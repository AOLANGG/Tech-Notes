## 元素的定位

web⾃动化测试的操作核⼼是能够找到⻚⾯对应的元素，然后才能对元素进⾏具体的操作。

常⻅的元素定位⽅式⾮常多，如id，classname，tagname，xpath，cssSelector

常⽤的主要由cssSelector和xpath

### cssSelector

选择器的功能：选中页面中制定的标签元素

选择器的种类分为基础选择器和复合选择器，常见的元素定位方式可以通过id选择器和子类选择器来进行定位

定位百度首页的“百度热搜”元素，可以通过使用id选择器和子类选择器定位：`#hotsearch-content-wrapper > li`

```python
# 1. 打开浏览器——驱动管理
ChromeIns = ChromeDriverManager().install()
driver = webdriver.Chrome(service=Service(ChromeIns))

# 2. 输入百度网址——https://www.baidu.com
driver.get("https://www.baidu.com/")
time.sleep(2)
ret = driver.find_elements(By.CSS_SELECTOR, "#hotsearch-content-wrapper > li")
for i in ret:
    # 获取每个元素对应的文本信息
    print(i.text)
driver.quit()
```

### xpath

XML路径语⾔，不仅可以在XML⽂件中查找信息，还可以在HTML中选取节点。

xpath使⽤路径表达式来选择xml⽂档中的节点

xpath语法中：

#### 获取HTML页面所有的节点

`//*`

#### 获取HTML页面指定的节点

`//[指定节点]`

#### 获取一个节点中的直接子节点

`/`

#### 获取一个节点的父节点

`..`

#### 实现节点属性的匹配

`[@...]`

#### 使用指定索引的方式获取对应的节点内容

注意：xpath的下标是从1开始的

更便捷的⽣成selector/xpath的⽅式：右键选择复制"Copy selector/xpath"

![img](https://i-blog.csdnimg.cn/direct/6213a0c64a1b49a69023da6b0fc1bc6c.png)

`//*[@id="hotsearch-content-wrapper"]/li[3]/a/span[2]`

## 操作测试对象

获取到页面的元素之后，接下来就是要对元素进行操作了。常见的操作有点击、提交、输入、清楚、获取文本

### 点击/提交对象

`click()`

```python
#找到百度⼀下按钮并点击
driver.find_element(By.CSS_SELECTOR, "#su").click()
```

### 模拟按键输入

`send_keys("")`

```python
driver.find_element(By.CSS_SELECTOR, "#kw").send_keys("迪丽热巴")
```

### 清除文本内容

输⼊⽂本后⼜想换⼀个新的关键词，这⾥就需要⽤到 clear()

```python
driver.find_element(By.CSS_SELECTOR, "#kw").send_keys("迪丽热巴")
time.sleep(1)
driver.find_element(By.CSS_SELECTOR,"#kw").clear()
time.sleep(1)
driver.find_element(By.CSS_SELECTOR, "#kw").send_keys("古⼒娜扎")
```

### 获取文本信息

如何判断获取到的元素对应的文本是否符合预期呢？

获取文本信息：`text`

```python
text = driver.find_element(By.XPATH,'//*[@id="hotsearch-contentwrapper"]/li[1]/a/span[2]').text
print(f"text:{text}")
```

问题：是否可以通过 text 获取到“百度⼀下按钮”上的⽂字“百度⼀下”呢？尝试⼀下

注意：⽂本和属性值不要混淆了。获取属性值需要使⽤⽅法 `get_attribute("属性名称")` ;

### 获取当前页面的标题

`title`

```python
title = driver.title
```



### 获取当前页面的URL

`current_url`

```python
url = driver.current_url
```

## 窗口

当我们⼿⼯测试的时候，我们可以通过眼睛来判断当前的窗⼝是什么，但对于程序来说它是不知道当前最新的窗⼝应该是哪⼀个。对于程序来说它怎么来识别每⼀个窗⼝呢？每个浏览器窗⼝都有⼀个唯⼀的属性句柄（handle）来表⽰，我们就可以通过句柄来切换

### 切换窗口

1. 获取当前页面句柄

`driver.current_window_handle`

2. 获取所有页面句柄

`deriver_window_handles`

3. 切换当前句柄为最新页面

```python
# 获取当前页面的句柄
curHandle = driver.current_window_handle
# 获取所有句柄
allHandle = driver.window_handles

for handle in allHandle:
    if handle != curHandle:
        driver.switch_to.window(handle)
```

### 窗口设置大小

#### 窗⼝的⼤⼩设置

```python
#窗⼝最⼤化
driver.maximize_window()
#窗⼝最⼩化
driver.minimize_window()
#窗⼝全屏
driver.fullscreen_window()
#⼿动设置窗⼝⼤⼩
driver.set_window_size(1024,768)
```

### 屏幕截图

⾃动化脚本⼀般部署在机器上⾃动的去运⾏，如果出现了报错，我们是不知道的，可以通过抓拍来记录当时的错误场景

`driver.save_screenshot('../images/image.png')`

```python
#简单版本
driver.save_screenshot('../images/image.png')
#⾼阶版本
filename = "autotest-"+datetime.datetime.now().strftime('%Y-%m-%d-
%H%M%S')+'.png'
driver.save_screenshot('../images/'+filename)
```

### 关闭窗口

```python
driver.close()
注意：窗⼝关闭后driver要重新定义
```

## 弹窗

 ![img](https://i-blog.csdnimg.cn/direct/c04420ea1c54415c842d9f82204c13a8.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)![img](https://i-blog.csdnimg.cn/direct/e348a2ba6b83482f904a0caefbc7157a.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)![img](https://i-blog.csdnimg.cn/direct/e57fcf8cbcd04068afc7e1453a509402.png)

```python
alert = driver.switchTo.alert
//确认
alert.accept()
//取消
alert.dismiss()
```

```python
alert = driver.switchTo.alert
alert.send_keys("hello")
alert.accept()
alert.dismiss()
```

## 等待

通常代码执⾏的速度⽐⻚⾯渲染的速度要快，如果避免因为渲染过慢出现的⾃动化误报的问题呢？可以使⽤selenium中提供的三种等待⽅法

### 强制等待

`time.sleep()`

优点：使用简单，调试的是由比较有效

缺点：影响运行效率，浪费大量时间

### 隐式等待

隐式等待是⼀种智能等待，他可以规定在查找元素时，在指定时间内不断查找元素。如果找到则代码继续执⾏，直到超时没找到元素才会报错

`implicityly_wait()`参数：秒

```python
#隐式等待5秒
driver.implicitly_wait(5)
```

隐式等待作⽤域是整个脚本的所有元素。即只要driver对象没有被释放掉（ driver.quit() ），隐式等待就⼀直⽣效。

优点：智能等待，作⽤于全局

### 显式等待

显⽰等待也是⼀种智能等待，在指定超时时间范围内只要满⾜操作的条件就会继续执⾏后续代码

WebDriverWait(driver,sec).until(functions)

functions ：涉及到selenium.support.ui.ExpectedConditions包下的 ExpectedConditions类

```python
from selenium.webdriver.support import expected_conditions as EC
wait = WebDriverWait(driver,2)
wait.until(EC.invisibility_of_element((By.XPATH,'//*
[@id="2"]/div/div/div[3]/div[1]/div[1]/div')))
```

`ExpectedConditions` 预定义⽅法的⼀些⽰例

| 方法                                         | 说明                                            |
| -------------------------------------------- | ----------------------------------------------- |
| title_is(title)                              | 检查⻚⾯标题的期望值                            |
| title_contains(title)                        | 检查标题是否包含区分⼤⼩写的⼦字符串的期望值    |
| visibility_of_element_located(locator, str]) | 检查元素是否存在于⻚⾯的DOM上并且可⻅的期望值。 |
| presence_of_element_located（locator，str]） | ⽤于检查元素是否存在于⻚⾯的DOM上的期望值       |
| visibility_of（element）                     | 检查已知存在于⻚⾯DOM上的元素是否可⻅的期望     |
| alert_is_present（）                         | 检查是否出现弹窗                                |

优点：显⽰等待是智能等待，可以⾃定义显⽰等待的条件，操作灵活

缺点：写法复杂

```python
#隐式等待设置为10s，显⽰等待设置为15s，那么结果会是5+10=15s吗？
driver.implicitly_wait(10)
wait = WebDriverWait(driver,15)
start = time.time()
try:
 res = wait.until(EC.presence_of_element_located((By.XPATH,'//*
[@id="2"]/div/div/div[3]/div[1]/div[1]/div/div/div')))
except:
 end = time.time()
 print("no such element")
driver.quit()
print(end-start)
```

`不要混合隐式和显式等待，可能会导致不可预测的等待时间`

## 浏览器导航

常见操作：

1. 打开网站

`driver.get("https://www.baidu.com/")`

2. 浏览器的前进、后退、刷新

```python
driver.back()
driver.forward()
driver.refresh()
```

## 文件上传

点击⽂件上传的场景下会弹窗系统窗⼝，进⾏⽂件的选择。

selenium⽆法识别⾮web的控件，上传⽂件窗⼝为系统⾃带，⽆法识别窗⼝元素

但是可以使⽤sendkeys来上传指定路径的⽂件，达到的效果是⼀样的

```python
driver.get("file:///D:/file/%E6%AF%94%E7%89%B9%E6%95%99%E5%8A%A1/%E6%B5%8B%E8%A
F%95/selenium4html/selenium-html/upload.html")
ele = driver.find_element(By.CSS_SELECTOR,"body > div > div > 
input[type=file]")
ele.send_keys("D:\\file\\test.txt")
```

## 浏览器参数设置

1. 设置无头模式

```python
options = webdriver.ChromeOptions()
options.add_argument("-headless")
driver = 
webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()),options
=options)
```

2. 页面加载策略

`options.page_load_strategy = '加载⽅式'`

| 策略   | 说明                                                |
| ------ | --------------------------------------------------- |
| normal | 默认值，等待所有资源下载                            |
| eager  | DOM访问已准备就绪，但注入图像的其他资源可能还在加载 |
| none   | 完全不会阻塞WebDriver                               |

```python
options = webdriver.ChromeOptions()
options.page_load_strategy = 'eager'
driver = webdriver.Chrome(service=ChromeService(ChromeDriverManager().install()),options=options)
```

