#### 排序子序列

- **题目链接**：[排序子序列](https://www.nowcoder.com/questionTerminal/2d3f6ddd82da445d804c95db22dcc471)
- **难度**：⭐⭐
- **标签**：`贪心`、`模拟`

#### 💡 题目描述

牛牛定义排序子序列为一个数组中一段连续的子序列,并且这段子序列是非递增或者非递减排序的。牛牛有一个长度为n的整数数组A,他现在有一个任务是把数组A分为若干段排序子序列,牛牛想知道他最少可以把这个数组分为几段排序子序列.
如样例所示,牛牛可以把数组A划分为[1,2,3]和[2,2,1]两个排序子序列,至少需要划分为2个排序子序列,所以输出2


示例1
输入

```
6
1 2 3 2 2 1
```

输出

```
2
```

#### 思路分析

要求把数组分成若干组，要求每组都是非递增或者非递减排序，求最少可以分为几组

 - 🧠  **算法图解**：
   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/065eb81ab8da4844aa4a34a368298cfa.png#pic_center)

 - 从左向右开始遍历数组中的每一个元素，考虑当前元素和下一个元素（如果存在）的大小关系——为了方便描述，当前元素我用`x`表示，下一个元素我用`y`来表示
   - 如果`x>y`，则说明这是一个递减排序，这时候就继续遍历，直到`x<y`或者遍历到结束，这就是一个递减排序
   - 如果`x<y`，则说明这是一个递增排序，这时候就继续遍历，直到`x>y`或者遍历到结束，这就是一个递增排序
   - 如果`x==y`，则不知道这是什么类型的排序，这时候继续遍历，直到遇到`x>y`或者`x<y`
 - 特殊情况
   - 如果遍历到最后一个位置，这个位置是没有下一个元素；不妨考虑一下，其实只要是遍历到这个元素，它就肯定是一个排序组，直接在结果上`+1`即可


2. ⚡ **代码实现**：

```cpp
// cpp版本
#include <iostream>

using namespace std;
const int N = 1e5+10;
int n,a[N];

int main(){
    cin>>n;
    for(int i = 0;i<n;i++)cin>>a[i];
    int i = 0,ret = 0;
    while(i<n){
        if(i==n-1){
            ret++;
            break;
        }
        if(a[i]<a[i+1]){
            while(i+1<n&&a[i]<=a[i+1])i++;
            ret++;
        }
        else if(a[i]>a[i+1]){
            while(i+1<n&&a[i]>=a[i+1])i++;
            ret++;
        }
        else{
            while(i+1<n&&a[i]==a[i+1])i++;
        }
        i++;
    }
    cout<<ret<<endl;
    return 0;
}
```

3. 💭  **复杂度分析**：
   - **时间复杂度**：O(N)，只需遍历链表一次。
   - **空间复杂度**：O(N)，用了数组`a`来存储元素

---
#### 消减整数

- **题目链接**：[消减整数](https://ac.nowcoder.com/acm/problem/219038)
- **难度**：⭐⭐
- **标签**：`贪心`、`数学`

#### 💡 题目描述

给出一个正整数H，从1开始减，第一次必须减1，每次减的数字都必须和上一次相同或者是上一次的两倍，请问最少需要几次能把H恰好减到0。


示例1
输入

```
3
3
5
7
```

输出

```
2
3
3
```

#### 思路分析

给定一个整数h，通过一定的操作，最少多少次可以变成0

 - 🧠  **算法图解**：
   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/82c3e7e5cf0b43f9ac0a61c1fa51bd5c.png#pic_center)

- 核心：把`h`减为0，操作次数最少

- 对于`-a`得到的$h^‘$，我们对它有两种操作
  - `-2a`：如果`-2a`，那么这个数在之后的操作中就只能使用`2a`或者`2a`的倍数来减到0，也就是说$h^‘$必须是`2a`的倍数
  - `-a`：没有要求，因为起点就是从1开始的
- 每次尽量使用`2a`，这样就能保证最少的操作次数

2. ⚡ **代码实现**：

```cpp
// cpp版本
#include <iostream>

using namespace std;

int main(){
    int t;
    cin>>t;
    while(t--){
        int h;
        cin>>h;
        int a = 1,ret = 0;
        while(h){
            h-=a;
            ret++;
            if(h%(2*a)==0)a*=2;
        }
        cout<<ret<<endl;
    }
    return 0;
}
```
---
#### 最长上升子序列(二)

- **题目链接**：[最长上升子序列(二)](https://www.nowcoder.com/practice/4af96fa010c44638a7e112abf65f7237?tpId=196&tqId=39285&ru=/exam/oj)
- **难度**：⭐⭐
- **标签**：`贪心`、`二分`

#### 💡 题目描述

给定一个长度为 n 的数组 a，求它的最长严格上升子序列的长度。 所谓子序列，指一个数组删掉一些数（也可以不删）之后，形成的新数组。例如 [1,5,3,7,3] 数组，其子序列有：[1,3,3]、[7] 等。但 [1,6]、[1,3,5] 则不是它的子序列。 我们定义一个序列是严格上升的，当且仅当该序列不存在两个下标 i 和 j 满足 i < j 且 a[i] ≥ a[j]。 数据范围：0 ≤ n ≤ 10^5，-10^9 ≤ a[i] ≤ 10^9 要求：时间复杂度 O(nlogn)，空间复杂度 O(n)

示例1
输入

```
[1,4,7,5,6]
```

输出

```
4
```

#### 思路分析

从数组中挑选一些数出来，相对顺序不变，求最长严格递增子序列的长度

 - 🧠  **算法图解**：
   ![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/01a252930c3c44e0a3c887e7765d7111.png#pic_center)
- 从当前的元素开始，在此之前的元素可以组成子序列，会得到相应的长度，每种长度保留最小的元素（保证之后的数可以轻松的拼接上此长度）
- 把所有的长度对应的最小元素存放在一个数组中，这个数组就是一个升序的数组，假设当前遍历到的元素是`x`
  - 如果`x`比最长长度对应的元素更大，说明最长长度应该更新
  - 否则，通过二分查找到对应的位置，更新某长度的最小元素


2. ⚡ **代码实现**：

```cpp
// cpp版本
class Solution {
    int pos = 0;
public:
    int LIS(vector<int>& a) {
        int n = a.size();
        vector<int>f(n+1,INT_MAX);
        for(int&x:a){
            if(pos==0||x>f[pos]){
                f[++pos] = x;
            }
            else{
                // 二分查找
                int l = 1,r = pos;
                while(l<r){
                    int mid = l+(r-l)/2;
                    if(f[mid]>=x)r = mid;
                    else l = mid+1;
                }
                f[l] = min(f[l],x);
            }
        }
        return pos;
    }
};
```
---
3. 💭  **复杂度分析**：
   - **时间复杂度**：O(N*log(N))，只需遍历链表一次。
   - **空间复杂度**：O(N)，用了数组`f`来存储对应长度的最小元素

---
