## 动态内存管理

### 为什么要有动态内存分配

在栈上开辟的空间有两特点

- 空间开辟的大小是固定的
- 数组在申明的时候，必须指定数组的长度，数组空间一旦确定了大小就不能调整

但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的遍历开辟空间的方式就不能满足了

C语言中移入了动态内存开辟，让哼许愿可以自己申请和释放空间，就比较灵活了

### malloc和free

#### malloc

C语言提供了动态内存开辟的函数

`void* malloc(size_t size);`

这个函数向内存中申请一块连续可用的空间，并返回只想这个空间的指针

- 如果开辟成功，则返回一个指向开辟好空间的指针
- 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查
- 返回值的类型是`void*`，所以malloc函数并不知道开辟空间的类型，具体使用的时候使用者自己来决定
- 如果参数size为0，malloc的行为是标准未定义的，这取决于编译器

#### free

`void free(void* ptr)`

free函数用来释放动态开辟的内存

- 如果参数ptr指向的空间不是动态开辟的，那么free函数的行为是未定义的
- 如果参数ptr是NULL指针，则函数什么都不做

#### calloc和realloc

`calloc`函数也用来动态内存分配

`void* calloc(size_t num,size_t size)`

- 函数的功能是为num个大小为size的元素开辟一块空间，并且把空间得到每个字节都初始化成0
- 和函数malloc的区别只在于calloc在返回地址之前把申请的空间的每个字节初始化为0

`realloc`

- realloc函数的出现让动态内存管理更加灵活
- 有时我们发现之前申请的空间太小了，有时我们又会觉得申请的空间太大了，那为了合理的使用内存，我们一定会堆内存的大小进行灵活的调整。那`realloc`函数就可以做到对动态开辟内存大小的调整

`void* realloc(void* ptr,size_t size)`

- `ptr`是要调整的内存地址
- `size`调整之后的新大小
- 返回值为调整之后的内存的起始地址
- 这个函数调整原内存大小空间的基础上，还会降内存中的数据移动到新的空间中
- `realloc`在调整内存空间存在两种情况
  - 原有空间之后又足够大的空间
  - 原有空间之后没有足够大的空间



**情况1**
当是情况1 的时候，要扩展内存就直接原有内存之后直接追加空间，原来空间的数据不发生变化。

**情况2**
当是情况2 的时候，原有空间之后没有足够多的空间时，扩展的方法是：在堆空间上另找一个合适大小的连续空间来使用。这样函数返回的是一个新的内存地址

## C/C++中程序内存区域的划分

C/C++程序内存分配的几个区域

1. 栈区：在执行函数的时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有效。栈区主要存放运行函数而分配的局部变量、函数参数、返回数据、返回地址等。
2. 堆区：一般由程序员分配释放，若程序员不释放，程序结束之后又OS回收
3. 数据段（静态区）：存储全局变量，静态数据。程序 结束之后又系统释放。
4. 代码段：存放函数体（类成员函数和全局函数）的二进制代码

![img](https://i-blog.csdnimg.cn/direct/72f7db1c4b764d79be1308c0d2a76928.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

## 文件操作

### 二进制文件和文本文件

根据数据的组织形式，数据文件被称为**文本文件**和**二进制文件**

数据在内存中以二进制的形式存储，如果不加转换的输出到外存的文件中，就是**二进制文件**

如果要求在外存上以ASCII吗的形式存储，则需要再存储钱转换。以ASCII字符的形式存储到额文件就是**文本文件**

文本文件和二进制文件的区别

| 维度     | 文本文件                                          | 二进制文件                                   |
| -------- | ------------------------------------------------- | -------------------------------------------- |
| 存储方式 | 按字符编码规则存储（如 1 个 UTF-8 汉字占 3 字节） | 按数据本身的二进制格式存储（无固定编码）     |
| 可读性   | 文本编辑器可直接读取（人类能懂）                  | 直接打开是乱码，需专用软件解析               |
| 用途     | 存储纯文字信息（如文档、代码、日志）              | 存储多媒体、程序、压缩包等复杂数据           |
| 结构     | 结构简单，按 “行” 或 “字符序列” 组织              | 结构复杂，有自定义格式（如图片有像素头信息） |

文本文件和二进制文件的联系

- 本质相同：两者在计算机底层均以**二进制字节流**（0 和 1）形式存储，无绝对物理界限；
- 包含关系：文本文件可视为 “特殊的二进制文件”—— 它是按固定字符编码规则排列的二进制数据，而二进制文件是 “无固定编码的通用二进制数据”。

### 文件的打开和关闭

C语言在启动的时候默认打开了三个流

- stdin 标准输入流，再打所属的环境中从键盘输入，scanf函数就是冲标准输入流中读取数据
- stdout 标准输出流，大所述环境中输出值显示器解密那，printf函数就是将信息输出到标准输出流中
- stderr 标准错误流，大多数环境中输出到显示器界面

### 文件指针

缓冲文件系统中，关键概念就是“**文件类型指针**”，简称**文件指着**

每个使用的文件都在内存中开辟了一个相应的**文件信息区**，用来存放文件的相关信息（如文件的名字，文件状态以及文件当前的位置）。这些信息是保存在一个结构体变量中的。该结构体类型是由系统声明的，取名**FILE**



文件在读写之前应该先**打开文件**，在结束使用应该**关闭文件**

在编写程序的时候，在打开文件的同时，都会返回一个FILE* 指针变量指向这个文件，也相当于建立指针和文件之间的关系

`ANSIC` 规定`fopen`函数来打开文件，`flcose`来关闭文件

mode表示文件的打开方式，下面都是文件的打开方式



![img](https://i-blog.csdnimg.cn/direct/18a46d6be5c84f098604b0684c099903.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

### 顺序读写函数介绍

| 函数名  | 功能           | 适用于     |
| ------- | -------------- | ---------- |
| fgetc   | 字符输入函数   | 所有输入流 |
| fputc   | 字符输出函数   | 所有输出流 |
| fgets   | 文本行输入函数 | 所有输入流 |
| fputs   | 文本行输出函数 | 所有输出流 |
| fscanf  | 格式化输入函数 | 所有输入流 |
| fprintf | 哥书画输出函数 | 所有输出流 |
| fread   | 二进制输入     | 文件输入流 |
| fwrite  | 二进制输出     | 文件输出流 |

上面说的适用于所有的输出流一般指适用于标注输入流和其他输入流（比如文件输入流）；所有输出流一般指使用与标准输出流和其他输出流（比特文件输出流）

### 文件随机读写

#### fseek

根据文件指针的位置和偏移量来定位文件指针（文件内容的光标）

`int fseek(FILE* stream,long int offset,int origin);`

#### ftell

返回文件指针相对于起始位置的偏移量

`long int ftell(FILE* stream);`

#### rewind

让文件指针的位置回到文件的起始位置

`void rewind(FILE*stream)`

### 文件读取结束的判定

1. 文本文件是否结束，判断返回值是否为`EOF`（`fgetc`），或者`NULL`(`fgets`)
2. 二进制的读取结束判断，判断返回值是否小于实际要读的个数

- fread判断返回值是否小于实际要读的个数

### 文件缓冲区

ACSIC标准采用**换种文件系统**处理数据文件，所谓缓冲文件系统是指系统自动的在内存为程序中每一个正在使用的文件开辟一个“**文件缓冲区**”。从内存向磁盘输出数据会先送到内存中的缓冲区，装满缓冲区之后才会一起送到磁盘。如果从磁盘向计算机读入数据，则从磁盘文件中读取数据输入到内存缓冲区，然后再从缓冲区逐个地将数据送到程序数据区（程序变量等）。缓冲
区的大小根据C编译系统决定

![img](https://i-blog.csdnimg.cn/direct/0eeb1c196ebe4934ab33f159f7598b28.png)![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)因为有缓冲区的存在，C语言在操作文件的时候，需要做刷新缓冲区或者在文件操作结束的时候关闭文件。

如果不做，可能导致读写文件的问题
