## 字符串函数

### strlen

`sizeof和strlen的区别`

| 特性       | `sizeof`                     | `strlen`                        |
| ---------- | ---------------------------- | ------------------------------- |
| 性质       | 运算符（编译期计算）         | 库函数（运行期计算）            |
| 作用对象   | 任意数据类型 / 变量 / 表达式 | 以`'\0'`结尾的字符串（`char*`） |
| 计算内容   | 内存总字节数（包含所有部分） | 有效字符数（不包含`'\0'`）      |
| 依赖`'\0'` | 不依赖                       | 必须依赖（否则行为未定义）      |
| 头文件     | 不需要                       | 需要`#include <string.h>`       |

`模拟实现strlen`

```c++
size_t myStrlen(const char* str) {
	size_t len = 0;
	if (str) {
		while (*str) {
			len++;
			str++;
		}
	}
	return len;
}
```

### strcpy

```c
char* myStrcpy(char* dest, const char* src) {
	if (dest == NULL || src == NULL)return NULL;
	char* ret = dest;
	while ((*dest++ = *src++) != '\0');
	return ret;
}
```



### strcat

```c
char* myStrcat(char* dest, const char* src) {
	if (dest == NULL || src == NULL)return NULL;
	char* ret = dest;
	while (*dest != '\0') {
		dest++;
	}
	while ((*dest++ = *src++) != '\0');
	return ret;
}
```



### strstr

```c
char* myStrstr(const char* str1, const char* str2) {
	if (str1 == NULL || str2 == NULL)return NULL;
	if (*str2 == '\0')return (char*)str1;
	const char* s1 = str1;
	const char* s2 = str2;
	const char* current = str1;
	while (*current != '\0') {
		s1 = current;
		s2 = str2;
		while (*s1 != '\0' && *s2 != '\0' && *s1 == *s2) {
			s1++, s2++;
		}
		if (*s2 == '\0')
		{
			return (char*)current;
		}
		current++;
	}
	return NULL;
}
```

## 内存函数

### memcpy

- 函数memcpy从source的位置开始向后复制数据到destination指向的位置
- 这个函数在遇到'\0'的时候不会停下来
- 如果source和destination有重叠的时候，复制的结果是未定义的

先来举一个没有重叠的情况

```c++
#include <iostream>
#include <cstring>

int main()
{
	int arr1[] = { 1,2,3,4,5,6,7,8 ,9,10 };
	int arr2[20]{};
	memcpy(arr2, arr1, sizeof arr1);
	for (int i = 0; i < 20; ++i)
		std::cout << arr2[i] << ' ';
	//1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0
	return 0;
}
```

这是一个有重叠的情况
```c++
#include <iostream>
#include <cstring>

int main()
{
	int arr[20] = { 1,2,3,4,5,6,7,8 ,9,10 };
	memcpy(arr + sizeof(int), arr, sizeof(int) * 10);
	for (int i = 0; i < 20; ++i)
		std::cout << arr[i] << ' ';
	//1 2 3 4 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0
	return 0;
}
```

可以看出来这种结果并不是我们所期望的，所以memcpy不适合有重叠的拷贝。有重叠的拷贝应当使用memmove来操作

下面来模拟一下memcpy的实现

```c++
void* myMemcpy(void* dst, const void* src, size_t count) {
	void* ret = dst;
	assert(dst);
	assert(src);
	for (size_t i = 0; i < count; i++) {
		*(char*)dst = *(char*)src;
		dst = (char*)dst + 1;
		src = (char*)src + 1;
	}
	return ret;
}
```

### memmove

- 和memcpy的差别就是memmove函数处理的元内存块和目标内存是可以重叠的

**很明显，只需要倒序拷贝就可以了，模拟实现代码如下：**

```cpp
void* myMommove(void* dst, void* src, size_t count) {
	void* ret = dst;
	assert(dst);
	assert(src);
	dst = (char*)dst + count;
	src = (char*)src + count;
	for (size_t i = 0; i < count; ++i)
	{
		*(char*)dst = *(char*)src;
		dst = (char*)dst - 1;
		src = (char*)src - 1;
	}
	return ret;
}
```

## 整型和字符串转换函数

### atoi

```c++
int myAtoi(const char* str) {
    // 跳过前导空白字符
    while (isspace((unsigned char)*str)) {
        str++;
    }
    int sign = 1;
    if (*str == '-') {
        sign = -1;
        str++;
    }
    else if (*str == '+') {
        str++;
    }
    long long result = 0;
    while ('0'<= * str&&'9'>=*str) {
        result = result * 10 + (*str - '0');
        str++;
    }
    return (int)(sign * result);
}
```



### itoa

```c++
// 辅助函数：反转字符串
void reverse_str(char* start, char* end) {
    while (start < end) {
        char temp = *start;
        *start = *end;
        *end = temp;
        start++;
        end--;
    }
}

char* myItoa(int value,char* str) {
    if (str == NULL)return NULL;
    if (value == 0) {
        str[0] = '0';
        str[1] = '\0';
        return str;
    }
    int sign = 1;
    if (value < 0) {
        sign = -1;
        value = -value;
    }
    char* ptr = str;
    while (value) {
        *ptr = (value % 10) + '0';
        ptr++;
        value /= 10;
    }
    if (sign == -1) {
        *ptr++ = '-';
    }
    *ptr = '\0';
    reverse_str(str, ptr - 1);
    return str;
}
```



