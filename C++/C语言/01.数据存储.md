## 数据的存储

### 整型的储存

**正整数的原、反、补码都相同**

**负整数的三种表示方法各不相同**



**原码**：直接将数值按照正负数的形式翻译成二进制得到的就是原码

**反码**：将原码的符号位不变，其余位按位取反就可以得到反码

**补码**：反码+1就得到补码

对于整型来说：数据存放在内存中其实就是存放的二进制的补码

### 大小端字节序和字节序的判断

**大小端**：超过一个字节的数据在内存中存储的时候，要考虑存储顺序的问题，按照不同的存储顺序，可以分为打断字节序存储和小端字节序存储。

**大端模式**：数据的低位字节内容保存在内存的高地址处，而数据的高位字节内容，保存在内存的低地址处。

**小端模式**：数据的低位字节内容保存在内存的低地址处，而数据的高位字节内容，保存在内存的高地址处

==设计一个程序来判断当前机器的字节序== -- 百度笔试题

```c
#include <iostream>

int check_sys(){
    int i = 1;
    return *((char*)&i);
}

int main(){
    if(check_sys())std::cout<<"小端"<<std::endl;
    else std::cout<<"大端"<<std::endl;
    return 0;
}
```

```c
#include <iostream>

int check_sys()
{
    union
    {
        int i;
        char c;
    } un;
    un.i = 1;
    return un.c;
}
int main()
{
    if (check_sys())
        std::cout << "小端" << std::endl;
    else
        std::cout << "大端" << std::endl;
    return 0;
}
```

## 浮点数的存储

==V = $(−1) ^S$* ∗ *M* ∗ 2$ ^E$==

对于32位的浮点数(float)，最⾼的1位存储符号位S，接着的8位存储指数E，剩下的23位存储有效数字M

对于64位的浮点数(double)，最⾼的1位存储符号位S，接着的11位存储指数E，剩下的52位存储有效数字M



**IEEE 754 对有效数字M和指数E，还有⼀些特别规定。**

IEEE 754 规定，在计算机内部保存M时，默认这个数的第⼀位总是1，因此可以被舍去，只保存后⾯的xxxxxx部分。⽐如保存1.01的时候，只保存01，等到读取的时候，再把第⼀位的1加上去。这样做的⽬的，是节省1位有效数字。以32位浮点数为例，留给M只有23位，将第⼀位的1舍去以后，等于可以保存24位有效数字。

**⾸先，E为⼀个⽆符号整数（unsigned int）**

这意味着，如果E为8位，它的取值范围为0~255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法中的E是可以出现负数的，所以IEEE 754规定，存⼊内存时E的真实值必须再加上⼀个中间数，对于8位的E，这个中间数是127；对于11位的E，这个中间数是1023。⽐如，2^10的E是10，所以保存成32位浮点数时，必须保存成10+127=137，即10001001。

**E不全为0或不全为1（常规情况）**

这时，浮点数就采⽤下⾯的规则表⽰，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第⼀位的1。

**E全为0**

这时，浮点数的指数E等于1-127（或者1-1023）即为真实值，有效数字M不再加上第⼀位的1，⽽是还原为0.xxxxxx的⼩数。这样做是为了表⽰±0，以及接近于0的很⼩的数字

**E全为1**

这时，如果有效数字M全为0，表⽰±⽆穷⼤（正负取决于符号位s）