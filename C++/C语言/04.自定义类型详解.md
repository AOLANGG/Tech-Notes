## 结构体内存对齐

结构体就是一些数据类型的集合

**内存对齐的对齐规则**

1. 结构体的第一个成员对齐到和结构体变量起始位置偏移量为0的地址处
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
   - 对齐数：= 编译器默认的一个对齐数与该成员变量大小的较小值
   - VS中默认的值是8
   - Linux中gcc没有默认的对齐数，对齐数就是成员自身大小
3. 结构体的大小为最大对齐数（结构器中每个成员变量都有一个对齐数，所有对齐数中最大的）的整数倍
4. 如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍

下面是一些案例，帮助理解

```C++
struct Example1 {
    char a;     // 大小1，对齐数1
    int b;      // 大小4，对齐数4
    short c;    // 大小2，对齐数2
};
```

- a是`char`类型，1字节，对齐数是1，位置是0
- b是`int`类型，4字节，对齐数是4，位置是4~7
- c是`short`类型，2字节，对齐数是2，位置是8~9，但是最大对齐数是4，需要补齐到4的倍数
- 所以整体的大小就是12

```c++
struct Example2 {
    char a;     // 大小1，对齐数1
    short c;    // 大小2，对齐数2  
    int b;      // 大小4，对齐数4
};
```

- a类型是`char`类型，1字节，对齐数是1 ，位置是0
- c类型是`short`类型，2字节，对齐数是2，位置是2~3
- b类型是`int`类型，4字节，对齐数是4，位置是4~7
- 所以整体的大小就是8

```c++
struct Inner {
    double d; // 大小为8，对齐数是8
    char e; // 大小为1 ，对齐数为1
};
struct Outer {
    int a; // 大小4 对齐数4
    struct Inner b; // 大小为16 对齐数是8
    short c; // 大小2 对齐数2
};
```

- 在Inner中
  - d是`double`类型，8字节，对齐数是8，位置是0~7
  - e是`char`类型，大小是1，对齐数是1，位置是8
  - 整体的大小就是16
- 在Outer中
  - a的类型是`int`，4字节，对齐数是4，位置是0~3
  - b的类型是`struct Inner`，16字节，对齐数是8，位置是8~23
  - c的类型是`char`，1字节，对齐数是1，位置是24，但是最大对齐数是8，需要补全到8的倍数，也就是32
  - 整体的大小就是32

```c++
struct Example4 {
    char a;         // 大小1，对齐数1
    int arr[3];     // 大小12，对齐数4
    double b;       // 大小8，对齐数8
};
```

- `char a`：偏移0，占用1字节
- `int arr[3]`：对齐数4，从偏移4开始，占用4-15（3×4=12字节）
- `double b`：对齐数8，从偏移16开始，占用16-23
- 总大小：24字节，最大对齐数8，已经是8的倍数 

## 共用体（联合体）

像结构体一样，联合体也是由一个或者多个成员构成的，这些成员可以是不同的类型

但是编译器值为最大的成员分配足够的内存空间。联合体的特点就是所有的成员共用同一块内存空间。所以联合体也叫共用体

给联合体其中的一个成员复制，其他成员的值也会跟着变化

**联合体的特点**

联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是以最大成员的大小（因为联合体至少得有能力保存最大的那个成员）

### 联合体大小的计算

- 联合的大小至少是最大成员的大小
- 当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍

```c++
#include <stdio.h>
union Un1
{
	char c[5];
	int i;
};
union Un2
{
	short c[7];
	int i; 
};
int main()
{
	//下面输出的结果是什么？
	printf("%zd\n", sizeof(union Un1)); // 8
	printf("%zd\n", sizeof(union Un2)); // 16
	return 0;
}
```

用联合体来判断当前机器的大小端

```c++
int check_sys()
{
	union
	{
		char c;
		int x;
	}un;
	un.x = 1;
	return un.c; // 1表示小端，否则表示大端
}
```

## 枚举

枚举的优点：

1. 增加代码的可读性和可维护性
2. 和`#define`定义的标识符比较枚举有类型检查，更加严谨。
3. 便于调试，预处理阶段会删除`#define`定义的负号
4. 使用方便，一次可以定义多个常量
5. 枚举常量是遵循作用域规则的，枚举声明在函数内，只能在函数中使用

缺点：

1. 取值不可动态扩展：运行时无法新增/删除值
2. 性能开销：比基本类型更占资源
3. 序列化/反序列化风险：结构变化导致异常
4. 语言支持差异大，部分语言需模拟实现
5. 简单场景易导致代码冗余