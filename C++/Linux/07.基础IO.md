**写**

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main()
{
    umask(0);
    int fd = open("myfile",O_WRONLY|O_CREAT,0644);
    if(fd<0){
        perror("open");
        return 1;
    }
    int count = 5;
    const char* msg = "hello bite\n";
    int len = strlen(msg);

    while(count--){
        write(fd,msg,len);
    }
    close(fd);
    return 0;
}
```

**读**

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>

int main()
{
    int fd = open("myfile",O_RDONLY);
    if(fd<0){
        perror("open");
        return 1;
    }
    const char* msg = "hello bite\n";
    char buf[1024];
    while(1){
        ssize_t s = read(fd,buf,strlen(msg));
        if(s>0){
            buf[s] = 0;
            printf("%s",buf);
        }
        else break;
    }
    close(fd);
    return 0;
}
```



## 接口介绍

`open`

```
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
pathname: 要打开或创建的目标文件
flags: 打开文件时，可以传入多个参数选项，用下面的一个或者多个常量进行“或”运算，构成flags。
参数:
 O_RDONLY: 只读打开
 O_WRONLY: 只写打开
 O_RDWR : 读，写打开
 这三个常量，必须指定一个且只能指定一个
 O_CREAT : 若文件不存在，则创建它。需要使用mode选项，来指明新文件的访问权限
 O_APPEND: 追加写
 返回值：
 成功：新打开的文件描述符
 失败：-1
```

open 函数具体使用哪个，和具体应用场景相关，如目标文件不存在，需要open创建，则第三个参数表示创建文件的默认权限, 否则，使用两个参数的open。

- 上面的 fopen fclose fread fwrite 都是C标准库当中的函数，我们称之为库函数（libc）
- 而， open close read write lseek 都属于系统提供的接口，称之为系统调用接口

![img](https://i-blog.csdnimg.cn/direct/c59c2a96589d46c6895d5639dc83ff9c.png)

系统调用接口和库函数的关系，一目了然

可以认为，f#开头的函数，都是对系统调用的封装，方便二次开发

## 文件描述符fd

- 通过对`open`函数的学习，知道了文件描述符是一个小整数

### 0 & 1 & 2

- Linux进程默认情况下会有3个打开的文件描述符，分别是标准输入0， 标准输出1， 标准错误2
- 0,1,2对应的物理设备一般是：键盘，显示器，显示器

![img](https://i-blog.csdnimg.cn/direct/8acd5d1c8bda49cea213c63c309fcd31.png)

而现在知道，文件描述符就是从0开始的小整数。当我们打开文件时，操作系统在内存中要创建相应的数据结构来描述目标文件。于是就有了file结构体。表示一个已经打开的文件对象。而进程执行open系统调用，所以必须让进程和文件关联起来。每个进程都有一个指针*files, 指向一张表files_struct,该表最重要的部分就是包涵一个指针数组，每个元素都是一个指向打开文件的指针！所以，本质上，文件描述符就是该数组的下标。所以，只要拿着文件描述符，就可以找到对应的文件

### 文件描述符的分配规则

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

int main()
{
    close(0);
    int fd = open("myfile", O_RDONLY);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    printf("fd: %d\n", fd);
    close(fd);
    return 0;
}
```

发现是结果是： fd: 0 或者 fd 2 可见，文件描述符的分配规则：在files_struct数组当中，找到当前没有被使用的最小的一个下标，作为新的文件描述符

### 重定向

那如果关闭1呢？看代码：

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    close(1);
    int fd = open("myfile", O_WRONLY | O_CREAT, 00644);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    printf("fd: %d\n", fd);
    fflush(stdout);

    close(fd);
    return 0;
}
```



此时，我们发现，本来应该输出到显示器上的内容，输出到了文件 myfile 当中，其中，fd＝1。这种现象叫做输出

重定向。常见的重定向有:>, >>, < 

那重定向的本质是什么呢？

![img](https://i-blog.csdnimg.cn/direct/f8aa6972487849709825fd9e0c6f6373.png)

## 使用dup2系统调用

函数原型

```c++
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

 

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>

int main()
{
    int fd = open("./log", O_CREAT | O_RDWR);
    if (fd < 0)
    {
        perror("open");
        return 1;
    }
    close(1);
    dup2(fd, 1);
    for (;;)
    {
        char buf[1024] = {0};
        ssize_t read_size = read(0, buf, sizeof(buf) - 1);
        if (read_size < 0)
        {
            perror("read");
            break;
        }
        printf("%s", buf);
        fflush(stdout);
    }
    return 0;
}
```

## FILE

- 因为IO相关函数与系统调用接口对应，并且库函数封装系统调用，所以本质上，访问文件都是通过fd访问的。
- 所以C库当中的FILE结构体内部，必定封装了fd

```c++
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    const char *msg0 = "hello printf\n";
    const char *msg1 = "hello fwrite\n";
    const char *msg2 = "hello write\n";
    printf("%s", msg0);
    fwrite(msg1, strlen(msg0), 1, stdout);
    write(1, msg2, strlen(msg2));
    fork();
    return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/ded52e5161e640f5a8df8a00df89dd98.png)

我们发现 printf 和 fwrite （库函数）都输出了2次，而 write 只输出了一次（系统调用）。为什么呢？肯定和fork有关

- 一般C库函数写入文件是全缓冲，而写入显示器是行缓冲
- printf、fwrite库函数会自带缓冲区，当发生重定向普通文件的时候，数据的缓冲方式变为了全缓冲
- 放在缓冲区的数据不会被立刻刷新，甚至fork之后
- 但是进程退出之后，会统一刷新，写入文件中
- 但是在fork时候，父子数据会发生写时拷贝，当父进程准备刷新的时候，子进程也就有同样的一份数据，随机产生两份数据
- write没有变化，说明没有所谓的缓冲

综上： printf fwrite 库函数会自带缓冲区，而 write 系统调用没有带缓冲区。另外，我们这里所说的缓冲区，都是用户级缓冲区。其实为了提升整机性能，OS也会提供相关内核级缓冲区

 printf fwrite 是库函数， write 是系统调用，库函数在系统调用的“上层”， 是对系统调用的“封装”，但是 write 没有缓冲区，而 printf fwrite 有，足以说明，该缓冲区是二次加上的，又因为是C，所以由C标准库提供

## 理解文件系统

我们在使用`ls -l`的时候可以看到除了文件名，还有文件元数据

```
aolang@iZn4a7iqb8xkd5ni3g5evbZ:~/algo$ ls -l
total 28
-rw-rw-r-- 1 aolang aolang    64 Oct 21 21:14 file
-rwxrwxr-x 1 aolang aolang 16160 Oct 21 21:46 main
-rw-rw-r-- 1 aolang aolang   346 Oct 21 21:46 main.cc
-rw-rw-r-- 1 aolang aolang    71 Oct 14 23:44 makefile
```

每行包含7列

- 模式
- 硬链接数
- 文件所有者
- 组
- 大小
- 最后修改时间
- 文件名

其实这个信息除了通过这种方式来读取，还有一个stat命令能够看到更多信息

```
aolang@iZn4a7iqb8xkd5ni3g5evbZ:~/algo$ stat main.cc 
  File: main.cc
  Size: 346             Blocks: 8          IO Block: 4096   regular file
Device: fc03h/64515d    Inode: 416841      Links: 1
Access: (0664/-rw-rw-r--)  Uid: ( 1001/  aolang)   Gid: ( 1001/  aolang)
Access: 2025-10-21 21:46:47.714414324 +0800
Modify: 2025-10-21 21:46:47.566409806 +0800
Change: 2025-10-21 21:46:47.566409806 +0800
 Birth: 2025-10-14 23:25:20.292209291 +0800
```

### 磁盘概述

**磁盘是计算机的主要存储介质，可以存储大量的二进制文件，并且断电也不会丢失数据**。

#### 磁盘构造

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1df96824cb6ebd247ce10b4673dc68b1.png)

磁盘是由盘片构成的。每个盘片有两面或者称为表面，表面覆盖着磁性记录材料。对于每个磁性单位，磁化表示1，未磁化表示0。盘片中央有一个可以旋转的主轴，它使得盘片以固定的旋转速率旋转。在旋转的过程中，磁臂带动着磁头来回摆动来读取信息。盘面和磁头的数量是1：1，也就是说，每一个盘面都有一个负责读取其数据的磁头。

此外，磁头与磁盘之间是**有一定空隙**的，如果磁头和磁盘接触，加上旋转带来的摩擦，很容易刮花盘面，从而导致数据丢失。这也为什么磁盘在摔过之后就很容易坏掉。
总的来说，一个磁盘的主要组成成分包括：盘片、主轴、磁头、磁臂以及驱动马达等，它们被封装在一个密封的包装里，整个装置被称为磁盘驱动器



每个盘面都是由一组称为磁道(track) 的同心圆组成。每个磁道被划分为一组 扇区（sector）。每个扇区包含相等数量的数据位（512 byte），这些数据编码在扇区的磁性材料中。扇区之间由一些间隙分隔开，这些空隙不存储数据位。间隙用来存储用来标识扇区的格式化位。 文件存在磁盘的一个个扇区里。(打开的文件理论上也是拷贝了一份磁盘文件到内存)。
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/c96c4354e7590b42131b9da1fa2d4f95.png)

我们将所有盘片表面上到主轴中心的距离相等的磁道集合称为柱面。例如，假设一个磁盘驱动器里有三个盘片（六个盘面），每个表面的磁道的编号都是一样的，那么柱面x，就是六个x号磁道的集合

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/d57665eeeddd54081d3068677de2d666.png)

一般来说，扇区是磁盘的最小存储单元。如果每次读写数据都是以一个扇区为单位就会使得读写的效率非常低。假设我们要读1G（1024*1024*1024byte）大小的文件,那就要连续读1024*1024*2次。所以文件系统把多个扇区组成一个块（逻辑块），每个块占4kb的字节大小（包含八个扇区）。每次读写就是按块来读写，提高了整体的读写效率。（1k=$2^{10}$byte）

需要弄清楚的是，**扇区是磁盘的最小存储单位而不是读取数据的最小单位。** 块才是

#### CHS寻址

既然扇区是磁盘存储数据的单元，那如何在磁盘中找到目标扇区呢？
要想确定一个扇区的位置，需要以下步骤

1. 找到目标扇区所在的**盘面**。
2. 找到目标扇区所在的**磁道**。
3. 在磁道中确定哪一个**扇区**。

同样的，如果我们确定了一个柱面(**Cylinder**)，再确定柱面上的一个磁头（**Head**），也就能找到一个唯一的磁道，再在该磁道找到的扇区(**Sector**)就是唯一的目标扇区了。我们把上面的寻址方法称为CHS寻址法。对于CHS寻址法，只需要知道上面不同的三个参数，找到一个唯一的扇区！

#### 磁盘的抽象存储结构

为了便于寻址，我们可以先将整个磁盘抽象成一个线性的连续的数组，每个元素当然就对应着一个盘面

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/0b4b616350f8c06a055bf2da7317eb4c.png)

这样划分显得太粗糙了，我们再接着继续细分。把每一个盘面划分成诺干个大小相同的磁道，于是整个数组的最小元素就变成了磁道。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/feed624ea3e5acd6989c02b44430a8a6.png)

即使是这样，也还是不够，再继续细分。把每个磁道划分为诺干个大小相同的扇区，于是整个数组的最小元素就变成了一个扇区。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/f8a76893e8c83d6f1684464d0838f0c2.png)

这样一来，整个数组就是磁盘中所有扇区的集合。每个元素都对应着一个扇区的地址，每一个扇区都有唯一的一个下标映射。将来我们想要找某一个扇区，只需要用它在数组中的下标就能找到该扇区的CHS。

```
假设每个磁道上有100个扇区，每个盘面有100个磁道。现在想找到下标index=50505对应的扇区的CHS地址：
根据假设信息，一个盘面有100*100=10000个扇区。

盘面位置（H）=index/10000=5，即该扇区在第五盘面。

磁道位置( C)=(index%10000)/100=5,即该扇区在第五盘面的第五磁道上。

扇区位置(S)=index%100=5,即该扇区位置在第五盘面的第五磁道的第五个扇区的位置。
```

这样一来，**系统只需要管理好这个数组，就等于变相的管理好整个磁盘了！又因为读写数据的最小单位是数据块而不是扇区，为了方便文件系统读写数据，我们还需要将上面的数组进一步抽象成以数据块为单位**的数组。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/b59bca535275bab7866eb301eef3e9e8.png)

### 理解文件系统

虽然我们已经可以将磁盘分为一个个数据块，但是对于空间巨大的磁盘来说还是太小了！（直接管理的对象太多了）现在我们的计算机大一点的都是以t为单位了，一个t就有多少数据块？为了便于管理，我们又将磁盘划分为诺干个分区。比如一个500GB的磁盘，我们可以划分为5个分区，每个分区管理100GB。只要操作系统能管理好一个分区，我们用同样的方式就能管理好其它所有的分区 。

那么如何管理好一个分区呢？

将一个分区按组划分，假设每个组的大小为2GB,那么一个分区就有50个组。根据分治思想，只要我们想办法管理好一个组，也就能用样的方法管理好所有组 **(Block group[]**)，进而管理好整个分区。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/4053798b289bd9bec672c778f7e2f447.png)

Linux ext2文件系统，上图为磁盘文件系统图（内核内存映像肯定有所不同）。磁盘是典型的块设备，硬盘分区被划分为一个个的block。一个block的大小是由格式化的时候确定的，并且不可以更改。例如mke2fs的-b选项可以设定block大小为1024、2048或4096字节。而上图中启动块（Boot Block）的大小是确定的，

启动块Boot Block存放的是操作系统的核心数据，每当计算机开机都需要先从Boot Block读取数据才能正常启动。

每个Block group里都存着以下信息
```
Super Block(超级块)：存放文件系统本身的结构信息。记录的信息主要有：bolck 和 inode的总量，未使用的block和inode的数量，一个block和inode的大小，最近一次挂载的时间，最近一次写入数据的时间，最近一次检验磁盘的时间等其他文件系统的相关信息。Super Block的信息被破坏，可以说整个文件系统结构就被破坏了。

GDT，Group Descriptor Table：块组描述符，描述块组属性信息

块位图（Block Bitmap）：Block Bitmap中记录着Data Block中哪个数据块已经被占用，哪个数据块没有被占用。

inode位图（inode Bitmap）：每个bit表示一个inode是否空闲可用。

inode节点表:存放文件属性 如 文件大小，所有者，最近修改时间等

Data blocks 数据区：存放文件内容
```

我们常说文件=内容+属性，其实可以理解为文件=inode+Data blocks。
结合上图可以看到，每个组包含了诺干个大小不一的文件，文件系统将这些文件的属性和内容分开存放。除此之外还设置了一些区域存放用来管理组内文件的信息，比如GDT、Block Bitmap等。每一个文件的属性inode表里记录着文件内容所占数据块的位置。

### 理解inode

inode又称为索引节点。每一个文件都有唯一对应的inode。inode表现为一个**号码**,存放着除了文件名之外的所有信息：文件大小，文件最近修改时间，文件内容在Data blocks中的位置等。	

```c++
struct inode{
    inode 编号；
    文件类型；
    权限；
    引用计数；
    拥有者；
    所属组；
    ACM时间；
    int datablocks[10];//文件内容所占的块号位置
}
```

**acm**

下面解释一下文件的三个时间：

- Access 最后访问时间

- Modify 文件内容最后修改时间

- Change 属性最后修改时间



给出结论：要想在磁盘中找到一个完整的文件，就必须要知道该文件的inode

那为什么inode节点信息不包括文件名呢？

```
原因：文件名长度不确定，不利于用一个统一空间的角度看待inode。为除了文件名以外的信息所占空间都是固定的，这也就导致了每一个文件的inode节点的空间大小是一样的，这使得系统更好的管理（只需要计算偏移量就能确定一个inode的位置）。一旦加入了文件名这个不确定字符串长度，每个文件的inode大小都不一样，不利于读取inode信息。
```

**如何通过inode在整个磁盘中找到目标文件？**

```
首先是找到哪一个组。对于一个分区来说，每个的组的inode编码都是不重复的，且都有自己的起始位置，衔接上一个组inode的末尾位置。比如第一个组的inode范围为1000-2000，第二个组的范围为2001-3001，依次往后面推。所以我们只需要比较一下inode在那个范围就能确定在那个组了。再用该inode减去该组的起始值，就能在inode table里找到目标inode真正位置了。这样就找到了目标文件的属性。
然后再通过inode节点中的datablocks[]找到各个数据块的地址。拿着这个地址再去Data blocks里面去找对应的数据块。这样就能找到文件内容了。
总结：要想找到文件内容必须先找到文件属性。
```

**如何获取一个新的inode**

```
在inode Bitmap中记录着每一个inode的空闲状态。当我们要创建一个文件，内核会在inode Bitmap中快速找到有哪个位置的比特位是0。假如找到了第10个比特位为0，那么就将这个比特位置1，表示已经征用这个inode号了，再将该inode加上该组的起始值后返回给操作系统
```

### 理解大文件的索引方式

刚才我们提到，每个文件的indoe内容大小是固定的，这对于大文件也是一样的吗？indoe中用来记录数据块的地址是一个datablocks数组，内部的元素个数是确定的，一般是15个。

如果每个datablocks[i]对应一个data block（数据块）,那就最多占15*4kb=60kb的空间。这样是肯定不够的

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7fb9f381a4cdbd0db0e47d4cdc8ad2df.png)

datablock中并非所有元素都直接映射一个数据块，而是会根据实际情况建立二级索引、三级索引。对于二级索引来说，**每一个元素对应的是一张数据块表，即表中的内容就是真正数据块的位置**。这样一来，用一个块去存放一个块表，大大提高了存储的效率。而即使是较大的文件，三级索引也基本上够用了。

## 软硬链接

### 什么叫做软链接

在Linux操作系统中，文件系统的核心概念之一是链接，包括软链接（符号链接）和硬链接。这些链接提供了访问文件系统中文件的灵活方式。软链接，被称为符号链接。类似于windows下的一个快捷方式。其本身也是一个文件，有着自己独立的inode。该文件的内容是链接对象文件的路径。这也是我们为什么可以通过快捷方式打开目标文件。

值得注意的是，`rm`指令删除文件时并不会考虑该文件是否是一个软链接，也就不会影响到原来的文件。其余大部分操作都会通过软链接影响到原文件，比如`chmod`修改权限。

**用 ln -s 指令创建软链接**

格式：
`ln -s 目标文件 软链接名`

![img](https://i-blog.csdnimg.cn/direct/c58f30f05a624223b2cec3bec2b0eeae.png)

软链接是一个独立的文件，有着自己独立的inode。

通过软链接可以访问原来的文件（跨目录访问）。

**软链接的特点：**

- 软链接包含的是另一个文件的路径，而不是直接指向文件数据的inode
- 如果原始文件被移动或删除，软链接就会失效，因为它的路径不再有效，这种情况下软链接被称为悬空链接。
- 软链接可以跨文件系统，因为它仅仅保存了另一个文件的路径。

**为什么说软链接可以更灵活的访问文件呢？**

因为很多时候我们有的文件会在非常深的路径下面，**通过路径去找到这个文件往往会比较麻烦**。当我们想要在其他目录下直接访问这个文件，可以考虑建立一个软链接，这样一来就可以通过这个软链接直接访问其他目录的文件了

#### 软链接的工作原理

- 软链接是文件系统中的一个特殊文件类型，存储的是目标文件的路径，操作系统访问到软链接的时候会重定向到路径指向的目录或者路径。
- 软链接的文件类型标识符会被标记为`l`，这样操作系统就会知道这个文件是一个软链接了
- 软连接的权限和被指向的目标文件无关。即使软链接指向一个不可读的文件，软链接本身的权限也是可读的。这也是为什么我们创建出来的软链接的权限掩码是777.有趣的是，我们并不能对一个软链接本身修改其权限，当我们尝试用chmod指令修改一个软链接的权限时，操作系统会直接跳过软链接而去修改它所指向的文件。从设计角度上来说，软链接只是一个“表象”，控制软链接的权限也没有太多意义。所以，对于操作系统来说，软链接只需要提供两点信息就可以了：一是告诉操作系统自己是一个软链接文件，二是目标文件的路径信息。
- 当用户通过软链接访问文件时，操作系统内核首先检查链接指向的路径。如果路径有效，操作系统就转向该路径并完成相应的文件操作。如果目标文件被移动或删除，软链接就会失效，称为悬挂链接（dangling link），因为它指向了一个不存在的路径

### 什么叫做硬链接

硬链接是指向文件系统中某个文件的实际数据的直接指针。在技术上讲，硬链接是文件实际数据的另一个名字（或指针）。创建出来的硬链接会复用原来文件的inode，也就意味着硬链接**并不是一个独立的文件**。

**用 ln 指令创建硬链接**

格式：`ln 目标文件 链接名`

![img](https://i-blog.csdnimg.cn/direct/59aefa7fccdd47c6b415402e30f1fa49.png)

果然，创建的**硬链接的inode和原文件的inode是一样的**

**硬链接的原理**

- 创建硬链接实际上是在文件系统中创建一个额外的目录条目，指向同一个inode。因此原始文件和硬链接共享同一个inode和文件数据
- 每个inode有一个引用计数，表示有多少文件名（目录条目）指向这个inode。当创建硬链接时，相关inode的引用计数会增加。当删除文件名时，引用计数减少。只有当引用计数达到零时，文件的数据和inode才会被系统回收。在文件属性中可以看到一个文件的硬链接数量

![img](https://i-blog.csdnimg.cn/direct/44d1c8f4eb3c41b3b1ec3bac78e85e42.png)

这个硬链接数量其实是指**有多少inode指向该文件的内容**

**硬链接的特点**

1. **节省空间**：硬链接只是增加了一个新的目录条目，即indoe映射。并没有开额外的空间来存储文件数据
2. 备份和共享方便：通过硬链接，我们可以在不同的路径下创建指向相同文件内容的路口，有助于数据的共享和备份，尤其对于大文件来说
3. 时更新：由于同一文件的所有的硬链接都是指向同一inode,对原始文件或任何硬链接的修改会即时反映在所有链接上，因为它们共享相同的数据。
4. 不能链接目录：硬链接不能链接目录，防止循环引用，这可能导致目录遍历算法陷入无限递归。
5. 硬链接 不能跨文件系统，因为不同的文件系统的indoe表不同
6. 删除复杂：多个硬链接指向同一个文件时，删除操作需要谨慎处理。每次删除一个硬链接文件，其实是使该inode引用数-1，直到为0才是真正的删除

其实硬链接可以链接目录，只不过这是由操作系统自己去做的。比如我们创建一个目录后，`.`和`..`其实就是一个硬链接：

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/7dc4b566b5c1b004cde69e1a7db308c4.png)

**我们进入A目录后观察`.`的inode,发现和A目录的inode是一样的！这也能解释为什们我们的`.`表示的就是当前目录**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/8b497a52279e7e77a0dce3255779ae15.png)

同理`..`其实就是上一级目录的硬链接。
之所以不给用户创建目录的硬链接，是因为出于安全考虑。

**进一步理解为什么硬链接不能链接目录**

假设这样一个场景：
我们有一个目录结构，包括目录A和目录B。如果系统允许硬链接目录，我们可能会执行以下操作：

1. 创建目录A和B
2. 在A目录下创建B的硬链接
3. 在B目录下创建A的硬链接

则势必会出现这样的场景

```
A -> B -> A -> B -> ...
```



那问题来了，为什么`.`和`..`不会引发循环遍历呢？

虽然看起来确实会引发无限循环，但是设计者在设计之前就考虑到了这一点，采取了以下措施来防止.和..造成死循环：
1.在尝试进入.时，系统知道这个目录就是当前目录，所以就不会进去。
2.根目录的..指向自己，使得回到上级目录的次数是有限的。
3.遍历目录的时候，遍历算法会智能地忽略或适当处理对.和…的访问，从而防止无限循环。

## 动静态库

在软件开发中，库（Library）是一种方式，可以**将代码打包成可重用的格式**，供其他程序调用。库可以分为静态库（**Static**Libraries）和动态库（**Dynamic** Libraries 或 Shared Libraries）。这两种类型的库在链接和执行时有各自的特点和用途

### 静态库

静态库是一种在程序编译时就被整合到可执行文件中的代码和数据集合。一般来说，无论是动态库还是静态库，其库中的内容都是一些被编译过但是还未被链接的**目标文件**（以.o或者.obj结尾的二进制文件）。

为什么要把这些目标文件打包成库呢？

```
1. 首先就是便于代码复用。将常用的功能打包成库使得这些代码可以轻松的在多个项目中重用。这大大节省了开发的时间，也有助于提高代码的一致性。
2. 使项目设计变得更加模块化。需要什么功能就添加什么库，将整个项目分解为更小更容易管理的模块。每个模块的库执行特定的功能，通过提供接口与其它模块交互。这有助于提高代码的维护性与可读性。
3. 版本控制和兼容性。库可以独立于使用它们的应用程序进行版本控制。开发者可以对库进行更新和改进。对于我们使用者来说，只需要更新一下就能使用最新的库了
4. 团队协作。库允许不同的开发者或小组专注于特定的功能领域。例如，一个团队可以负责数据库交互的库，而另一个团队则可以专注于用户界面的组件。这样的分工促进了专业化，可以提高开发效率和产品质量
```

#### 生成一个静态库

根据库的特点，我们需要先将add.c文件和sub.c文件编译成目标文件，使用带`-c`选项的gcc指令：

![img](https://i-blog.csdnimg.cn/direct/e1ecc2d66a8049bb8bfbdf37c79fe968.png)

接下来使用归档工具 `ar` 命令将一组对象文件打包成一个库文件。具体使用方式如下：
`ar -rc libmymath.a add.o sub.o`

其中，`-rc`是参数，表示替换、创建。`libmymath.a`表示要生成的库文件(一般静态库是以.a为后缀)。`add.o`、`sub.o`则是输入的对象文件。

用指令`ar -tv`查看库中的目录列表

选项`t`表示列出静态库中的文件，`v`表示详细信息

![img](https://i-blog.csdnimg.cn/direct/86e28b8708f141649cfb66c02992584c.png)

#### 归档工具ar

`ar`是一个用于创建和管理归档文件的工具，**通常用于创建静态库**。生成的归档文件是一个单独的文件，用来存储多个其它的文件和目录，常常在编译链接阶段用于组织静态库中的对象文件（.o文件）。ar来源于archive(归档)，其主要功能就是把多个文件合并成一个文件，以便于管理。

虽然我们可以用`-tv`选项查看归档文件中的目录，但它本身并不是一个目录，只是看起来像而已！此外，ar的功能其实与zip类似，但是ar对于处理这种目标文件是非常有效的。

- 插入文件到归档中（如果归档已存在，这个选项会替换或添加文件）。
- 创建归档文件，如果它不存在
- 创建一个对象文件索引（符号表），这对于链接器加速访问归档中的目标文件很重要
- 列出归档内容
- 从归档中提取文件。
- 从归档中删除文件。
- 只有当被添加的文件比归档中现有的同名文件更新时才添加文件

总之，区别于我们用gcc一个一个链接目标文件，这种打包成库的方式简化了链接和构建的过程，显得非常的方便且灵活。

#### 静态库的链接

当创建可执行文件时，**如果程序依赖于某个静态库，链接器（linker）会将静态库中的相关对象文件整合到最终的可执行文件中**。回到上面的代码样例。我们的main.c文件依赖于add与sub函数的实现，如果不链接库。按照我们之前的方式，只能一个一个链接源文件：

![img](https://i-blog.csdnimg.cn/direct/d254203cabd94356847ee5860ba1fa7b.png)

而现在我们已经将add.o与sub.o打包成了静态库`libmymath.a`，该怎么使用呢？

`gcc main.o -L/path/to/library -lexample -o main`

- 其中 `-L/path/to/library` 告诉链接器**在哪个目录下**查找库文件。如果库文件在标准库路径下**例如 /usr/lib/ 或 /usr/local/lib/**，可以省略这个选项。
- `-lexample` 指定链接器使用名为 `libexample.a` 的库。注意这里的使用命名规则，并不是直接将库静态库的全名加上去，而是要进行一些“处理”。因为链接器**会自动寻找以`lib`开头，`.a`结尾的文件**。我们只需要提供去掉lib和.a的部分。`-l`选项表示指定添加库。

库搜索路径：

- 从左到右搜索-L指定的路径
- 由环境变量指定的目录 （LIBRARY_PATH）
- 标准库路径 例如 /usr/lib/ 或 /usr/local/lib/

![img](https://i-blog.csdnimg.cn/direct/308e73332ae14a329b671141ceb0250f.png)

这样我们就成功的链接了一个静态库。
值得注意的是，一旦我们成功链接了某个静态库之后，该静态库中的所有数据和代码就存在可执行文件中了。所以我们之后即使把静态库删除也不会影响到程序的执行。**这是一个一次性的过程。**

### 动态库

动态库（Dynamic Libraries）是现代软件开发中常用的一种资源共享和模块化技术。动态库能够使多个程序**共享同一份库代码**，而不需要将这些代码复制到每个程序的可执行文件中，从而节省系统资源并便于维护和更新。

与静态库不同的是，动态库被链接后存在于**进程的共享区域**内，该区域内的数据和代码可以供多个进程使用。而且是用时访问，即程序在运行阶段会不断地访问。也就意味着，如果我们在生成可执行文件之后，将动态库删除，程序便会报链接错误。这是和使用静态库不一样的地方。

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/056bb57c125ba10929b797778a85cbf4.png)

#### 创建动态库

创建静态库使用了归档工具ar，而创建一个动态库gcc工具就可以。

```
gcc -fPIC -c sub.c add.c
gcc -shared -o libmymath.so sub.o add.o
```

首先解析第一条指令：
选项`-fPIC`表示生成位置无关码

**什么叫做位置无关码**

```
位置无关码的意思就是，生成的代码在内存中可以被加载到任何位置，而不是某个固定的地址。这种特性对于动态库尤其重要，因为动态库需要能够被多个不同的程序共享，并且每个程序可能将库加载到不同的地址空间。

位置无关码的寻址方式为相对寻址，可以将代码中的所有指针认为是一个个偏移量，不同的程序给与它不同的初始地址，这样就能灵活的将库加载到其它的地方。
```

**生成位置无关码是创建动态库的标准做法**，因为它确保库能在不同的应用程序和不同的运行实例中被正确地共享和使用。如果我们不用`-fPIC`选项生成位置无关码，程序在运行时就会报错。

![img](https://i-blog.csdnimg.cn/direct/a605ccd614cb41a7a7d739e51f021ee0.png)

所以第一条指令的意思就是将sub.c和add.c文件分别经过编译生成目标文件。
接下来就是将这些目标文件打包成库。

选项`-shared`表示 链接器 生成一个动态库而不是默认的可执行文件。生成的动态库一般以`.so`结尾

![img](https://i-blog.csdnimg.cn/direct/9b2989df03aa42afb8060e1b71bec845.png)

#### 加载动态库

当我们已经通过gcc编译器得到了一个动态库，该如何使用这个动态库呢?
如果我们直接像使用静态库那样直接链接，确实能编译通过，但是一旦我们尝试运行，就会得到以下报错：

![img](https://i-blog.csdnimg.cn/direct/90274a5da6ac4578aeb21f4150ab8de0.png)

为什么报错显示找不到这个动态库呢？我们不是在链接动态库的时候告诉了编译器动态库的路径了吗？

这一点非常容易理解。

我们确实将动态库路径告诉了gcc编译器,也确实编译成功了，得到了一个可执行文件。但是一个动态库是需要在运行时被访问的！编译器能找到这个动态库并不表示操作系统能找到这个动态库！

那为啥静态库这样运行就没问题呢？这是因为静态库是一次性工程，在链接阶段就把所有的代码和数据拷贝到程序的内部了！往后这个静态库文件在哪已经无所谓了。

所以，对于一个动态库而已，链接一个动态库的时候要告诉编译器库在哪，运行的时候就要告诉操作系统在哪。

解决方法：

运行时，操作系统会默认在`/lib`（不同的操作系统名字可能不一样）这个目录下去找动态库

1. 将我们自己的动态库拷贝到`/lib`里面，就能成功运行了：

![img](https://i-blog.csdnimg.cn/direct/1ac5cf1f577e46648db826999a505a30.png)

2. 在`/lib`目录下创建一个动态库的软链接:

![img](https://i-blog.csdnimg.cn/direct/ca30578ccd474d35ab82f81623ca96c8.png)

这样操作系统也能通过软链接找到我们的动态库

3. .修改动态库默认路径的环境变量`LD_LIBRARY_PATH`:

![img](https://i-blog.csdnimg.cn/direct/5dc0d652ca1940b4beacc30ca0bbb1ef.png)

但是这样设置的环境变量在下一次登录就失效了，要想永久生效就得修改配置文件`.bashrc`

找到LD_LIBRARY_PATH配置项，并在其路径下添加库的路径，这样每次登录都会自动生效。
如果你发现你的./bashrc没有LD_LIBRARY_PATH那你可以自己手动加一个环境变量LD_LIBRARY_PATH过去:export LD_LIBRARY_PATH=/path/to/your/libs:$LD_LIBRARY_PATH

## 动静态链接

### 静态链接

静态链接是在程序编译时将所有需要的库文件（通常是 .a 或 .lib 文件）内容直接复制到最终的可执行文件中的过程。这样，程序在运行时不再需要任何外部库。注意与静态库的区别，链接是一个动作，而库是一个名称。我们常把链接静态库的过程称为静态链接。

值得注意的是，gcc默认是动态链接。我们可以用指令`file`观察到这一点。

![img](https://i-blog.csdnimg.cn/direct/3465b7b39cb244e5aef1b9c27ce4bc9c.png)

那如何使gcc静态链接目标文件呢？
使用`-static`选项:`gcc -o main main.c -L. -lmth -static`

![img](https://i-blog.csdnimg.cn/direct/aa78ec091ac049e488716a8c108b5917.png)

再使用file观察，发现提示该可执行文件不是一个动态链接文件

![img](https://i-blog.csdnimg.cn/direct/9576623eee6547e7aabf507349e6a846.png)

那为什么之前我们用的是静态库，默认是动态链接，还显示是动态链接呢？
如果不显示使用-static选项，系统会只将声明的这个库进行静态链接，其它的库就还是动态链接。
比如我们之前的gcc -o main main.c -L. -lmymath,假如这个mymath.a是一个静态库，那么就只会静态链接这个库，其它库都是动态链接。

### 动态链接

动态链接是编译过程中，程序被构建为在运行时加载外部共享库（如 .so 或 .dll 文件）的过程。这意味着程序在运行时依赖于这些库文件。动态链接一般用来链接动态库。

gcc默认就是动态链接，因此无需其它选项。值得注意的是，如果我们声明的库路径下面包含静态库和动态库，即同名的库，只是后缀不一样。gcc还是会优先考虑链接动态。

### 动静态链接的优缺点

优点：

- 静态链接生成的可执行文件包含了所有必要的代码，不依赖于外部的库文件，这使得部署更简单，只需要分发单一的可执行文件
- 静态链接性能快。在某些情况下，静态链接的程序启动速度比动态链接的程序快，因为它们在启动时不需要加载外部库
- 动态链接节省空间：多个程序可以共享同一个库的单一物理副本，这样可以显著减少系统的总体占用空间。
- 动态链接更新方便，不需要重新编译，只需要替换库文件即可。

缺点：

- 静态链接的可执行文件通常比动态链接的文件大，因为它包含了所有必要的库代码。
- 静态链接更新比较麻烦，需要重新编译整个程序。
- 动态链接过于依赖外部的动态库，一旦外部的库出现问题，导致很多程序都运行不了
- 动态链接的性能开销会比较大，因为需要加载外部的库

总的来说，动态链接是用时间换空间，静态链接是用空间换时间，如何选择哪种链接方式取决于具体的环境。
