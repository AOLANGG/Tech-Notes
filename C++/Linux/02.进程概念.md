## 冯诺依曼体系

![img](https://i-blog.csdnimg.cn/direct/a5e1b309315b45bd95f09bf360218d42.png)

## 操作系统

任何计算机系统都包含一个基本的程序集合，成为操作系统（OS）。操作系统包括：

- 内核（进程管理，内存管理，文件管理，驱动管理）
- 其他程序（函数库，shell程序等等）

### 设计OS的目的

- 与硬件交互，管理所有的软硬件资源
- 为用户程序提供一个良好的执行环境

### 定位

- 在整个计算机软硬件架构中，操作系统的定位是：**一款纯正的“搞管理”的软件**

![img](https://i-blog.csdnimg.cn/direct/3b878ad94cba47ac95015533422db208.png)

**`先描述，在组织`**

计算机管理硬件

1. 描述起来，用`struct`结构体
2. 组织起来，用链表或者其他的数据结构

## 系统调用和库函数

- 在开发角度，操作系统对外会表现为一个整体，但是会暴漏自己的部分接口，供上层开发使用，这部分有操作系统提供的接口，就叫做系统调用。
- 系统调用在使用上，功能比较基础，对用户的要求相对比较高，所有，有心的开发者可以对部分系统调用进行封装，从而形成库，有了库，更利于上层用户或者开发者进行二次开发

## 进程

- 课本：程序中一个执行实力，正在执行的程序等
- 内核观点：担当分配系统资源（CPU、内存）的实体

### 描述进程 PCB

- 进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合

- 称之为PCB，Linux操作系统下的PCB是`task_struct`

**`task_struct`，PCB的一种**

- 在Linux中描述进程的结构体叫做`task_struct`
- `task_struct`是Linux内核中的一种数据结构，被装载到内存中，并且包含进程的信息

**`task_struct`内容分类**

- 标识符：描述进程的唯一标识符，用来区分其他进程
- 状态：任务状态，退出代码，退出信号
- 优先级：相对于其他进程的优先级
- 程序计数器：程序中即将被执行的下一条指令的地址
- 内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针
- 上下文数据：进程执行时处理器的寄存器中的数据
- IO状态信息：包括显示的IO请求，分配给进程的IO设备和被进程使用的文件列表
- 记账信息：可能包括处理器时间总和，使用的时钟数中和，时间限制，记账号等。

### 查看进程

![img](https://i-blog.csdnimg.cn/direct/9d81e5426ab349e588f209298a58024d.png)

## 进程控制

### 进程创建

**`fork`**

- `fork`有两个返回值
- 父子进程代码共享，数据各自开辟空间，私有一份（采用写时拷贝）

```c++
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    int ret = fork();
    if(ret<0){
        perror("fork");
        return 1;
    }
    else if(ret == 0){
        // child
        printf("I am child: %d,ret: %d\n",getpid(),ret);
    }
    else{
        // father
        printf("I am father: %d,ret: %d\n",getpid(),ret);
    }
    sleep(1);
    return 0;
}
```

### 进程状态

- **R运行状态**：并不意味这进行一定在运行中，它表明进程要么在运行中要么在运行队列中
- **S睡眠状态**：意味着进程在等待某个事件就绪，也可叫做可中断睡眠
- **D磁盘休眠状态**：也叫做不可中断睡眠状态
- **T停止状态**：可以通过发送`SIGSTOP`信号给进程来停止进程。这个被暂停的进程可以通过发送`SIGCONT`信号让进程继续运行
- **X死亡状态**：这个状态指示一个返回状态，在任务列表中是看不到的

**进程状态查看命令**

`ps aux / ps ajx 命令`

- **Z僵尸进程**
  - 僵尸状态时一个比较特殊的状态。当进程退出并且父进程没有读取到子进程退出的返回代码就会出现僵尸进程
  - 僵尸进程会以状态保留在进程表中，并且一直等待父进程读取退出状态代码
  - 所以，只要子进程退出，父进程还在运行，但是父进程不读取自己成状态，子进程就会进入Z状态

![img](https://i-blog.csdnimg.cn/direct/d2286866998f416e8a6284d11b36ae3c.png)

**僵尸进程的危害**

- 进程的退出状态必须被维持下去，因为它要告诉父进程任务完成的额如何。假如父进程一直不读取，那么子进程一直处于`z`状态
- 维护退出状态本身就是要用数据维护的，也就是进程基本信息，保存在`task_struct(PCB)`中，Z状态不退出，`task_struct`一直维护
- 一个父进程创建了很多子进程，不回收，就会造成内存资源的浪费，引发内存泄漏

**孤儿进程**

- 父进程如果提前退出，子进程就叫做“孤儿进程”
- 孤儿进程被1号init进程领养，由init进程回收

![img](https://i-blog.csdnimg.cn/direct/0202f88d326046c1b7a3f62141569334.png)

## 进程优先级

- CPU资源分配的先后顺序，就是指进程的优先权
- 优先权高的进程有优先执行权利。配置进程优先权对多任务环境很有用，可以改善系统性能
- 还可以把进程运行到指定的CPU上，把不重要的进程安排到某个CPU上，可以大大改善系统整体性能。

![img](https://i-blog.csdnimg.cn/direct/48cef732e77b489ab06ce02d1ea4cade.png)

- UID：代表执行者的身份
- PID：代表某个进程的代号
- PPID：代表这个进程是由哪个进程发展衍生而来的
- PRI：代表这个进程可被执行的优先级，越小越早被执行
- NI：代表这个进程的`nice`值

### PRI和NI

`PRI = 100 + NI`

- PRI是进程的优先级，就是程序被CPU执行的先后顺序，这个值越小进程的优先级别越高
- NI，nice，表示进程可悲执行的优先级的修正数值
- PRI = 100 + NI
- 当nice值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行
- 调整进程优先级，其实就是调整`nice`值
- `nice`取值范围是-20到19，一共40个级别



需要强调一点的是，进程的nice值不是进程的优先级，他们不是一个概念，但是进程nice值会影响到进程的优先级变化。可以理解nice值是进程优先级的修正修正数据

## 环境变量

- 环境变量一般是指在操作系统运行环境的一些参数
- 我们在编写C/C++代码的时候，在链接的时候，从来不知道我们的所链接的动态静态库在哪里，但是照样可以链接成功，生成可执行程序，原因就是有相关环境变量帮助编译器进行查找
- 环境变量具有某些特殊用途，在系统中具有全局性

###  常见环境变量

- PATH：指定命令的搜索路径
- HOME：指定用户的主工作目录
- SHELL：当前shell，它的指通常是`/bin/bash`

### 查看环境变量

`echo $NAME`

### 和环境变量相关的命令

1. echo：显示某个环境变量值
2. export：设置一个新的环境变量
3. env：显示所有环境变量
4. unset：清除环境变量
5. set：显示本地定义的shell变量和环境变量

![img](https://i-blog.csdnimg.cn/direct/b79850c63ade458096b6983a54bc0b90.png)

每个程序都会收到一张环境表，环境表是一个字符指针数组，每个指针指向一个以’\0’结尾的环境字符串

### 通过代码获取环境变量

1. 通过第三个参数

```c++
int main(int argc,char* argv[],char* env[])
{
    int i = 0;
    for(;env[i];i++){
        printf("%s\n",env[i]);
    }
    return 0;
}
```

2. 通过第三方变量`environ`获取

```c++
int main(int argc,char* argv[])
{
    extern char** environ;
    int i = 0;
    for(;environ[i];i++){
        printf("%s\n",environ[i]);
    }
    return 0;
}
```

## 程序地址空间

![img](https://i-blog.csdnimg.cn/direct/c6a8131f2cb24048abe0cf533b51bd83.png)

```c++
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int g_val = 0;
int main(){
    pid_t id = fork();
    if(id==0){
        // child
        printf("child[%d]: %d: %p\n",getpid(),g_val,&g_val);
    }
    else{
        // parent
        printf("parent[%d]: %d: %p\n",getpid(),g_val,&g_val);

    }
}

parent[38231]: 0: 0x559f25fc9014
child[38232]: 0: 0x559f25fc9014
```

可以发现，输出出来的变量值和地址是一模一样的，因为子进程按照父进程为模板，父子没有对变量进行任何修改；如果修改了呢？

```c++
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

int g_val = 0;
int main(){
    pid_t id = fork();
    if(id==0){
        // child
        g_val = 10;
        printf("child[%d]: %d: %p\n",getpid(),g_val,&g_val);
    }
    else{
        // parent
        sleep(3);
        printf("parent[%d]: %d: %p\n",getpid(),g_val,&g_val);

    }
}

child[38303]: 10: 0x5640a629d014
parent[38302]: 0: 0x5640a629d014
```

发现，父子进程，输出的地址是一致的，但是变量内容居然不一样！？

- 变量内容不一样，所以父子进程不可能是同一个变量
- 地址一样，说明这个地址应当是一个虚拟地址
- 在Linux下，这种地址叫做虚拟地址
- 我们用C/C++看到的地址，都是虚拟地址。物理地址，用户一概看不到，有操作系统统一管理。OS负责把物理地址转换成虚拟地址

### 进程地址空间

![img](https://i-blog.csdnimg.cn/direct/f50f755f8a654644a0530b47791a7b5b.png)

![img](https://i-blog.csdnimg.cn/direct/f12649b0239b480abdddb5a57eb0b1b6.png)
