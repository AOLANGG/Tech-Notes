## 什么是线程

- 在一个程序里的一个执行路线就叫做线程。线程是“一个进程内部的控制序列”
- 一切进程至少都有一个执行线程
- 线程在进程内部运行，本质实在进程地址空间内运行
- 在Linux中，在CPU眼中，看到的PCB都比传统的进程更加轻量化
- 透过进程虚拟地址空间，可以看到进程的大部分资源，将进程资源合理分配给每个执行流，就形成了线程
  执行流

![img](https://i-blog.csdnimg.cn/direct/71e4fab7e40647a6a50474a1b95e37ad.png)

## 线程的优缺点

**优点**

1. 创建一个新线程的代价比创建一个新进程小得多
2. 与进程切换相比，线程切换要做的工作更少
3. 线程占用的额资源比进程少的多
4. 能充分利用多处理器的可并行数量
5. 在等待慢速I/O操作结束的同时，程序可执行其他的计算任务
6. 计算密集型应用，为了能在多处理器系统上运行，将计算分解到多个线程中实现
7. I/O密集型应用，为了提高性能，将I/O操作重叠。线程可以同时等待不同的I/O操作

**缺点**

- 性能损失
  - 一个很少被外部事物阻塞的计算密集型线程往往无法与其他线程共享同一个处理器。如果计算密集型线程的数量比可用的处理器多，那么可能会有较大的性能损失，这里的性能损失指的是增加了额外的同步和调度开销，而可用的资源不多
- 健壮性降低
  - 编写多线程需要更全面更深入的考虑，在一个多线程程序中，因时间分配上的细微偏差或者因共享不该共享的变量而造成不良影响的可能性很大，换句话说，线程之间是缺乏保护的。
- 缺乏访问控制
  - 进程是访问控制的基本粒度，在一个线程中会调用某些OS函数对整个进程造成影响
- 编程难度提高
  - 编写和调试一个多线程的程序比单线程要困难的多

## 线程异常

- 单个线程如果出现除零，野指针问题导致线程崩溃，进程也会随着崩溃
- 线程是进程的执行分支，线程出现问题，就类似进程出现问题，进而触发信号机制，终止进程，该进程内的所有线程也都被终止了

## 进程vs线程

- 进程是资源分配的基本单位
- 线程是调度的基本单位
- 线程共享进程数据，也拥有自己的一部分数据
  - 线程ID
  - 一组寄存器
  - 栈
  - errno
  - 信号屏蔽字
  - 调度优先级

进程的多个线程共享 同一地址空间,如果定义一个函数,在各线程
中都可以调用,如果定义一个全局变量,在各线程中都可以访问到,除此之外,各线程还共享以下进程资源和环境

- 文件描述符
- 每个信号处理方式
- 当前工作目录
- 用户ID和组ID

![img](https://i-blog.csdnimg.cn/direct/b76e4398fa8143149f7afcd2f7f5ef53.png)

## 线程控制

- 与线程有关的函数构成了一个完整的系列，绝大多数函数的名字都是以“pthread_”打头的
- 要使用这些函数库，要通过引入头文<pthread.h>
- 链接这些线程函数库时要使用编译器命令的“-lpthread”选项

### 创建线程

```c++
功能：创建一个新的线程
原型
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *
(*start_routine)(void*), void *arg);
参数
thread:返回线程ID
attr:设置线程的属性，attr为NULL表示使用默认属性
start_routine:是个函数地址，线程启动后要执行的函数
arg:传给线程启动函数的参数
返回值：成功返回0；失败返回错误码
```

错误检查

- 传统的一些函数是，成功返回0，失败返回-1，并对全局变量errno赋值
- pthreads函数出错时不会设置全局变量errno（而大部分其他POSIX函数会这样做）。而是将错误代码通过返回值返回
- pthreads同样也提供了线程内的errno变量，以支持其它使用errno的代码。对于pthreads函数的错误，建议通过返回值业判定，因为读取返回值要比读取线程内的errno变量的开销更小

```c++
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

void *rout(void *arg)
{
    int i;
    while (1)
    {
        printf("I am thread %d\n",*(int*)arg);
        sleep(1);
    }
}

int main()
{
    pthread_t tid;
    int ret;
    int num = 111;
    if ((ret = pthread_create(&tid, NULL, rout, &num)) != 0)
    {
        fprintf(stderr, "pthread_create: %s\n", strerror(ret));
        exit(EXIT_FAILURE);
    }
    int i;
    for (;;)
    {
        printf("I'am main thread\n");
        sleep(1);
    }
    return 0;
}
```

#### 获取当前线程

**pthread_self**

```
pthread_t pthread_self(void);
```

```c++
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

void *rout(void *arg)
{
    int i;
    while (1)
    {
        printf("thread id : %ld,I am thread num: %d\n",pthread_self(),*(int*)arg);
        sleep(1);
    }
}

int main()
{
    pthread_t tid;
    int ret;
    int num = 111;
    if ((ret = pthread_create(&tid, NULL, rout, &num)) != 0)
    {
        fprintf(stderr, "pthread_create: %s\n", strerror(ret));
        exit(EXIT_FAILURE);
    }
    int i;
    for (;;)
    {
        printf("I'am main thread\n");
        sleep(1);
    }
    return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/f784cf4a58e44aeba3c7120da962115f.png)

### 线程终止

如果需要只终止某个线程，而不终止整个进程，有三种方法

1. 从线程函数return（对主线程不适用）
2. 线程可以调用`pthread_exit`来终止自己
3. 一个线程可以调用`phtread_cancel`终止统一进程下的另一个线程

**`pthread_exit`函数**

功能：线程终止
原型
void pthread_exit(void *retval);
参数
value_ptr:retval不要指向一个局部变量。
返回值：无返回值，跟进程一样，线程结束的时候无法返回到它的调用者（自身）

retval是线程的退出状态

**`pthread_cancel`函数**

```
功能：取消一个执行中的线程
原型
int pthread_cancel(pthread_t thread);
参数
thread:线程ID
返回值：成功返回0；失败返回错误码
```

### 线程等待

- 已经退出的线程，其空间没有被释放，仍然在进程的地址空间内
- 创建新的线程不会复用刚才退出线程的地址空间

```
功能：等待线程结束
原型
int pthread_join(pthread_t thread, void **value_ptr);
参数
thread:线程ID
value_ptr:它指向一个指针，后者指向线程的返回值
返回值：成功返回0；失败返回错误码
```

调用该函数的线程将挂起等待,直到id为thread的线程终止。thread线程以不同的方法终止,通过pthread_join得到的
终止状态是不同的，总结如下：

```
1. 如果thread线程通过return返回,value_ ptr所指向的单元里存放的是thread线程函数的返回值。
2. 如果thread线程被别的线程调用pthread_ cancel异常终掉,value_ ptr所指向的单元里存放的是常数PTHREAD_ CANCELED。
3. 如果thread线程是自己调用pthread_exit终止的,value_ptr所指向的单元存放的是传给pthread_exit的参数。
4. 如果对thread线程的终止状态不感兴趣,可以传NULL给value_ ptr参数。
```

![img](https://i-blog.csdnimg.cn/direct/58186f82590148faa881abe7bc1af3e4.png)

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread1(void *arg)
{
    printf("thread 1 returning...\n");
    int *p = (int *)malloc(sizeof(int));
    *p = 1;
    return (void *)p;
}
void *thread2(void *arg)
{
    printf("thread 2 exiting ...\n");
    int *p = (int *)malloc(sizeof(int));
    *p = 2;
    pthread_exit((void *)p);
}
void *thread3(void *arg)
{
    while (1)
    { //
        printf("thread 3 is running ...\n");
        sleep(1);
    }
    return NULL;
}

int main()
{
    pthread_t tid;
    void *ret;

    // thread1 return
    pthread_create(&tid, NULL, thread1, NULL);
    pthread_join(tid, &ret);
    printf("%d\n", *(int *)ret);
    free(ret);

    // thread2 exit
    pthread_create(&tid, NULL, thread2, NULL);
    pthread_join(tid, &ret);
    printf("%d\n", *(int *)ret);
    free(ret);

    // thread 3 cancel by other
    pthread_create(&tid, NULL, thread3, NULL);
    sleep(3);
    pthread_cancel(tid);
    pthread_join(tid, &ret);
    if (ret == PTHREAD_CANCELED)
        printf("thread return, thread id %X, return code:PTHREAD_CANCELED\n", tid);
    else
        printf("thread return, thread id %X, return code:NULL\n", tid);
    return 0;
}
```

### 分离线程

- 默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行pthread_join操作，否则无法释放资源，从而造成系统泄漏。
- 如果不关心线程的返回值，join是一种负担，这个时候，我们可以告诉系统，当线程退出时，自动释放线程资源

```c++
int pthread_detach(pthread_t thread);
```

可以是线程组内其他线程对目标线程进行分离，也可以是线程自己分离:

```c++
thread_detach(pthread_self());
```



```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void* thread_run(void* arg)
{
    // 分离线程
    pthread_detach(pthread_self());
    printf("%s\n",(char*)arg);
    return NULL;
}

int main()
{
    pthread_t tid;
    if(pthread_create(&tid,NULL,thread_run,(void*)"thread_run ...")!=0){
        printf("create thread error\n");
        return 1;
    }
    int ret = 0;
    sleep(3);
    if(pthread_join(tid,NULL)==0){
        printf("pthread wait success\n");
        ret = 0;
    }
    else{
        printf("pthread wait failed\n");
        ret = 1;
    }
    return ret;
}
```

### 线程互斥

- 临界资源：多线程执行流共享的资源就叫做临界资源
- 临界区：每个线程内容，访问临界资源的代码，就叫做临界区
- 互斥：任何时刻，互斥保证有且只有一个执行流进入临界区，访问临界资源，通常临界资源起保护作用
- 原子性：不会被任何调度机制打断的操作，该操作只有两态，要么完成，要么未完成

**互斥量mutex**

- 大部分情况下，线程使用的数据都是局部变量，这个时候变量归单个线程，其他线程无法获取这个变量
- 有时候，很多线程需要共享，这样的变量就叫做共享变量，可以通过数据的共享，完成线程之间的交互
- 多个线程并发的操作共享变量，会有一些线程安全的问题

举个例子

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

int ticket = 100;
void* route(void* arg)
{
    char* id = (char*)arg;
    while(1){
        if(ticket>0){
            // 1ms
            usleep(1000);
            printf("%s sells ticket:%d\n", id, ticket);
            ticket--;
        }
        else break;
    }
    return NULL;
}

int main()
{
    pthread_t t1, t2, t3, t4;
    pthread_create(&t1,NULL,route,(void*)"thread 1");
    pthread_create(&t2,NULL,route,(void*)"thread 2");
    pthread_create(&t3,NULL,route,(void*)"thread 3");
    pthread_create(&t4,NULL,route,(void*)"thread 4");

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);
    pthread_join(t4, NULL);
    return 0;
}
```

可以看出并没有得出正确的结果

说白了就是，因为`--ticket`操作本身不是一个原子性的操作

#### 互斥量的接口

**初始化互斥量**

- 静态分配

```
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER
```

- 动态分配

```
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict
attr);
参数：
mutex：要初始化的互斥量
attr：NULL
```

**销毁互斥量**

- 使用`PTHREAD_MUTEX_INITIALIZER`不需要销毁
- 不要销毁一个已经加锁的互斥量
- 已经销毁的互斥量，要确保后面不会有线程在尝试加锁

```c++
int pthread_mutex_destroy(pthread_mutex_t *mutex)；
```

互斥量加锁和解锁

```c++
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
返回值:成功返回0,失败返回错误号  
```

调用pthread_ lock 时，可能会遇到以下情况:

- 互斥量处于未锁状态，该函数会将互斥量锁定，同时返回成功
- 发起函数调用时，其他线程已经锁定互斥量，或者存在其他线程同时申请互斥量，但没有竞争到互斥量，那么pthread_ lock调用会陷入阻塞(执行流被挂起)，等待互斥量解锁

修正版
```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

int ticket = 100;
pthread_mutex_t mutex;

void *route(void *arg)
{
    char *id = (char *)arg;
    while (1)
    {
        pthread_mutex_lock(&mutex);
        if (ticket > 0)
        {
            // 1ms
            usleep(1000);
            printf("%s sells ticket:%d\n", id, ticket);
            ticket--;
            pthread_mutex_unlock(&mutex);
        }
        else
        {
            pthread_mutex_unlock(&mutex);
            break;
        }
    }
    return NULL;
}

int main()
{
    pthread_t t1, t2, t3, t4;
    pthread_mutex_init(&mutex, NULL);
    pthread_create(&t1, NULL, route, (void *)"thread 1");
    pthread_create(&t2, NULL, route, (void *)"thread 2");
    pthread_create(&t3, NULL, route, (void *)"thread 3");
    pthread_create(&t4, NULL, route, (void *)"thread 4");

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    pthread_join(t3, NULL);
    pthread_join(t4, NULL);
    pthread_mutex_destroy(&mutex);
    return 0;
}
```

## 常见的锁概念

### 死锁

死锁是指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态。

**死锁的四个条件**

1. 互斥条件：一个资源每次只能被一个执行流调用
2. 请求和保持条件：一个执行流因请求资源而阻塞的时候，对以获取的资源保持不放
3. 不剥夺条件：一个执行流已获取的资源，在未使用完之前，不能被强行剥夺
4. 循环等待条件:若干执行流之间形成一种头尾相接的循环等待资源的关系

**避免死锁**

- 破坏死锁的额四个必要条件
- 加锁顺序一致
- 避免锁未释放的长江
- 资源一次性分配

## Linux线程同步

### 条件变量

条件变量本身不直接保护共享资源，而是用于 **让线程等待某个 “条件” 成立**（比如共享队列非空、数据准备就绪等），当条件满足时，由其他线程 “通知” 等待的线程继续执行。

- 当一个线程互斥的访问某个变量的时候，它可能发现在其他线程改变状态之前，它什么也做不了
- 例如一个线程访问队列时，发现队列为空，它只能等待，只到其它线程将一个节点添加到队列中。这种情况就需要用到条件变量

### 同步和竞态条件

- 同步：在保证数据安全的前提下，让线程能够按照某种特定的顺序访问临界资源，从而有效避免饥饿问题，叫做同步
- 竞态条件：因为时序问题，而导致程序异常，我们称之为竞态条件。在线程场景下，这种问题也不难理解

### 条件变量函数 

**初始化**

```c++
int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);
参数：
cond：要初始化的条件变量
attr：NULL
```

**销毁**

```c++
int pthread_cond_destroy(pthread_cond_t *cond)
```

**等待条件满足**

```c++
int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);
参数：
cond：要在这个条件变量上等待
mutex：互斥量
```

**唤醒等待**

```c++
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
```

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

pthread_cond_t cond;
pthread_mutex_t mutex;

void* r1(void* arg){
    while(1){
        pthread_cond_wait(&cond,&mutex);
        printf("活动\n");
    }
}
void* r2(void* arg){
    while(1){
        pthread_cond_signal(&cond);
        sleep(1);
    }
}
int main()
{
    pthread_t t1, t2;
    pthread_cond_init(&cond,NULL);
    pthread_mutex_init(&mutex,NULL);

    pthread_create(&t1,NULL,r1,NULL);
    pthread_create(&t2,NULL,r2,NULL);

    pthread_join(t1,NULL);
    pthread_join(t2,NULL);

    pthread_mutex_destroy(&mutex);
    pthread_cond_destroy(&cond);
    return 0;
}
```

**为什么`pthread_cond_wait`需要互斥量**

- 条件等待是线程间同步的一种手段，如果只有一个线程，条件不满足，一直等下去都不会满足，所以必须要有一个线程通过某些操作，改变共享变量，使原先不满足的条件变得满足，并且友好的通知等待在条件变量上的线程。
- 条件不会无缘无故的突然变得满足了，必然会牵扯到共享数据的变化。所以一定要用互斥锁来保护。没有互斥锁就无法安全的获取和修改共享数据。
- 由于解锁和等待不是原子操作。调用解锁之后， pthread_cond_wait 之前，如果已经有其他线程获取到互斥量，摒弃条件满足，发送了信号，那么pthread_cond_wait 将错过这个信号，可能会导致线程永远阻塞在这个pthread_cond_wait 。所以解锁和等待必须是一个原子操作。
- int pthread_cond_wait(pthread_cond_ t *cond,pthread_mutex_ t * mutex); 进入该函数后，会去看条件量等于0不？等于，就把互斥量变成1，直到cond_ wait返回，把条件量改成1，把互斥量恢复成原样

## 生产者消费者模型

### 为什么要使用生产者消费者模型

生产者消费者模式就是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。这个阻塞队列就是用来给生产者和消费者解耦的。

### 优点

- 解耦
- 支持并发
- 支持忙闲不均

![img](https://i-blog.csdnimg.cn/direct/748492acf8bc4215b318726f5fed398c.png)

### 基于BlockingQueue（阻塞队列）的生产者消费者模型

在多线程编程中阻塞队列(Blocking Queue)是一种常用于实现生产者和消费者模型的数据结构。其与普通的队列区别在于，当队列为空时，从队列获取元素的操作将会被阻塞，直到队列中被放入了元素；当队列满时，往队列里存放元素的操作也会被阻塞，直到有元素被从队列中取出(以上的操作都是基于不同的线程来说的，线程在对阻塞队列进程操作时会被阻塞)

![img](https://i-blog.csdnimg.cn/direct/2aa1ddcc912f4a698ebd43f351a673fe.png)

### C++ queue模拟阻塞队里的生产者消费者模型

```c++
#include <iostream>
#include <queue>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define NUM 8

class BlockQueue
{
private:
    std::queue<int> q;
    int cap;
    pthread_mutex_t lock;
    pthread_cond_t full;
    pthread_cond_t empty;

private:
    void LockQueue()
    {
        pthread_mutex_lock(&lock);
    }
    void uLockQueue()
    {
        pthread_mutex_unlock(&lock);
    }
    // 休眠等待
    void ProductWait()
    {
        pthread_cond_wait(&full, &lock);
    }
    void ConsumeWait()
    {
        pthread_cond_wait(&empty, &lock);
    }
    // 通知
    void NotifyProduct()
    {
        pthread_cond_signal(&full);
    }
    void NotifyConsume()
    {
        pthread_cond_signal(&empty);
    }
    bool IsEmpty()
    {
        return q.size() == 0;
    }
    bool IsFull()
    {
        return q.size() == cap;
    }

public:
    BlockQueue(int _cap = NUM) : cap(_cap)
    {
        pthread_mutex_init(&lock, NULL);
        pthread_cond_init(&full, NULL);
        pthread_cond_init(&empty, NULL);
    }
    void PushData(const int &data)
    {
        LockQueue();
        while (IsFull())
        {
            NotifyConsume();
            std::cout << "queue full,notify consume data,product stop" << std::endl;
            ProductWait();
        }
        q.push(data);
        NotifyConsume();
        uLockQueue();
    }
    void PopData(int &data)
    {
        LockQueue();
        while (IsEmpty())
        {
            NotifyProduct();
            std::cout << "queue empty,notify product data,consume stop" << std::endl;
            ConsumeWait();
        }
        data = q.front();
        q.pop();
        NotifyProduct();
        uLockQueue();
    }
    ~BlockQueue()
    {
        pthread_mutex_destroy(&lock);
        pthread_cond_destroy(&full);
        pthread_cond_destroy(&empty);
    }
};

void *consumer(void *arg)
{
    BlockQueue *bqp = (BlockQueue *)arg;
    int data;
    for (;;)
    {
        bqp->PopData(data);
        std::cout << "Consume data done : " << data << std::endl;
        sleep(2);
    }
}
// more faster
void *producter(void *arg)
{
    BlockQueue *bqp = (BlockQueue *)arg;
    srand((unsigned long)time(NULL));
    for (;;)
    {
        int data = rand() % 1024;
        bqp->PushData(data);
        std::cout << "Product data done: " << data << std::endl;
        sleep(1);
    }
}
int main()
{
    BlockQueue bq;
    pthread_t c, p;
    pthread_create(&c, NULL, consumer, (void *)&bq);
    pthread_create(&p, NULL, producter, (void *)&bq);
    pthread_join(c, NULL);
    pthread_join(p, NULL);
    return 0;
}
```

## POSIX信号量

POSIX信号量和SystemV信号量作用相同，都是用于同步操作，达到无冲突的访问共享资源目的。 但POSIX可以用于线程间同步。

**初始化信号量**

```c++
#include <semaphore.h>
int sem_init(sem_t *sem, int pshared, unsigned int value);
参数：
pshared:0表示线程间共享，非零表示进程间共享
value：信号量初始值
```

**销毁信号量**

```c++
int sem_destroy(sem_t *sem);
```

**等待信号量**

```c++
功能：等待信号量，会将信号量的值减1
int sem_wait(sem_t *sem); //P()
```

**发布信号量**

```c++
功能：发布信号量，表示资源使用完毕，可以归还资源了。将信号量值加1。
int sem_post(sem_t *sem);//V()
```

## 线程池

一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。

### 应用场景

1. 需要大量的线程来完成任务，且完成任务的时间比较短。 WEB服务器完成网页请求这样的任务，使用线程池技术是非常合适的。因为单个任务小，而任务数量巨大，你可以想象一个热门网站的点击次数。 但对于长时间的任务，比如一个Telnet连接请求，线程池的优点就不明显了。因为Telnet会话时间比线程的创建时间大多了。

2. 对性能要求苛刻的应用，比如要求服务器迅速响应客户请求。

3. 接受突发性的大量请求，但不至于使服务器因此产生大量线程的应用。突发性大量客户请求，在没有线程池情况下，将产生大量线程，虽然理论上大部分操作系统线程数目最大值不是问题，短时间内产生大量线程可能使内存到达极限，出现错误.

`ThreadPool.hpp`

```c++
#pragma once
#include <iostream>
#include <unistd.h>
#include <string>
#include <vector>
#include <queue>
#include <pthread.h>
#include <functional>
#include "Thread.hpp"
#include "Task.hpp"

using namespace ThreadMoudle;

static const int gdefaultnum = 5; // 默认线程数量

void test(string &str)
{
    while (true)
    {
        cout << str << " helloworld" << endl;
        sleep(1);
    }
}

template <class T>
class ThreadPool
{
private:
    void LockQueue()
    {
        pthread_mutex_lock(&_mutex);
    }

    void UnlockQueue()
    {
        pthread_mutex_unlock(&_mutex);
    }

    void Wakeup() // 唤醒某个线程
    {
        pthread_cond_signal(&_cond);
    }
    void WakeupAll()
    { // 唤醒所有在等待的线程
        pthread_cond_broadcast(&_cond);
    }

    void Sleep() // 调用该函数的线程等待条件变量
    {
        pthread_cond_wait(&_cond, &_mutex);
    }
    bool IsEmpty()
    {
        return _task_queue.empty();
    }

    void HandlerTask(const string &name) // 线程池中线程的执行逻辑
    {
        while (true)
        {
            // 取任务
            LockQueue();
            while (IsEmpty() && _isrunning)
            {
                _sleep_thread_num++;
                Sleep();
                _sleep_thread_num--;
            }
            // 判断此时是否需要停止
            if (IsEmpty() && !_isrunning) // 此时没有任务且需要退出
            {
                cout << name << " quit" << endl;
                UnlockQueue();
                break;
            }

            T t = _task_queue.front(); // 取出一个任务对象
            _task_queue.pop();
            UnlockQueue();
            t(); // 处理任务
            cout << name << " : " << t.result() << endl;
        }
    }

public:
    ThreadPool(int thread_num = gdefaultnum) // 初始化线程池
        : _thread_num(thread_num), _isrunning(false), _sleep_thread_num(0)
    {
        pthread_mutex_init(&_mutex, nullptr);
        pthread_cond_init(&_cond, nullptr);
    }
    void Init() // 初始化线程容器里的线程，赋予每个线程名字以及处理逻辑函数
    {
        func_t func = bind(&ThreadPool::HandlerTask, this, std::placeholders::_1); // 绑定HandlerTask函数的第一个参数
        for (int i = 0; i < _thread_num; i++)
        {
            string threadname = "thread-" + to_string(i + 1);
            _threads.emplace_back(threadname, func);
        }
    }

    void Start() // 启动线程池里的所有线程，此时所有线程开始执行HandlerTask函数
    {
        _isrunning = true;
        for (auto &thread : _threads)
        {
            thread.Start();
        }
    }

    void Stop()
    {
        LockQueue();
        _isrunning = false;
        WakeupAll(); // 唤醒所有线程赶紧把剩下的任务处理了
        UnlockQueue();
    }

    void Push(const T &in)
    {
        LockQueue();
        if (_isrunning) // 如果线程池要停止，那就不要在生产任务了
        {
            _task_queue.push(in); // 生产了一个任务
            if (_sleep_thread_num > 0)
            {
                Wakeup(); // 唤醒一个等待的线程
            }
        }
        UnlockQueue();
    }

    ~ThreadPool()
    {
        pthread_mutex_destroy(&_mutex);
        pthread_cond_destroy(&_cond);
    }

private:
    int _thread_num;
    vector<Thread> _threads; // 线程组
    queue<T> _task_queue;    // 任务队列
    bool _isrunning;         // 运行状态
    int _sleep_thread_num;   // 休眠

    pthread_mutex_t _mutex;
    pthread_cond_t _cond; // 等待队列，没有收到任务的线程就等待
};
```

`Thread.hpp`

```c++
#ifndef _MYTHREAD
#define _MYTHREAD

#include <iostream>
#include <pthread.h>
#include <string>
#include <functional>

using namespace std;

namespace ThreadMoudle
{
    using func_t = function<void(const string &)>;

    class Thread
    {
    public:
        void Excute() // 线程执行任务
        {
            cout << _name << " is running" << endl;
            _isrunning = true;
            _func(_name);
            _isrunning = false;
        }

    public:
        Thread(const string &name, func_t func)
            : _name(name), _func(func)
        {
            cout << "create " << _name << " done" << endl;
        }
        static void *ThreadRoutine(void *arg)
        { // 新线程都会先执行这个函数
            Thread *self = static_cast<Thread *>(arg);
            self->Excute();
            return nullptr;
        }

        bool Start() // 线程开始启动
        {
            int res = pthread_create(&_tid, nullptr, ThreadRoutine, this);
            if (res != 0)
                return false;
            return true;
        }

        void Stop()
        {
            if (_isrunning)
            {
                pthread_cancel(_tid);
                _isrunning = false;
                cout << _name << " Stop" << endl;
            }
        }

        void Join()
        {
            pthread_join(_tid, nullptr);
            cout << _name << " is Joined" << endl;
        }

        string Getname()
        {
            return _name;
        }
        ~Thread()
        {
            Stop();
        }

    private:
        string _name;    // 线程名
        pthread_t _tid;  // 线程ID
        bool _isrunning; // 是否在执行任务
        func_t _func;    // 要执行的回调函数
    };
};

#endif
```

`main.cc`

```c++
#include "ThreadPool.hpp"
#include "Task.hpp"
#include <unistd.h>
int main()
{
    ThreadPool<Task> *tp = new ThreadPool<Task>();// 线程池
    tp->Init();
    tp->Start();
    int cnt = 3;
    srand(time(nullptr));
    while (cnt)
    {
        // 主线程安排任务给线程池
        sleep(1);
        int x = rand() % 100;
        int y = rand() % 100;
        Task t(x, y);
        tp->Push(t);
        sleep(1);
        cout << "cnt: " << cnt-- << endl;
    }
    tp->Stop();
    cout << "threadpoll is end" << endl;
    sleep(10);

    return 0;
}
```

`task.hpp`

```c++
#pragma once

#include <iostream>
#include <functional>

// 要做加法
class Task
{
public:
    Task()
    {
    }
    Task(int x, int y) : _x(x), _y(y)
    {
    }
    void Excute()
    {
        _result = _x + _y;
    }
    void operator()()
    {
        Excute();
    }
    std::string debug()
    {
        std::string msg = std::to_string(_x) + "+" + std::to_string(_y) + "=?";
        return msg;
    }
    std::string result()
    {
        std::string msg = std::to_string(_x) + "+" + std::to_string(_y) + "=" + std::to_string(_result);
        return msg;
    }

private:
    int _x;
    int _y;
    int _result;
};
```

## 线程安全的单例模式

### 什么是单例模式

单例模式是一种 "经典的, 常用的, 常考的" **设计模式**.

### 什么是设计模式

IT行业这么火, 涌入的人很多. 俗话说林子大了啥鸟都有. 大佬和菜鸡们两极分化的越来越严重. 为了让菜鸡们不太拖大佬的后腿, 于是大佬们针对一些经典的常见的场景, 给定了一些对应的解决方案, 这个就是 **设计模式**

### 单例模式的特点

某些类, 只应该具有一个对象(实例), 就称之为单例.

例如一个男人只能有一个媳妇.

在很多服务器开发场景中, 经常需要让服务器加载很多的数据 (上百G) 到内存中. 此时往往要用一个单例的类来管理这些数据.

### 饿汉实现方式和懒汉实现方式

#### 饿汉方式实现单例模式

```c++
template <typename T>
class Singleton
{
    static T data;

public:
    static T *GetInstance()
    {
        return &data;
    }
};
```

#### 懒汉模式

```c++
template <typename T>
class Singleton
{
    static T *inst;

public:
    static T *GetInstance()
    {
        if (inst == NULL)
        {
            inst = new T();
        }
        return inst;
    }
};
```

存在一个严重的问题, 线程不安全.

第一次调用 GetInstance 的时候, 如果两个线程同时调用, 可能会创建出两份 T 对象的实例.

但是后续再次调用, 就没有问题了

#### 懒汉模式（线程安全版）

```c++
// 懒汉模式, 线程安全
template <typename T>
class Singleton
{
    volatile static T *inst; // 需要设置 volatile 关键字, 否则可能被编译器优化.
    static std::mutex lock;

public:
    static T *GetInstance()
    {
        if (inst == NULL)
        {                // 双重判定空指针, 降低锁冲突的概率, 提高性能.
            lock.lock(); // 使用互斥锁, 保证多线程情况下也只调用一次 new.
            if (inst == NULL)
            {
                inst = new T();
            }
            lock.unlock();
        }
        return inst;
    }
};
```

## STL、智能指针和线程安全

### STL中的容器是否是线程安全的

不是.

原因是, STL 的设计初衷是将性能挖掘到极致, 而一旦涉及到加锁保证线程安全, 会对性能造成巨大的影响.

而且对于不同的容器, 加锁方式的不同, 性能可能也不同(例如hash表的锁表和锁桶).

因此 STL 默认不是线程安全. 如果需要在多线程环境下使用, 往往需要调用者自行保证线程安全.

### 智能指针是否是线程安全的?

对于 unique_ptr, 由于只是在当前代码块范围内生效, 因此不涉及线程安全问题.

对于 shared_ptr, 多个对象需要共用一个引用计数变量, 所以会存在线程安全问题. 但是标准库实现的时候考虑到了这个问题, 基于原子操作(CAS)的方式保证 shared_ptr 能够高效, 原子的操作引用计数
