## 进程间通信

### 进程间通信目的

- 数据传输：一个进程需要将他的数据发送给另一个进程
- 资源共享：多个进程之间共享同样的资源
- 通知事件：一个进程需要向另一个或一组进程发送消息，通知它们发生了某种事情（比如进程终止要通知父进程）
- 进程控制：有些进程希望完全控制另一个进程的执行，此时控制进程希望能够拦截另一个进程所有的陷入和异常，及时知道它的状态改变

## 管道

- 管道是unix中最古老的进程间通信的形式
- 我们把从一个进程连接到另一个进程的一个数据流成为一个管道

![img](https://i-blog.csdnimg.cn/direct/1875634c4c0b46abad9cbe77899a7a86.png)

### 匿名管道

```
#include <unistd.h>
功能:创建一无名管道
原型
int pipe(int fd[2]);
参数
fd：文件描述符数组,其中fd[0]表示读端, fd[1]表示写端
返回值:成功返回0，失败返回错误代码
```

![img](https://i-blog.csdnimg.cn/direct/ba7d4bcb091b446394f98357760992e9.png)

- `fd[0]`: 管道读取端
- `fd[1]`: 管道写入端

举个例子：

```c++
// 从键盘中读取数据，写入管道，读取管道，写到屏幕上
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int main(){
    int fds[2];
    char buf[100];
    int len;
    if(pipe(fds)==-1){
        perror("make pipe");
        exit(1);
    }
    // 从标准输入中读取
    while(fgets(buf,100,stdin)){
        len = strlen(buf);
        if(write(fds[1],buf,len)!=len){
            perror("write to pipe");
            break;
        }
        memset(buf,0,sizeof buf);
        // 写入到管道
        if((len=read(fds[0],buf,100))==-1){
            perror("read from pipe");
            break;
        }
        // 从管道中读，读到标准输出
        if(write(1,buf,len)!=len){
            perror("write to stdout");
            break;
        }
    }
    return 0;
}
```

### 用fork来共享管道原理

**站在文件描述符角度，深度理解管道**

![img](https://i-blog.csdnimg.cn/direct/403b1d10ec694dfc83e7ee89a47a0624.png)

**站在内核角度，管道本质**

![img](https://i-blog.csdnimg.cn/direct/2b279bc03e0448c0a65f98b64079c39a.png)

### 管道的读写规则

- 当没有数据可读
  - `O_NONBLOCK` disable：read调用阻塞，即进程暂停执行，一直等到有数据来到为止
  - `O_NONBLOCK` enbale：read调用返回-1，errno值为EAGAIN
- 当管道满了
  - `O_NONBLOCK` disable：write调用阻塞，知道有进程来读走数据为止
  - `O_NONBLOCK` enbale：调用返回-1，errno这EAGAIN
- 如果所有管道写端对应的文件描述符被关闭，则read返回0
- 如果所有管道读端的文件描述符被关闭，则write操作会产生信号SIGPIPE，进而可能退出
- 当要写入的数据量不大于PIPE_BUF=4096时，linux将保证写入的原子性
- 当要写入的数据量大于PIPE_BUF时，linux将不保证写入的原子性

### 管道特点

- 只能用于具有共同祖先的进程之间进行通信；通常，一个管道由一个进程创建，然后该进程调用fork，此后父子进程之间就可以应用该管道
- 管道提供流式服务
- 一般而言，进程退出，管道释放，所以管道的生命周期跟随进程
- 一般而言，内核会对管道操作进行同步和互斥
- 管道是半双工的，只能像一个方向流动；需要双方通信，需要简历两个管道

![img](https://i-blog.csdnimg.cn/direct/d5c8912e3f644fb19af629d6bc29e5ea.png)

### 命名管道

- 管道应用的一个限制就是只能在具有共同祖先的进程键通信
- 如果想在两个不相关的进程之间交换数据，可以使用FIFO文件来做这项工作，它被称为命名管道
- 命名管道是一种特殊类型的文件

#### 创建一个命名管道

- 命名管道可以从命令行上创建，命令行的方式是使用下面这个命令

```
mkfifo filename
```

- 命名管道也可以在程序中创建，相关的函数有

```
int mkfifo(const char* filename,mode_t mode);
```

#### 匿名管道和命名管道的区别

- 匿名管道是由`pipe`函数创建并打开
- 命名管道是由`mkfifo`函数创建，打开用`open`
- FIFO（命名管道）和pipe（匿名管道）之间唯一的区别就是它们创建和打开的方式不同，一旦这些工作完成之后，它们具有相同的语义。

#### 命名管道的打开规则

- 如果当前打开操作是为了读而打开FIFO
  - O_NONBLOCK disbale：阻塞知道有相应的进程为写而开大该FIFO
  - O_NONBLOCK enbale：立刻返回成功
- 如果当前打开操作是为了写而打开FIFO
  - O_NONBLOCK disbale：阻塞知道有相应进程为了读而打开该FIFO
  - O_NONBLOCK enbale：立刻返回失败，错误码为ENXIO

## system V共享内存

共享内存是最快的IPC形式。一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话来说进程不在通过执行进入内核的系统调用来传递彼此的数据。

![img](https://i-blog.csdnimg.cn/direct/bd0cc7ce20e84fa79a909e2776f23a61.png)

每个进程的虚拟空间分布中都有一块区域专门用来存放公共资源。这个区域就是数据共享区

![img](https://i-blog.csdnimg.cn/blog_migrate/450438043cdfde5673b5d495d4ddc97e.png)

值得注意的是，这个数据共享区中的数据不属于任何一个进程，而是被多个进程共享。当一个进程连接到共享区中，操作系统会将这块共享内存段映射到进程的虚拟地址空间中，使得进程可以直接访问这块共享内存。**共享内存的声明周期是随操作系统，也就意味着，如果我们不主动删除共享内存，即使创建共享内存的进程已经终止，该共享内存也会一直存在，直到重启或者用指令删除**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/5b35f334fddccf27ff296dcf2d307bd9.png)

使用共享内存的步骤

1. 创建共享内存
2. 连接共享内存
3. 访问共享内存
4. 分离共享内存
5. 删除共享内存

### 创建共享内存区域

进程可以通过调用shmget函数来创建一个共享内存标识符，并且指定内存大小和权限等参数。该标识符类似与文件描述符fd，是操作系统给用户使用的，用来标识共享内存区域。

```c++
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/shm.h>

int shmget(key_t key,size_t size,int shmflag);
```

- `key`是一个键值，用于唯一标识共享内存区域。通常使用`ftok`函数来生成一个键值。
- `size`是要创建的共享内存的大小，一般建议是4096的整数倍。

- `shmflg`:由九个权限标志构成，它们的用法和创建文件时使用的mode模式标志是一样的
- 创建成功返回一个非负整数（shmid），否则返回-1.

`shmat`函数

功能：将共享内存段连接到进程地址空间

```
void *shmat(int shmid, const void *shmaddr, int shmflg);
参数
```

shmid: 共享内存标识
shmaddr:指定连接的地址
shmflg:它的两个可能取值是SHM_RND和SHM_RDONLY

返回值：成功返回一个指针，指向共享内存第一个节；失败返回-1

说明

```
shmaddr为NULL，核心自动选择一个地址
shmaddr不为NULL且shmflg无SHM_RND标记，则以shmaddr为连接地址。
shmaddr不为NULL且shmflg设置了SHM_RND标记，则连接的地址会自动向下调整为SHMLBA的整数倍。公式：shmaddr - 
(shmaddr % SHMLBA)
shmflg=SHM_RDONLY，表示连接操作用来只读共享内存
```

`shmdt`函数

```
功能：将共享内存段与当前进程脱离
原型
 int shmdt(const void *shmaddr);
参数
 shmaddr: 由shmat所返回的指针
返回值：成功返回0；失败返回-1
注意：将共享内存段与当前进程脱离不等于删除共享内存段
```

`shmctl`函数

```c++
功能：用于控制共享内存
原型
 int shmctl(int shmid, int cmd, struct shmid_ds *buf);
参数
 shmid:由shmget返回的共享内存标识码
 cmd:将要采取的动作（有三个可取值）
 buf:指向一个保存着共享内存的模式状态和访问权限的数据结构
返回值：成功返回0；失败返回-1
```

## 消息队列

- 消息队列提供了一个从一个进程向另外一个进程发送一块数据的方法

- 每个数据块都被认为是有一个类型，接收者进程接收的数据块可以有不同的类型值

- 特性方面
  - IPC资源必须删除，否则不会自动清除，除非重启，所以system V IPC资源的生命周期随内核

## 信号量

- 由于各进程要求共享资源，而且有些资源需要互斥使用。因此个进程竞争使用这些资源，进程的这种关系为进程的互斥
- 系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源
- 在进程中涉及到互斥资源的程序段叫临界区
- 特性方面
  - IPC资源必须删除，否则不会自动清理，除非重启