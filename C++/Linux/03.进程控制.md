## 写时拷贝

![img](https://i-blog.csdnimg.cn/direct/b179ef403ca743508a6240c6d3215737.png)

## 进程终止

### 进程退出场景

- 代码运行完毕，结果正确
- 代码运行完毕，结果不正确
- 代码异常终止

## 进程常见退出方法

正常终止：

1. 从main返回
2. 调用exit
3. _exit

异常退出：

- `ctrl+c`，信号终止

**_exit函数**

```c++
#include <unistd.h>
void _exit(int status);

```

参数：status 定义了进程的终止状态，父进程通过wait来获取该值

- 说明：虽然status是int，但是仅有低8位可以被父进程所用。所以_exit(-1)时，在终端执行$?发现返回值是255。

**exit函数**

```c++
#include <unistd.h>
void exit(int status);
```

exit最后也会调用exit, 但在调用exit之前，还做了其他工作

1. 执行用户通过 atexit或on_exit定义的清理函数
2. 关闭所有打开的流，所有的缓存数据均被写入
3. 调用_exit

![img](https://i-blog.csdnimg.cn/direct/e5aa2f028f1d430a9ab41cbea95ba107.png)

**return退出**

return是一种更常见的退出进程方法。执行return n等同于执行exit(n),因为调用main的运行时函数会将main的返回值当做 exit的参数。

## 进程等待

- 之前讲过，子进程退出，父进程如果不管，就会造成僵尸进程的问题，引起内存泄漏
- 进程一旦变成僵尸状态，`kill -9`也无能为力，因为这个进程早就死了。
- 父进程派给子进程的任务完成的如何，我们需要知道
- 五金城通过进程等待的方式，回收子进程资源，获取子进程退出信息。

### 进程等待的方法

**`wait`方法**

```c++
#include<sys/types.h>
#include<sys/wait.h>
pid_t wait(int*status);
返回值：
	成功返回被等待进程pid，失败返回-1
参数：
    输出型参数，获取子进程退出状态；不关心，传NULL即可
```

**`waitpid`方法**

```c++
pid_ t waitpid(pid_t pid, int *status, int options);
返回值：
 当正常返回的时候waitpid返回收集到的子进程的进程ID；
 如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0；
 如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在；
参数：
 pid：
 Pid=-1,等待任一个子进程。与wait等效。
 Pid>0.等待其进程ID与pid相等的子进程。
 status:
 WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）
 WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）
 options:
 WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进
程的ID。
```

- 如果子进程已经退出，调用wait/waitpid时，wait/waitpid会立即返回，并且释放资源，获得子进程退出信息
- 如果在任意时刻调用wait/waitpid，子进程存在并且正常运行，则进程可能阻塞
- 如果不存在该子进程，则立即出错返回

### 获取子进程status

- wait和waitpid，都有一个status参数，该参数是一个输出型参数，由操作系统填充
- 如果传递NULL，表示不关心子进程的退出状态信息
- 否则，操作系统会根据该参数，将子进程的退出信息反馈给父进程
- `status`不能简单的看做一个整型，应该当做是一个位图

![img](https://i-blog.csdnimg.cn/direct/10ab747b47584335a430e34e88d1ac69.png)

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>

int main(){
    pid_t pid = fork();
    if(pid < 0){
        perror("fork");
        exit(1);
    }
    else if(pid == 0){
        // child
        printf("I am child,pid:%d\n",getpid());
        sleep(15);
        exit(10);
    }
    else{
        // parent
        int st;
        int ret = wait(&st);
        if(ret>0&&((st&0xff)==0)){
            // 正常退出
            printf("child exit code:%d\n",(st>>8)&0xff);
        }
        else if(ret>0){
            // 异常退出
            printf("sig code: %d\n",st&0x7f);
        }
    }
    return 0;
}
```



![img](https://i-blog.csdnimg.cn/direct/d735750c2c8749e5acd54c756f42d758.png)

- 进程的阻塞等待方式

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>

int main(){
    pid_t pid = fork();
    if(pid == 0){
        // child
        printf("child is run,pid is %d\n",getpid());
        sleep(3);
        exit(10);
    }
    else{
        int status = 0;
        pid_t ret = waitpid(-1,&status,0);
        printf("this is test for wait\n");
        if(WIFEXITED(status)&&ret==pid){
            printf("wait child 5s success, child return code is :%d.\n",WEXITSTATUS(status));
        }
        else{
            printf("wait child failed, return.\n");
            return 1;
        }
    }  
    return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/658726be370a4174b5443cb2a048ad0e.png)

- 进程的非阻塞等待

```c++
#include <stdio.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <stdlib.h>

int main(){
    pid_t pid = fork();
    if(pid == 0){
        // child
        printf("child is run, pid is : %d\n",getpid());
        sleep(5);
        exit(10);
    }
    else{
        int status = 0;
        pid_t ret = 0;
        do
        {
            ret = waitpid(-1,&status,WNOHANG);// 非阻塞等待
            if(ret == 0)printf("child is running\n");
            sleep(1);
        }while(ret==0);
        if(WIFEXITED(status) && ret==pid){
            printf("wait child success,child return code is: %d\n",WEXITSTATUS(status));
        }
        else{
            printf("wait child failed,return\n");
            return 1;

        }
    }
    return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/b88a0a0898ea486fab6bb973f465181d.png)

## 进程程序替换

### 替换原理

用fork创建子进程后执行的是和父进程相同的程序(但有可能执行不同的代码分支),子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时,该进程的用户空间代码和数据完全被新程序替换,从新程序的启动例程开始执行。调用exec并不创建新进程,所以调用exec前后该进程的id并未改变

### 替换函数

```c++
#include <unistd.h>`

int execl(const char *path, const char *arg, ...);
int execlp(const char *file, const char *arg, ...);
int execle(const char *path, const char *arg, ...,char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],char *const envp[]);
int execve(const char *path, char *const argv[], char *const envp[]);
```

### 函数解释

- 这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回
- 如果调用出错则返回-1
- 所以exec函数只有出错的返回值而没有成功的返回值

### 命名理解

- l(list) : 表示参数采用列表
- v(vector) : 参数用数组
- p(path) : 有p自动搜索环境变量PATH

- e(env) : 表示自己维护环境变量

### 解释参数

`path`表示的是可执行文件的路径

`arg`表示命令行参数的某个元素，第一个必须是程序名，其余每一个arg参数表示一条选项用逗号隔开。最后以NULL结尾。

`file`表示可执行文件名，在`execvp`、`execlp`中会去其环境变量中找

`envp[]`表示环境变量数组，可提供给替换程序作为环境变量

`argv[]`表示命令行参数数组，以命令名为首，以NULL结尾。给替换程序提供命令选项。

![img](https://i-blog.csdnimg.cn/direct/6e1ea00fd64d4b78b4f611b4c1cf8922.png)

![img](https://i-blog.csdnimg.cn/direct/faab0e1e9c4e42afbed86fbf8b099e6b.png)

```c++
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main(){
    execl("/usr/bin/ls","ls",NULL);
    return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/62877352daf64f78b358d0739e0a4c90.png)