## 信号

- 信号是进程之间事件异步通知的一种方式，属于软中断

**`kill -l`命令查看系统定义的信号**

![img](https://i-blog.csdnimg.cn/direct/2100255596d94649abdcd826579768d7.png)

常见的信号是1-31，其中34-64都是实时信号，可以这样查看每个信号的默认处理动作——

`man 7 signal`

![img](https://i-blog.csdnimg.cn/direct/f83e17fc59504db69057b7e97bc9cb70.png)

![img](https://i-blog.csdnimg.cn/direct/662e3ccc0fa740689b14f07fc3eb849f.png)

### Core和Term的区别

查看信号的默认响应行为我们可以发现发现，大多信号都是Core或者Term,且这两种信号都表示**终止进程**。那这两种终止进程的方式有什么区别呢

Term就是普通的终止进程，没有其他动作。而Core不仅会终止进程，还会生成一个**核心转储文件**。

```text
核心转储（Core Dump）文件包含了进程终止时的内存映像，和关于进程状态的详细信息，也就意味着，通过这个核心转储文件我们就能知道这个进程在终止之前发生了什么。这对于开发者来说是非常宝贵的调试信息（可以借助gdb调试器加载其中的信息并调试）。
```

系统默认进程终止时不生产Core文件，因为core文件中可能包含用户密码等隐私信息，不安全。也就意味着，即使某个进程收到`SIGQUIT`信号(默认产生core文件)也不会生成core文件。但是在开发调试阶段可以使用`ulimit`指令改变这个限制,允许产生core文件。此外core文件的大小取决于进程的Resource Limit(这个信息保存 在PCB中，默认是0）。

此外，如果子进程终止之后生成了core文件，那么子进程的退出码中的[core_dump](https://img-blog.csdnimg.cn/direct/0b0300ecfe834be2b238653d6121a6a5.png)标记位就会置为1。

### 信号处理常见方式

1. 忽略该信号
2. 执行该信号的默认处理动作
3. 提供一个信号处理函数,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉一个信号

#### signal函数

signal函数（库函数）是用于设置处理某个信号时所调用的处理函数，也被称为信号处理器。由头文件signal.h提供，这个头文件属于c标准库的一部分。**该函数允许程序自定义特定信号的响应行为**。这一点也证实了信号的特征

```c++
 #include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

- `sighandler_t`是一个函数指针，作为`signal`的参数
- `signum`表示要捕捉的信号
- 返回值是一个指向之前处理该信号的函数的指针，或者在错误情况下返回 SIG_ERR
- `signal`函数并不是系统调用，但是其内部封装了系统调用`sigaction`。一旦我们使用signal函数捕捉了某个信号，该进程响应该信号的方式就可以自己决定了。但是值得注意的是，有一些特殊的信号的响应方式并不会完全被`sighandler`替代。

举个例子：

```c++
#include <stdio.h>
#include <signal.h>
#include <unistd.h>
#include <stdlib.h>

// 自定义信号处理函数
void signal_handler(int signum) {
    printf("捕获到信号: %d\n", signum);
    switch(signum) {
        case SIGINT:
            printf("接收到 Ctrl+C，程序将退出\n");
            exit(0);
            break;
    }
}
int main() {
    // 设置信号处理函数
    if (signal(SIGINT, signal_handler) == SIG_ERR) {
        perror("设置 SIGINT 处理函数失败");
        return 1;
    }
    printf("程序运行中... 按 Ctrl+C 测试信号处理\n");
    // 保持程序运行
    while(1) {
        sleep(1);
    }
    return 0;
}
```

## 产生信号的方式

### 通过终端按键产生信号

`ctrl+c`表示一个终止信号这个好理解，但是如何证明就是产生了信号`SIGINT（2）`呢？我们可以用signal函数捕捉`SIGINT`函数，然后在自定义该信号的响应方式，最后在进程运行时按下ctrl+c观察，请参考上述的代码

![img](https://i-blog.csdnimg.cn/direct/7922f2235a2649689567b2f4f8ac13ce.png)

### 通过系统函数想进程发送信号

其实就是我们常用的kill指令发送信号给指定进程。kill指令本质上是调用了系统调用kill函数。kill系统调用可以发信号到某一个进程，也可以发送到某一组进程。

**kill函数**

```c++
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```

- `pid`表示要信号发送到哪一个进程
- `sig`表示发送信号的类型
- 发送成功返回0，否则-1.

**raise函数**

raise函数可以给当前进程发送指定的信号（自己给自己发信号）。

```c++
#include<signal.h>
int raise(int sig);
```

- sig表示发送信号的类型
- 发送成功返回0，否则-1。

**abort函数**

```c++
#include <stdlib.h>
void abort(void);
```

这个函数没有参数，并且它也没有返回值。调用 abort 函数后，程序会立即异常终止。本质上这个函数调用之后，操作系统就会先该进程发送一个`SIGABRT`信号,这个信号会终止当前进程，且通常生成core文件。（**其实就是调用raise发送一个`SIGABRT`信号**）

### 信号的产生

#### 由软件条件产生信号

软件条件产生信号其实就是软中断的一种，就是因为某种软事件或程序内部逻辑触发的信号。**比如管道读端关闭之后，写端就会收到一个`SIGPIPE`信号进而终止。** 下面介绍`alarm`函数和`SIGALRM`信号

`alarm`函数是一个定时器，可以设置一个时间，这个定时器会在未来的一个时刻发送一个`SIGALRM`信号给当前进程（该信号默认处理动作是终止进程）。alarm函数原型具体如下

```c++
#include<unistd.h>
unsigned int alarm(unsigned int seconds);
```

- seconds表示的是一个时间，单位为秒。如果seconds为0,表示取消以前设置的定时器。
- 返回值是0或者是**以前设定的闹钟时间还余下的秒数**。

#### 由硬件条件产生信号

```text
硬件异常被硬件以某种方式被硬件检测到并通知内核,然后内核向当前进程发送适当的信号。例如当前进程执行了除以0的指令,CPU的运算单元会产生异常,内核将这个异常解释为`SIGFPE`信号发送给进程.再比如当前进程访问了非法内存地址,MMU会产生异常,内核将这个异常解释为`SIGSEGV`信号发送给进程。具体这个异常是怎么被检测出来的我们无需关心，我们只要知道发生硬件异常之后操作系统会向该进程发送一个信号来终止进程就行了。
```

为什么说除0是硬件异常？**因为除0这个操作是CPU在执行的，除0之后会CPU触发异常信号**。访问野指针也是类似

**野指针**

```c++
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig)
{
    printf("catch a sig : %d\n", sig);
    sleep(1);
}

int main()
{
    signal(SIGSEGV, handler);
    sleep(1);
    int *p = NULL;
    *p = 100;

    return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/dff26fc5a6984ede903de21bd58321b5.png)

说明信号11就是`SIGSEGV`信号，但是一个很奇怪的现象：**为什么handler函数会一直执行下去？**

代码`int *p = NULL; *p = 100;` 显然会引发一个 `SIGSEGV` 信号，因为它尝试向 NULL 指针所指向的内存地址写入一个值，这是非法的内存访问。之后CPU触发一个硬件异常信号，执行handler函数之前操作系统会保存触发信号的指令地址于上下文中，执行完handler之后，操作系统又会回到之前保存的地址中去，即又回到了信号发生时的状态，于是就又重新执行*p这个代码。于是就产生了死循环。


**直接在handler函数中调用exit()函数确保进程终止**

## 信号的阻塞

### 常见信号术语

- 信号递达（Delivery）:实际执行信号的处理动作
- 信号未决（Pending）:信号从产生到递达的中间状态
- 信号阻塞（Block）：进程可以选择阻塞某一个信号，被阻塞的的信号保持在未决状态，直到接触阻塞才会被递达。
- 信号忽略：信号在递达之后的一种不作为。与阻塞不同，被阻塞的信号没有被递达。
- 捕获信号：进程通过自定义信号处理程序来处理信号，而不是使用系统的默认动作

### 信号在内核中的表示

对于信号的学习，我们将其分为三个部分：产生信号、接收信号、处理信号。现在我们已经知道了信号是如何产生的，那我们的进程又是如何接收信号的呢？换句话说，一个进程是如何知道操作系统给它发信号了呢？

#### Pending表

```
其实在进程的PCB里面有一个信号位图（Signal Bitmap），用于表示有哪些发送给该进程但是还没有被处理的信号。每一个位都表示一种信号，如果有信号发送给该进程，那么这个位图对应的信号位就会置为1。假如给进程发送一个3号信号，那么这个位图的第3位就会置为1。因为信号的发送与进程实际处理之间是异步的，所以发送信号之后进程可能不会立即处理这个信号。
这个信号位图也被称为Pending(未决)表
```

有了`Pending`表，进程就能知道接受了哪些信号并准备处理信号，而**一个信号是否要被处理，则需要观察该信号是否被阻塞。此时需要查看进程的Block表中的内容**

#### Block类

```
同样的，PCB里面还有一个位图表示被进程阻塞的信号集。其每一个比特位都表示一个信号编号，如果是1则表示该对应信号被阻塞，即使信号到达，进程也不会处理。直到信号从该Block表中移除。Block表起到的作用实际上就是一个信号掩码（sig mask）。
```

有了Block表和Pending表，我们就能知道有哪些信号需要被处理，那么该怎么处理呢？这就是handler表中的内容了。

#### handler表

```
在进程PCB中有一个handler表，该表实际上就是一个函数指针数组（sighandler_t handler[32]） 数组的下标其实就是信号的编号。数组的内容一个函数指针，指向对应信号的处理函数。有了这个表，我们就能知道一个信号在该进程的 响应方式，显然，对handler数组某一元素内容的修改，即修改某一信号的响应方式。
```

![img](https://i-blog.csdnimg.cn/direct/649d876843b44f2b8e9507fed057607c.png)

### 信号集操作函数

#### sigemptyset

功能：初始化一个空的信号集，即将信号集中所有信号清楚，也就是让信号集中的每一个比特位清0。
原型

```c++
int sigemptyset(sigset_t *set);
```

- 将`set`指向的信号集清空
- 成功返回0，否则返回-1.

#### sigfillset

功能：初始化一个满的信号集，跟sigemptyset函数相反，让信号集中每一个比特位都置为1。
原型：

```c++
int sigfillset(sigset_t *set);
```

- 将`set`指向的信号集填满
- 成功返回0，否则-1.

#### sigaddset

功能：从信号集中添加一个指定的信号。
原型：

```c++
int sigaddset(sigset_t *set, int signum);
```

- 给`set`指向的信号集中添加一个`signum`信号
- 成功放回0，否则-1.

#### sigdelset

从信号集中删除一个指定的信号
原型：

```c++
int sigdelset(sigset_t* set,int signum);
```

- 从`set`指向的信号集中删除一个`signum`信号
- 成功返回0，失败则返回-1.

#### sigismember

功能：检查一个指定的信号是否在信号集中
原型

```c++
int sigismember(const sigset_t *set,int signum);
```

- 如果`set`指向的信号集中有`signum`信号就返回1，不在返回0，查看失败返回-1。

#### sigprocmask

功能：检查或者修改信号屏蔽字（阻塞信号集）。用来阻塞或者解阻信号。
跟上面的sigaddset和sigdelset函数不一样的是，sigprocmask可以修改进程的Block表。

原型：

```c++
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

how:指定操作类型。以下是常见的操作类型：
SIG_BLOCK:将set指向的信号集中的信号添加到阻塞信号集中
SIG_UNBLOCK：从阻塞信号集中移除set指向的信号集中的信号
SIG_SETMASK:将set指向的信号集设置为新的阻塞信号集
set指向一个sigset_t类型的对象，用于修改阻塞信号集。如果该参数为NULL，则表示不修改阻塞信号集。
oldset:指向一个sigset_t类型的对象，用于存储被set修改之前的阻塞信号集。
成功返回0，失败返回-1.

#### sigpending

功能：获取当前进程的未决信号集（pending表）
原型：

```c++
int sigpending(sigset_t *set);
```

- 将`set`指向的信号集重置为当前进程的未决信号集
- 成功返回0，否则-1.

## 可重入函数

可重入函数是指，一个函数在被多个线程调用时，不会因为共享资源的竞争而导致数据不一致等错误。这种函数可以在多线程环境中调用。意思就是说，可重入函数里面的数据都是临时变量，随着函数栈帧的销毁而销毁，一个线程调用这个函数并不会影响其它的线程。

```c++
int reentrant_function(int x) {
    int result = x * x;
    return result;
}
```

举一个非可重入函数的例子：

```c++
int global_var = 0;

void non_reentrant_function(int x) {
    global_var = x;
}

```

**这个函数修改了全局变量，在多线程环境下，多个线程同时调用，会导致数据竞争和不一致。所以是非可重入函数。**

 可重入函数的特点：

1. 不适用静态和动态变量：可冲入函数被调用时，只会访问局部变量
2. 不依赖共享资源：可重入函数不依赖外部资源，如果依赖，则加锁
3. 不调用非可重入函数：一旦调用，那么这个函数也是非可重入函数
4. 线程安全：可重入函数是线程安全的，但是线程安全的函数不一定是可重入函数

可重入函数是保证多线程安全编程的一种重要方法，通过保证每次调用之间的状态独立和避免共享资源的竞争来避免很多并发编程中的问题。

## volatile关键字

volatile是一个类型关键字，通常用来修饰变量。告诉编译器该变量可能会在程序执行过程中被意外改变，因此编译器不应该对这样的变量进行优化。

```
编译器在优化代码的时候，会大概推断出哪些变量在特定的范围内不会改变。对于这样的变量，编译器会把它们的值缓存在寄存器中，这也就不用再去内存上访问，需要的时候就在寄存器上读取。但是，如果一个变量的值是通过硬件中断、另一个线程或信号处理函数来改变的，那么编译器之前缓存在寄存器中的值就不准确了，从而导致程序出现错误的行为。
```

### volatile关键字的作用

保持内存的可见性，告知编译器，被该关键字修饰的变量，不允许被优化，对该变量的任何操作，都必须在真实的内存中进行操作