标准C++为了加强类型转换的可视性，引入了四种命名的强制类型转换符

## `static_cast`

`static_cast`用于非多态类型转换的可视性（静态转换），编译器隐式执行的任何类型转换都可以用`static_cast`，但是他不能用于两个不相关的类型进行转换

```c++
int main()
{
	double d = 3.14;
	int a = static_cast<int>(d);
	cout << a << endl;
	const char* s1 = "Hello";
	string s2 = static_cast<string>(s1);
	cout << s2 << endl;
	return 0;
}
```

## `reinterpret_cast`

`reinterpret_cast`操作符通常是操作数的位模式提供较低层次的重新解释，用于将一种类型转换为另一种不同的类型

```c++
int main()
{
	double d = 12.34;
	int a = static_cast<int>(d);
	cout << a << endl;
	// 这里使用static_cast会报错，应该使用reinterpret_cast
	//int *p = static_cast<int*>(a);
	int* p = reinterpret_cast<int*>(a);
	return 0;
}
```

## `const_cast`

`const_cast`最常用的用途就是删除变量的const属性，方便赋值

```c++
int main()
{
	const int a = 2;
	int* p = const_cast<int*>(&a);
	*p = 3;
	cout << a << endl; // 2
	return 0;
} 
```

## dynamic_cast

dynamic_cast用于将一个父类对象的指针/引用转换成子类对象的指针或者引用（动态转换）

**向上转型：子类对象指针/引用->父类对象指针/引用**

**向下转型：父类对象指针/引用->子类对象指针/引用**

注意：

1. **`dynamic_cast`只能用于父类含有虚函数的类**
2. **`dynamic_cast`会检查是否可以转换成功，能成功就转换，否则返回0**

```c++
class A
{
public:
	virtual void f() {}
};
class B : public A
{};
void fun(A* pa)
{
	// dynamic_cast会先检查是否能转换成功，能成功则转换，不能则返回
	B* pb1 = static_cast<B*>(pa);
	B* pb2 = dynamic_cast<B*>(pa);
	cout << "pb1:" << pb1 << endl;
	cout << "pb2:" << pb2 << endl;
}
int main()
{
	A a;
	B b;
	fun(&a);
	fun(&b);
	return 0;
}
```

**第一次调用 `fun(&a)`**

```c++
A* pa = &a;  // pa指向A对象

B* pb1 = static_cast<B*>(pa);  // 强制转换，不检查安全性
B* pb2 = dynamic_cast<B*>(pa); // 运行时检查，发现pa实际指向A对象
```



**结果**:

- `pb1`: 非空指针（强制转换成功）
- `pb2`: 空指针（运行时检查失败，因为A对象不是B对象）

**第二次调用 `fun(&b)`**

```
A* pa = &b;  // pa指向B对象（向上转型）

B* pb1 = static_cast<B*>(pa);  // 强制转换回B*
B* pb2 = dynamic_cast<B*>(pa); // 运行时检查，发现pa实际指向B对象
```

**结果**:

- `pb1`: 非空指针
- `pb2`: 非空指针（两者都成功）