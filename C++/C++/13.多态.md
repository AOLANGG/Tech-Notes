## 多态的概念

通俗来说，就是多种形态，**去完成某个行为，不同的对象去完成的时候会产生不同的状态**

## 多态的定义和实现

### 多态的构成条件

多天是在不同继承关系的类对象，去调用同一函数，产生不同的行为。比如Student继承了Person。Person对象买票全价，Student对象买票半价。

**构成多态有两个条件**

1. 必需通过基类的指针或者引用调用虚函数
2. 被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写

![img](https://i-blog.csdnimg.cn/direct/614eb019cea14196a8d90095fbfb3483.png)

### 虚函数

虚函数：被`virtual`修饰的类成员函数成为虚函数

```c++
class Person
{
public:
    virtual void BuyTicket(){
        cout<<"全价"<<endl;
    }
};
```

### 虚函数的重写

虚函数的重写：**派生类中有一个跟基类完全相同的虚函数（即派生类虚函数和基类虚函数的返回值、函数名字、参数列表完全相同），则称子类的虚函数重写了基类的虚函数**

**虚函数重写的两个例外**

1. **协变（基类和派生类虚函数返回值类型不同）**

派生类重写基类虚函数时，与基类虚函数返回值类型不同。基类虚函数返回基类对象的指针或引用，派生类虚函数返回派生类对象的指针或者引用，成为协变。

```c++
class A
{
};
class B : public A
{
};
class Person
{
public:
    virtual A *f() { return new A; }
};
class Student : public Person
{
public:
    virtual B *f() { return new B; }
};
```

2. **析构函数的重写（基类和派生类析构函数名字不同）**

如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加`virtual`关键字，都与基类析构函数构成重写，即使它们名字不同。虽然函数名字不同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一成`destructor`

```c++
class Person
{
public:
    virtual ~Person()
    {
        cout<<"~Person"<<endl;
    }
};
class Student:public Person
{
public:
    virtual ~Student()
    {
        cout<<"~Student"<<endl;
    }
};
int main()
{
    Person* p1 = new Person;
    Person* p2 = new Student;

    delete p1;
    delete p2;
    return 0;
}
```

### `override`和`final`

C++11提供了`override`和`final`两个关键字，可以帮助用户检测是否重写

1. **final：修饰虚函数，表示虚函数不能再被重写**

```c++
class Car
{
public:
    virtual void Drive() final
    {}
};

class Benz:public Car
{
public:
    // 这里会报错
    virtual void Drive()
    {
        cout<<"舒适"<<endl;
    }
};
```

2. **`override`：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错**

```c++
class Car
{
public:
    virtual void Drive() {}
};
class Benz : public Car
{
public:
    virtual void Drive() override
    {
        cout << "Benz-舒适" << endl;
    }
};
```

## 重载、覆盖（重写）、隐藏（重定义）的对比

![img](https://i-blog.csdnimg.cn/direct/b2203d9110ea4b768ba6c3a08a1e437b.png)

## 抽象类

在虚函数的后面加上=0，这个函数叫做纯虚函数。**包含纯虚函数的类叫做抽象类，抽象类不能实例化出对象**，派生类继承后必须重写纯虚函数，才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。

```c++
class Car
{
public:
    virtual void Drive() = 0;
};
class Benz : public Car
{
public:
    virtual void Drive() override
    {
        cout << "Benz-舒适" << endl;
    }
};
class BMW : public Car
{
public:
    virtual void Drive()
    {
        cout << "BMW-操控" << endl;
    }
};
int main()
{
    Car *pBenz = new Benz;
    pBenz->Drive();
    Car *pBMW = new BMW;
    pBMW->Drive();
    return 0;
}
```

### 接口继承和实现继承

普通函数的继承是一种实现继承，派生类继承基类函数，就可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口，如果不识闲，多态，就不要把函数定义成虚函数。

## 多态的原理

### 虚函数表

```c++
class Base
{
public:
	virtual void Func1()
	{
		cout << "Func1()" << endl;
	}

private:
	int _b = 1;
};
int main()
{
	Base b;
	cout << sizeof b << endl;
	return 0;
}
```

**最终输出的答案是`8`**

![img](https://i-blog.csdnimg.cn/direct/afc9c87600b84b5ba9b0c800cdee95cd.png)

**除了`b`，还多了一个`_vfptr`放在对象的前面，对象中的这个指针叫做虚函数表指针（`v`代表`virtual`，f代表`function`）**。一个含有虚函数的类至少都有一个虚函数表指针，因为虚函数的地址要被放在虚函数表中，虚函数表也叫做虚表。

### 动态绑定和静态绑定

1. 静态绑定又称为前期绑定，**在程序编译期间确定了程序的行为，也称为静态多态**，比如函数重载
2. 动态绑定又称为后期绑定，在程序运行期间，根据具体拿到的类型确定程序的具体行为，调用具体的函数，也称为**动态多态**



## 单继承和多继承关系的虚函数表

### 单继承的虚函数表

```c++
class Base {
public:
	virtual void func1() { cout << "Base::func1" << endl; }
	virtual void func2() { cout << "Base::func2" << endl; }
private:
	int a;
};
class Derive :public Base {
public:
	virtual void func1() { cout << "Derive::func1" << endl; }
	virtual void func3() { cout << "Derive::func3" << endl; }
	virtual void func4() { cout << "Derive::func4" << endl; }
private:
	int b;
};
int main()
{
	Base b;
	Derive d;

	return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/599be70f8d534c16b39f527a0b97c3b7.png)

### 多继承中的虚函数表

```c++
class Base1 {
public:
	virtual void func1() { cout << "Base1::func1" << endl; }
	virtual void func2() { cout << "Base1::func2" << endl; }
private:
	int a=1;
};
class Base2 {
public:
	virtual void func1() { cout << "Base2::func1" << endl; }
	virtual void func2() { cout << "Base2::func2" << endl; }
private:
	int b=2;
};
class Derive : public Base1, public Base2 {
public:
	virtual void func1() { cout << "Derive::func1" << endl; }
	virtual void func3() { cout << "Derive::func3" << endl; }
private:
	int d=3;
};
typedef void(*VFPTR) ();
void PrintVTable(VFPTR vTable[])
{
	cout << " 虚表地址>" << vTable << endl;
	for (int i = 0; vTable[i] != nullptr; ++i)
	{
		printf(" 第%d个虚函数地址 :0X%x,->", i, vTable[i]);
		VFPTR f = vTable[i];
		f();
	}
	cout << endl;
}
int main()
{
	Derive d;
	VFPTR* vTableb1 = (VFPTR*)(*(int*)&d);
	PrintVTable(vTableb1);
	Base2* ptr = &d;
	VFPTR* vTableb2 = (VFPTR*)(*(int*)(ptr));
	PrintVTable(vTableb2);
	return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/7c0b417caa2040519a278406a820c91e.png)

多出来的`func3`被放在第一个虚函数表中

补充：`sizeof(Derive)`为20

## 问答题

1. **什么是多态？**

去完成某个行为，当不同的对象去完成时会产生出不同的状态

2. **什么是重载、重写、隐藏？**

函数重载要求，在同一作用域中，函数名、函数参数都要相同。

重写，是指两个函数分别在基类和派生类中，函数名/参数/返回值都相同（协变除外）

隐藏：两个函数分别在基类和派生类中，函数名相同，两个基类和派生类的同名函数不构成重写就是重定义。

3. **多态的实现原理**

每个包含虚函数的类都有一个虚函数表，它是一个指针数组用来存放所有虚函数的地址，虚函数表在编译的时候生成，同一个类的对象共享同一张虚函数表，被各自对象的虚函数指针指向。在对象构造的时候，会初始化虚函数指针，使其指向对应的虚函数表。虚函数调用的时候，会去虚函数指针指向的虚函数表中查找对应的虚函数的地址，这样就实现了多态。

4. **inline函数可以是虚函数吗？**

可以，不过编译器就会忽略`inline`属性，这个函数不再是`inline`，因为虚函数要放在虚表中

5. **静态成员可以是虚函数吗？**

不能，因为静态成员函数没有this指针，使用类型::成员函数的调用方式无法访问虚函数表，所以静态成员函数无法放进虚函数表。

6. **构造函数可以是虚函数吗？**

不能，因为对象中的虚函数表指针就是在构造函数初始化列表中才初始化的。

7. **析构函数可以是虚函数吗**

可以，而且推荐把析构函数定义成虚函数，可以有效的避免内存泄漏

8. **对象访问普通函数快还是虚函数更快**

首先如果是普通对象，是一样快的。如果是指针对象或者是引用对象，则调用的普通函数快，因为构成多态，运行时调用虚函数需要到虚函数表中去查找。

9. **虚函数表实在什么阶段生成的？**

虚函数表是在编译阶段就生成的，一般情况下存在代码段(常量区)的。

10. **C++菱形继承的问题？虚继承的原理**

菱形继承会有冗余和二义性的问题。

当一个类虚继承另一个类时，编译器会为这个类添加一个隐藏的额成员——虚基表指针，指向一个虚基表，表中存储了虚基类相对于本类的偏移量

11. **什么是抽象类？抽象类的作用**

包含了纯虚函数的类就是抽象类。

抽象类强制重写了虚函数，另外抽象类体现出了接口继承关系。
