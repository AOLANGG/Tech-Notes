## 泛型编程

编译与类型无关的通用代码，是代码复用的一种手段

## 函数模版

函数模板代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据市参类型产生喊出的特定类型版本

**语法**

```c++
template<typename T1, typename T2,......,typename Tn>
```

**函数模板是一个蓝图，它本身不是函数，是编译器用使用方式产生特定具体类型的模具。所以其实模板就是将本来应该我们做的重复的事情交给了编译器**

![img](https://i-blog.csdnimg.cn/direct/cc72abf00d49457fa272b899b38c8c22.png)

**在编译器编译阶段**，对于模板函数的使用，**编译器需要根据传入的实参类型来推演生成对应类型的函数**以供调用。比如：**当使用double类型使用函数模板时，编译器通过对视参类型的推演，将T确定为double类型，然后产生一份专门处理double类型的代码**，对于字符类型也是如此。

### 函数模板的实例化

**用不同类型的参数使用函数模板时**，成为函数模板的**实例化**。模板参数实例化分为：**隐式实例化和显式实例化**

1. **隐式实例化：让编译器根据实参推演参数的实际类型**

```c++
template <class T>
T Add(const T& left, const T& right)
{
	return left + right;
}
int main()
{
	int a1 = 10, a2 = 20;
	double d1 = 10.0, d2 = 20.0;
	cout << Add(a1, a2) << endl;
	cout << Add(d1, d2) << endl;
	return 0;
}
```



2. **显示实例化：在函数名后的<>中制定模板参数的实际类型**

```c++
template <class T>
T Add(const T& left, const T& right)
{
	return left + right;
}
int main()
{
	int a = 10;
	double b = 20.1;
	// 显式实例化
	std::cout << Add<double>(a, b) << std::endl;
	return 0;
}
```

### 函数模板运行原理

#### 实例化之前

编译器在编译阶段只是简单检测下函数模板是否存在语法问题，不会生成代码

#### 实例化之后

编译阶段，编译器检测到对模板函数的实例化之后，进行一下操作

1. 先检测工程中是否存在合适的可调用的普通函数，如果存在则调用
2. 检测是否存在合适的函数模板，崔仔，编译器会根据实参的类型推演，成功之后，根据函数模板生成对应的具体函数，然后再调用
3. 没有对应的普通函数和模板函数，编译器就会报错

## 类模板

类模板的定义格式

```c++
template<class T1, class T2, ..., class Tn>
class 类模板名
{
	// 类内成员定义
};
```

### 类模板的实例化

类模板实例化和函数模板实例化不同，**类模板实例化需要再类模板名字后面跟<>，然后将实例化的类型放在<>中即可，类模板名字不是真正的类，而实例化的结果才是真正的类**

## 非类型模板参数

模板参数分 类型形参和非类型形参

**类型形参：出现在模板参数列表中，跟在`class`或者`typename`之类的参数类型名称**

**非类型形参：就是用一个常量作为类（函数）模板的一个参数，在类（函数）模板中可以当做常数来使用**

**注意**：

1. **浮点数、类对象以及字符串不能作为非类型模板参数**
2. **非类型模板参数必须在编译器就确定结果**

## 模板的特化

通常情况下，**使用模板可以实现一些与类型无关的代码，但对于一些特殊类型的可以能会得到一些错误的结果**，需要特殊处理。比如：实现一个专门用来小于比较的函数模板

```c++
// 函数模板 -- 参数匹配
template<class T>
bool Less(T left, T right)
{
    return left < right;
}
int main()
{
    cout << Less(1, 2) << endl; // 可以比较，结果正确
    Date d1(2022, 7, 7);
    Date d2(2022, 7, 8);
    cout << Less(d1, d2) << endl; // 可以比较，结果正确
    Date* p1 = &d1;
    Date* p2 = &d2;
    cout << Less(p1, p2) << endl; // 可以比较，结果错误
    return 0;
}
```

可以看到，Less绝大多数情况下是可以正常比较的，但是在特殊场景下就得到错误的结果。`p1`指向的`d1`显然小于`p2`指向的`d2`对象，但是Less内部没有比较`p1`和`p2`指向的对象内容，而是比较`p1`和`p2`指针的地址，这就无法达到预期而错误。

此时，就需要对模板进行特化。**在原模板类的基础上，针对特殊类型进行特殊化的实现方式**。模板特化，分为函数模板特化和类模板特化。

### 函数模板特化

1. 必须要有一个基础函数模板
2. 关键字`typename`后面要加一个空的`<>`
3. 函数名后面跟上一堆尖括号，括号里面是需要特化的类型
4. 函数形参表: 必须要和模板函数的基础参数类型完全相同，如果不同编译器可能会报一些奇怪的错误。

**一般情况下，如果函数模板遇到不能处理或者处理有误的类型，为了实现简单都是直接把函数给出**

### 类模板特化

#### 全特化

全特化是将模板参数列表中所有参数都确定化

```c++
template<class T1, class T2>
class Data
{
public:
	Data() { cout << "Data<T1, T2>" << endl; }
private:
	T1 _d1;
	T2 _d2;
};
template<>
class Data<int, char>
{
public:
	Data() { cout << "Data<int, char>" << endl; }
private:
	int _d1;
	char _d2;
};
void TestVector()
{
	Data<int, int> d1;
	Data<int, char> d2;
}
```

#### 偏特化

偏特化：任何针对模板参数进一步进行条件限制设计的特化版本。比如，对于一下模板类：

```c++
template<class T1, class T2>
class Data
{
public:
	Data() { cout << "Data<T1, T2>" << endl; }
private:
	T1 _d1;
	T2 _d2;
};
```

偏特化有两种表现方式

- 部分特化

  将模板参数类表中的一部分参数特化

```c++
// 将第二个参数特化为int
template <class T1>
class Data<T1, int>
{
public:
	Data() { cout << "Data<T1, int>" << endl; }
private:
	T1 _d1;
	int _d2;
};
```

- 参数更进一步的限制

偏特化并不仅仅是指特化部分参数，而是针对模板参数更进一步的条件限制所设计出来的一个特化版本。

```c++
//两个参数偏特化为指针类型
template <typename T1, typename T2>
class Data <T1*, T2*>
{
public:
	Data() { cout << "Data<T1*, T2*>" << endl; }
private:
	T1 _d1;
	T2 _d2;
};
//两个参数偏特化为引用类型
template <typename T1, typename T2>
class Data <T1&, T2&>
{
public:
	Data(const T1& d1, const T2& d2)
		: _d1(d1)
		, _d2(d2)
	{
		cout << "Data<T1&, T2&>" << endl;
	}
private:
	const T1& _d1;
	const T2& _d2;
};
```

## 模板分离编译

### 什么是分离编译

一个程序由若干源文件共同实现，而每个源文件单独编译生成的目标文件，最后将所有目标文件连接起来形成单一的可执行文件的过程成为分离编译模式

### 模板的分离编译

```c++
// a.h
template<class T>
T Add(const T& left, const T& right);
// a.cpp
template<class T>
T Add(const T& left, const T& right)
{
    return left + right;
}
// main.cpp
#include"a.h"
int main()
{
    Add(1, 2);
    Add(1.0, 2.0);
    return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/95fe3cf22a764c1c8423f188f4b8b727.png)

## 总结

**优点**

1. 模板复用了代码，节省资源，更快的迭代开发，C++的STL应运而生
2. 增强了代码的灵活性

**缺陷**

1. 模板会导致代码膨胀问题，也会导致编译时间变长
2. 出现模板编译错误时，错误信息非常凌乱，不易定位错误