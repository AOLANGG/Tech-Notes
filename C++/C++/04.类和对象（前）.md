## 面向对象和面向过程的区别

面向过程：根据业务从上到下的写代码

面向对象：将数据和函数绑定到一起，进行封装，这样能够更快速的开发程序，减少重复代码的重写过程

## 类定义的方式

- 类声明和定义全部放在类中
- 类声明在`.h`的头文件中，类型定义在`.cpp`的源文件中，注意：在源文件中定义类的时候，类名必须加类名限定符

## 封装特性

### 访问限定符

`private`：修饰的成员不能再类外访问

`protected`：主要应用子啊继承体系中，修饰的成员不能再类外被访问，但是可以被子类访问

`public`：修饰的成员可以直接在类外被访问

class定义类默认访问限定符是`private`，而struct定义的类默认访问限定符是`public`，struct之所以是`public`，是为了兼容C语言

**C++中struct和class的区别**

1. struct一般用来描述一个数据结构集合，而class是对一个对象数据的封装
2. struct中默认的访问权限是`public`，而class中默认访问权值是private的
3. 在继承关系中，struct默认是公有继承，class是私有继承
4. class关键字可以用来顶级模版参数，和typename相似，而struct不能用来定义模版参数

### 封装的概念

将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口和对象进行交互

### C++如何实现封装

1. 先通过class的方式，把对象的属性和方法包装成一个整体，更符合人们对于事务的认知
2. 通过访问限定符，选择性的将接口暴露给使用者，让对象这件可以完成交互

### `考点`

面向对象的三大特性：封装、继承、多态

什么是封装？C++如何实现封装的

## 类的作用域

类定义了一个新的作用域，类的所有成员都是再类的作用域上。在类体外定义成员，需要使用::作用域解析符，指明成员属于哪个类域

类中的成员变量可以在任意成员函数中使用，因此，成员变量可以看作是成员函数的全局变量

C++作用域中：全局作用域，函数体中局部作用域，命名空间，类域

## 类的实例化

### 概念

用类类型创建对象的过程就叫做类的实例化

类和对象的区别

- **类：**
  - 它是一个**抽象的概念**，是一种**自定义的数据类型**。
  - 它是对一类具有共同特征和行为的事物的**描述**或**模板**。
  - 它定义了这类事物的**属性**（在类中叫“成员变量”或“字段”）和**行为**（在类中叫“方法”或“函数”）。
- **对象：**
  - 它是类的一个**具体的实例**，是**真实存在的个体**。
  - 它根据类的模板，在内存中分配了具体的空间来存储属性的值。

### `考点`

1. 如何计算一个类的大小

这就是[内存对齐](https://github.com/AOLANGG/Tech-Notes/blob/main/C%2B%2B/C%E8%AF%AD%E8%A8%80/04.%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3.md)问题，和计算一个结构体的大小一样。

2. 空类的大小是多少？为什么？

空类的大小是1字节；

- **保证对象有唯一的地址**，C++标准要求每个对象在内存中必须有唯一的地址。如果空类大小为0，那么在创建对象数组的时候，所有对象都会指向相同的地址，这违反了语言规范
- **区分不同的对象**，即使是空类，也需要确保该类的不同实例在内存中是不同的

3. 什么是内存对齐？结构体是如何进行内存对齐的？

**内存对齐**就是数据在内存中的存储地址必须是某个值的整数倍，这个值通常是对齐数

- 结构体的第一个成员对齐到和结构体变量起始位置偏移量为0的地址处

- 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
  - 对齐数： 编译器默认的一个对齐数与该成员变量大小的较小值
  - VS中默认的值是8
  - Linux中gcc没有默认的对齐数，对齐数就是成员自身大小

- 结构体的大小为最大对齐数（结构器中每个成员变量都有一个对齐数，所有对齐数中最大的）的整数倍

- 如果嵌套了结构体的情况，嵌套的结构体成员对齐到自己的成员中最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体中成员的对齐数）的整数倍

4. 如果让结构体按照指定的默认对齐数进行对齐？

可以使用预编译指令来修改默认对齐数

1. 使用**`#pragma pack`**

比如设置成1字节对齐

```c
pragma pack(1)
```

2. 使用`C++11`的`alignas`

```c++
struct alignas(16) AlignedStruct {
    char a;
    int b;
    // 整个结构体按照16字节对齐
};
```



5. 如何知道结构体中某个成员相对于结构体起始位置的偏移量

**使用`offsetof`宏**



6. 什么是大小端？如何测试某台机器是大端还是小端，有没有遇到需要考虑大小端的场景？

**大端模式**：数据的高字节存储在低地址，低字节存储在高地址处

**小端模式**：数据的低字节存储在低地址，高字节存储在高地址处

```c++
#include <cstddef>
#include <iostream>


int check_sys()
{
	union
	{
		char c;
		int x;
	}un;
	un.x = 1;
	return un.c; // 1表示小端，否则表示大端
}

int main()
{
	if (check_sys())
	{
		std::cout << "小端" << std::endl;
	}
	else
	{
		std::cout << "大端" << std::endl;
	}
    return 0;
}
```

**需要考虑大小端的实际场景**

1. 网络编程

```c++
// 网络字节序是大端，主机字节序需要转换
uint32_t hostToNetwork(uint32_t hostlong) {
    if (isLittleEndian()) {
        return ((hostlong & 0xFF) << 24) | 
               ((hostlong & 0xFF00) << 8) | 
               ((hostlong & 0xFF0000) >> 8) | 
               ((hostlong & 0xFF000000) >> 24);
    }
    return hostlong;
}
```

2. 跨平台数据交换
   - 不同架构的机器之间传输二进制数据
   - 嵌入式系统和PC的数据通信

## this指针

### 概念

为了让成员函数知道操作哪个对象，C++编译器给每个非静态成员函数增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过该指针去访问的

### 特性

1. this指针的类型：`* const`，即，指针的指向不能改变
2. 只能在成员函数中使用
3. this指针其实是一个成员函数的形参，是对象调用成员函数时，将对象的地址作为实参传给this形参，所有对象中不存储this指针
4. this指针是成员函数第一个隐含的指针形参，一般情况下又编译器通过`ecx`寄存器自动传递，不需要用户传递

### `考点`

### 解释一下什么是this指针

为了让成员函数知道操作哪个对象，C++编译器给每个非静态成员函数增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过该指针去访问的

### this指针存放在哪里

- **通常存放在寄存器中**：`this`指针存放在ECX寄存器中
- **也可能在栈上**：当寄存器不够用时，编译器可能会将其压入栈中
- **不是对象的一部分**：`this`指针本身不在对象的内存布局中，它只是一个函数调用时传递的参数

## this指针有没有可能是NULL

有可能，而且访问的时候会告知未定义行为

```c++
class MyClass {
public:
    void print() {
        // 如果this为NULL，下面这行会导致崩溃
        std::cout << "Hello" << std::endl;
    }
    
    void safePrint() {
        if (this == nullptr) return; // 安全检查
        std::cout << "Hello" << std::endl;
    }
};

MyClass* obj = nullptr;
obj->print();      // 未定义行为，可能崩溃
obj->safePrint();  // 安全，有null检查
```

- 通过空指针调用成员函数在语法是上合法的
- 但只要在函数内访问成员变量或者调用虚函数，就会导致程序崩溃

## 常见的调用约定有哪些

调用约定规定了函数调用时参数传递、栈清理等规则：

1. **__cdecl**（C Declaration）
   - C/C++默认约定
   - 参数从右向左压栈
   - 调用者清理栈
   - 支持可变参数
2. **__stdcall**（Standard Call）
   - Windows API常用
   - 参数从右向左压栈
   - 被调用者清理栈
   - 不支持可变参数
3. **__fastcall**
   - 前两个参数通过ECX、EDX寄存器传递
   - 其余参数从右向左压栈
   - 性能较好
4. **__thiscall**
   - C++成员函数专用
   - `this`指针通过ECX寄存器传递
   - 参数从右向左压栈
5. **__vectorcall**
   - 支持SIMD寄存器传递参数
   - 性能优化
