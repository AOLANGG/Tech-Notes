## C/C++内存分布

我们先来看下面一段代码的相关的问题

```c++
int globalVar = 1;
static int staticGlobalVar = 1;
void Test()
{
 static int staticVar = 1;
 int localVar = 1;
 int num1[10] = { 1, 2, 3, 4 };
 char char2[] = "abcd";
 const char* pChar3 = "abcd";
 int* ptr1 = (int*)malloc(sizeof(int) * 4);
 int* ptr2 = (int*)calloc(4, sizeof(int));
 int* ptr3 = (int*)realloc(ptr2, sizeof(int) * 4);
 free(ptr1);
 free(ptr3);
}

1. 选择题：
   选项: A.栈  B.堆  C.数据段(静态区)  D.代码段(常量区)
   globalVar在哪里？____   staticGlobalVar在哪里？____
   staticVar在哪里？____   localVar在哪里？____
   num1 在哪里？____
  
   char2在哪里？____   *char2在哪里？___
   pChar3在哪里？____      *pChar3在哪里？____
   ptr1在哪里？____        *ptr1在哪里？____
2. 填空题：
   sizeof(num1) = ____;
   sizeof(char2) = ____;      strlen(char2) = ____;
   sizeof(pChar3) = ____;     strlen(pChar3) = ____;
   sizeof(ptr1) = ____;
3. sizeof 和 strlen 区别？

```

**选择题**

- `globalVar`、`staticGlobalVar`、`staticVar`都是静态存储期的变量，储存在数据段
- `localVar`、`num1`、`num2`、`char2`、`pChar3`、`ptr1`都是局部变量，都储存在栈上

- `*char2`是数组首元素，数组本身在栈上，所以也在栈上
- `*pChar3`指向字符串常量"abcd"，字符串常量存储在代码段(常量区)
- `*ptr1`指向malloc分配的内存，在堆上

**填空题**

```c++
sizeof(num1) = 40;           // 10个int × 4字节 = 40
sizeof(char2) = 5;           // "abcd"包含\0，共5个字符
strlen(char2) = 4;           // 不包含\0的字符个数
sizeof(pChar3) = 4/8;        // 指针大小，32位系统4字节，64位系统8字节
strlen(pChar3) = 4;          // 字符串"abcd"长度
sizeof(ptr1) = 4/8;          // 指针大小，32位系统4字节，64位系统8字节
```

`sizeof`和`strlen`的区别

`sizeof`是C语言的运算符，计算某个类型或者变量所占据的内存的字节数，在编译的时候确定结果，对应整个数组，计算整个数组的大小，包括字符串末尾的`\0`

`strlen`是C语言的库函数，计算字符串的实际长度，在运行的时候计算结果，要求字符串末尾必须有`\0`

![img](https://i-blog.csdnimg.cn/direct/49c1a82b00454708a9bb32620de8b722.png)

1. .**栈**又叫做堆栈，非静态局部变量/函数参数/返回值，栈是向下增长的
2. **内存映射段**是高效的IO映射方式，用于状态一个共享的动态内存库。用户可使用系统接口创建共享内存，叫做进程间通信。
3. **堆**用于程序运行时动态内存分配，堆事向上增长的。
4. **数据段**-储存全局数据和静态数据
5. **代码段**-可执行的代码/只读常量

## 面试题

1. malloc/calloc/realloc的区别

`malloc`函数可以从堆中申请一块大小由用户指定的内存，不会进行初始化，返回值为`void*`，这个过程可能会失败，所以在使用前要进行判空；如果申请出来之后，发现内存大小满足不了需求，或者远大于需求造成了浪费，这时候就使用`realloc`函数，来更改内存的大小。至于`calloc`函数和`malloc`函数基本一致，在`malloc`函数的基础上，自动初始化成0。

2. malloc函数的实现原理

**malloc底层实现**：当开辟的空间小于 128K 时，调用 brk（）函数；当开辟的空间大于 128K 时，调用mmap（）。malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲的内存块。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址。

## C++内存管理方式

### `new/delete`操作类型

```c++
void Test()
{
    // 动态申请一个int类型的空间
    int* ptr4 = new int;
    // 动态申请一个int类型的空间并初始化为10
    int* ptr5 = new int(10);
    // 动态申请10个int类型的空间
    int* ptr6 = new int[3];
    delete ptr4;
    delete ptr5;
    delete[] ptr6;
}
```

**注意：申请和释放单个元素的空间，使用new和delete操作符，申请和释放连续的空间，使用new[]和delete[]，要匹配适应**

**在申请自定义类型的空间的时候，`new`会调用构造函数，`delete`会调用析构函数，而`malloc`和`free`不会

## operator new 和 operator delete函数

**`new`**和**`delete`**使用户进行**动态内存申请和释放的操作符**，**operator new** 和 **operator delete**通过系统提供的**全局函数**，**new在底层调用operator new**全局函数申请空间，**delete在底层通过operator delete**全局函数来释放空间

**operator new实际上也是通过malloc来申请空间**，如果`malloc`申请空间成功就直接返回，否则执行用户提供的空间不足应对措施，如果用户提供该措施就继续申请，否则就抛异常。**operator delete最终是通过free来释放空间的**

## new和delete的实现原理

### 内置类型

如果申请的是内置类型的空间，new和malloc，delete和free基本类似，不同的地方是：new/delete申请和释放的是单个元素的空间，new[]和delete[]申请的是连续空间，而且new在申请空间失败时会抛异常，malloc会返回NULL。

### 自定义类型

- **new的原理**
  1. 调用operator new函数申请空间
  2. 在申请空间上执行构造函数，完成对象的构造
- **delete的原理**
  1. 在空间上执行析构函数，完成对象中资源的清理工作
  2. 调用operator delete函数释放对象的空间
- **new T[N]的原理**
  1. 调用operator new[]函数，在operator new[]中实际调用operator new函数完成N个对象空间的申请
  2. 在申请的空间上执行N次构造函数
- **delete[]的原理**
  1. 在释放的对象空间上执行N次析构函数，完成N个对象资源的清理
  2. 调用operator delete[]释放空间，实际在operator delete[]中调用operator delete来释放空间

## 常见面试题

### malloc/free、和new/delete的区别

malloc/free、和new/delete的共同点是：都从堆上申请空间，都需要用户手动释放

不通电：

1. `malloc/free`是函数，`new/delete`是操作符

2. `malloc`申请的空间不会进行初始化，`new`可以进行初始化
3. `malloc`申请空间，需要手动计算空间大小并传递，`new`只需要在后面跟上空间的类型即可
4. `malloc`的返回值是`void*`，在使用前必须强转，`new`不需要，因为`new`后面跟的是空间的类型
5. `malloc`申请空间失败，返回的是`NULL`，所以使用的时候必须判空，`new`不需要，但是`new`需要捕获异常
6. 申请自定义类型对象的时候，`malloc/free`只会开辟空间，不会调用构造函数和析构函数，而`new`在申请空间之后会调用构造函数完成对象的初始化，`delete`在释放空间前会调用析构函数万恒空间中资源的清理

### 什么是内存泄漏？内存泄漏的危害

**内存泄漏**是指因为疏忽或者错误造成程序未能释放已经不再使用的内存空间的情况。内存泄漏并不是物理上的小事，而是应用程序分配内存后，因为设计错误，是去了对该段内存的控制，造成了内存的浪费。

**危害**：长期运行的程序出现内存泄漏，响应很大，比如操作系统、后台服务，会导致响应越来越慢，最终卡死。

### 如何避免内存泄漏

1. 工程前期良好的设计贵方，养成良好的编码规范，申请的内存空间记着一定去释放
2. 采用RAII思想或者智能指针来管理资源
3. 有些公司内部规范使用内部实现的私有内存管理库。这套库自带内存泄漏检测的功能选项
4. 出问题了使用内存泄漏工具检测