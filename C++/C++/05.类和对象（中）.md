# 六个默认的成员函数

构造函数、析构函数、拷贝构造函数、赋值运算符重载，取地址操作符重载，const成员函数

## 构造函数

### 概念

构造函数是一个特殊的成员函数，名字和类名相同，创建类类型对象的时候由编译器自动调用，保证每个数据成员都有一个合适的初始值，并且在对象的声明周期中只调用一次

### 特性

1. 函数名和类名相同
2. 没有返回值
3. 对象实例化的时候编译器会自动调用对应的构造函数
4. 构造函数具有初始哈鱼列表
   - 以一个冒号开始，接着用逗号分隔的数据成员列表，每个成员变量后面跟一个放在括号中的初始值或者表达式
   - 注意：
     - 初始化列表是真正的对成员变量进行初始化，而构造函数体中是赋值
     - 初始化列表的位置只能初始化非静态成员变量
     - 每个成员变量只能在初始化列表中出现一次（初始化只能初始化一次）
     - 类中包含const类型的成员变量，引用类型的成员变量，类类型的成员变量，必须放在初始化列表位置进行初始化
     - 进行使用初始化列表进行初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先试用初始化列表初始化
     - 成员变量在类中声明次序就是其在初始化中的初始化顺序，和初始化列表中的先后次序无关
5. 构造函数可以重载
6. 如果类中没有显示定义构造函数，则编译器会自动生成一个午餐的默认构造函数，一旦用户显示定义编译器将不在生成
7. 无参的构造函数和全缺省的构造函数都成为默认构造函数，并且默认构造函数只能有一个。注意：无参构造函数、全缺省构造函数，编译器默认生成的构造函数，都是默认成员函数
8. 构造函数不能用const修饰
9. 构造函数不能是虚函数

### 应用场景

创建对象的时候，由编译器自动调用，并且在对象生命周期中只调用一次

### 关于编译器生成的默认构造函数

1. 用户没有显示定义任何构造函数的时候，编译器才会生成
2. 编译器生成的构造函数一定是无参的
3. 编译器生成的构造函数是由具体的事情要做的，比如调用成员变量中自定义类型的默认构造函数

## 拷贝构造函数

### 概念

只有单个形参，该形参是本类类型对象的引用（一般常用const修饰），在用已存在的类类型对象创建新对象时，由编译器自动调用

### 特性

1. 构造函数是一种重载形式，因此构造函数的特性，拷贝构造函数都满足
2. 拷贝构造函数的参数只有一个且必须使用引用传参，使用船只方式会引发无穷递归调用
3. 若未显示定义，系统生成默认的拷贝构造函数。默认的拷贝构造函数对象按内存存储按字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝

### 应用场景

当使用已经存在的类类型对象构造新对象的时候，或者以对象作为参数或者返回值类型的时，编译器会自动调用拷贝构造函数

## 关于编译器生成的拷贝构造函数

1. 用户没有显示定义，编译器会生成一个默认的拷贝构造函数
2. 编译器生成的拷贝构造函数都是浅拷贝，即：将对象中的内容原封不动的拷贝到新对象中。如果源对象涉及到资源管理，那么新对象和原对象共用了同一份资源，在进行复制或者析构的时候会造成内存泄漏或者程序崩溃
3. 如果类中涉及到了资源管理，用户必须显示提供拷贝构造函数，一般是按照深拷贝的方式提供，即：在拷贝对象内容的时候，发现对象中管理资源了，那么新对象也要重新申请一份空间

## 析构函数

### 概念

析构函数：与构造函数功能相反，析构函数不是完成对对象本身的销毁，局部对象销毁工作是由编译器完成的。而对象在销毁时会自动调用析构函数，完成对象中资源的清理工作。

### 特性

1. 析构函数函数名是在类名浅加上字符~
2. 无参数无返回值
3. 一个类有且只有一个析构函数。若未显式定义，系统会自动生成默认的析构函数，析构函数不能重载
4. 对象声明周期结束的时候，C++编译系统系统自动调用析构函数
5. 用户没有西那时候定义的时候，编译器会自动生成一个
6. 基类的析构函数最好设置成虚函数

### 关于编译器生成的默认析构函数

1. 如果用户没有显示提供，编译器会自动提供一份，做一些力所能及的事情
2. 如果对象中涉及到了资源管理，用户必须要显示给出析构函数，否则会造成内存泄漏

## 赋值运算符重载

### 运算符重载

为了提高代码的可行性，C++通过`operator`关键字来支持运算符重载，运算符重载是针对自定义类型的

写法：返回值类型 operator 重载运算法（参数列表）

注意事项：

1. 不能通过连接其他运算符类创建新的操作符，比如：operator@
2. 重载操作符必须有一个类类型或者枚举类型的操作数
3. 用于内置类型的操作数，其含义不能改变，例如：内置的整型++，不能改变它的含义
4. 作为类成员的重载函数，其形参看起来比操作数目少1，成员函数的操作符有一个默认的形参this，先定位第一个形参

5. `.* :: sizeof ?: .`这五类运算符是不能够被重载的，这个在笔试题中会经常性的出现

### 赋值运算符重载

`T& operator=(const T&elem)`

#### 注意

1. 参数类型：为什么要加&，为什么要加const？

**加&**是为了避免无限递归，在传递参数的时候胡里调用拷贝构造函数，而拷贝构造函数内部可能又会调用赋值运算符，导致无效递归；不仅如此，还能提高效率，传递引用避免了不必要的对象拷贝，特别是对于大型对象，这能显著提升性能

**加const**

- **保护原对象**：确保在赋值过程中不会以外修改原对象
- **支持常量对象**：允许从const对象进行赋值操作
- **语义正确**：赋值操作的右值通常不应该被修改



2. 返回值类型：为什么要按照&方式返回

返回**`T&`**的主要原因是为了支持**链式复制**

3. 是否检测自己给自己赋值

**必须检测自赋值**

4. 为什么要返回*this，而不是返回参数

返回`*this`而不是参数，原因是

- 赋值操作应该改变左操作数，返回左操作数更加符合直觉
- 内置类型的赋值操作（`a=b`）返回的是`a`（左值），而不是`b`

### 调用场景

用已经存在对象给另一个对象赋值时会调用赋值运算符重载

### 默认赋值运算符重载

1. 一个类没有显示定义赋值运算符重载，编译器会生成一个默认的赋值运算符重载
2. 编译器生成的默认赋值运算符重载是按照浅拷贝的方式生成的
3. 如果类中涉及到资源管理的时候，用户必须显示提供赋值运算符重载，否则可能会造成内存泄漏或运行时崩溃，用户一般是按照深拷贝的方式提供的

## const成员

### 普通变量

表示该变量是一个常量，并且在编译阶段会进行参数类型检测以及替换，比宏常量更加安全，可以取代宏常量

### const修饰类成员

- 修饰成员变量
  - 该成员变量不能再成员函数中被修改
  - 必须在类初始化列表的位置完成初始化工作
- 修饰成员函数
  - 实际上修饰的是函数隐藏的`this`指针
  - 在该类中不能修改对象中的任何成员变量，除非该变量使用`mutable`修饰
  - 该成员函数中：只能调用`const`成员函数，不能调用普通成员函数

### `考点`

1. `const`关键字的作用

参考上面

2. `const`修饰的常量和宏常量的区别

`const`用来定义常量，而`define`用来定义哄，而宏也可以用来定义常量，都用于定义常量，它们的区别有：

- `const`生效于编译的阶段；`define`生效与预处理阶段
- `const`定义的常量，在C语言中是存储在内存中的，需要有额外的内存空间；`define`定义的常量，运行时是直接的操作数，不会放在内存中
- `const`定义的常量都有类型的；`define`定义的常量没有类型，自然也没有类型检查

3. `const`成员和普通成员函数的区别

- **修改权限**：`const`成员函数内部**不能修改类的非静态成员变量**，也不能调用非`const`成员
- **调用限制**：`const`对象**只能调用const成员对象**；非`const`对象既可以调用`const`成员函数，也可以调用普通成员函数
- **this指针**：`const`成员函数中，`this`指针是`const 类名*const`类型（指向常量的常量指针），限制对指向对象的修改