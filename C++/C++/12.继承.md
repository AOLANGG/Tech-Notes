## 继承的概念及定义

### 概念

**继承**机制是面向对象程序设计**使代码可以服用**的最重要的手段，它允许程序员在**保持原有类特性的基础上进行扩展**，增加功能，这样产生新的类，叫做派生类。继承**呈现了面向对象设计的层次结构**，体现了由简单到复杂的认知过程。**继承是类设计层次的复用**

```c++
class Person
{
public:
	void print()
	{
		cout << "name:" << _name << endl;
		cout << "age:" << _age << endl;
	}

protected:
	string _name = "peter";
	int _age = 18;
};
class Student :public Person
{
protected:
	int _stuid;// 学号
};
class Teacher :public Person
{
protected:
	int _jobid;// 工号
};

int main()
{
	Student s;
	Teacher t;
	s.print();
	t.print();
	return 0;
}
```

### 继承定义

![img](https://i-blog.csdnimg.cn/direct/ccc866d0e4cf48b0a626c472632f184a.png)

继承关系

![img](https://i-blog.csdnimg.cn/direct/d7b20fdd23ed450e90df6bbd73223a08.png)

| 基类成员类型   | public 继承             | protected 继承          | private 继承          |
| -------------- | ----------------------- | ----------------------- | --------------------- |
| public 成员    | 派生类的 public 成员    | 派生类的 protected 成员 | 派生类的 private 成员 |
| protected 成员 | 派生类的 protected 成员 | 派生类的 protected 成员 | 派生类的 private 成员 |
| private 成员   | 在派生类中不可见        | 在派生类中不可见        | 在派生类中不可见      |

**总结**：

1. 基类`private`成员在派生类中无论以什么形式都是不可见的。这里的**不可见是指基类的私有成员还是继承到了派生类对象中，但是语法上限制派生类对象不管在类里面还是在类外面都不能去访问它**
2. 基类`private`成员在派生类中是不能访问的，如果基类成员不想在类外直接被访问，但是需要在派生类中能访问，就定义成`protected`。可以看出**保护成员限定符是因为继承才出现的**
3. 实际上面的表格我们进行一下总结会发现，基类的私有成员在子类都是不可见。基类的其他
   成员在子类的访问方式 == Min(成员在基类的访问限定符，继承方式)，public > protected>private
4. 使用关键字`class`时默认的继承方式是`private`，使用`struct`时默认的继承方式是`public`，**不过最好显示的写出继承方式**
5. **在实际运用中一般使用的都是`public`继承，几乎很少使用`protected/private`继承，也不提倡使用，因为它们继承下来的成员只能再派生类里面使用。

## 基类和派生类对象赋值转换

- **派生类对象**可以付给**基类的对象/基类的指针/基类的引用**。这里有个形象的说法叫做切片或者切割——把派生类中父类那部分切出来赋值过去
- 基类对象不能赋值给派生类对象
- 基类的指针或者引用可以通过强制类型转换给派生类的指针或者引用。但是必须是积累的指针是指向派生类对象才是安全的。这里基类如果是多态类型，可以使用RTTI(Run-Time Type Information)的dynamic_cast 来进行识别后进行安全转换

![img](https://i-blog.csdnimg.cn/direct/f2dd3387e3144e38a07b70b183e72140.png)

```c++
class Person
{
protected:
    string _name;
    string _sex;
    string _age;
};
class Student : public Person
{
public:
    int _id;
};
void Test()
{
    Student sobj;
    // 1. 子类对象可以赋值给父类对象/指针/引用
    Person pobj = sobj;
    Person *pp = &sobj;
    Person &rp = sobj;

    // 2. 基类对象不能赋值给派生类对象
    // sobj = pobj;

    // 3. 基类的指针可以通过强制类型转换赋值给派生类的指针
    pp = &sobj;
    Student *ps1 = (Student *)pp;// 这种情况转换时可以的
    ps1->_id = 10;

    pp = &pobj;
    Student *ps2 = (Student *)pp;// 这种情况转换虽然可以，但是存在越界访问的问题
    ps2->_id = 10;
}
int main()
{
    Test();
    return 0;
}
```

## 继承中的作用域

1. 在继承体系中**基类**和**派生类**都有独立的作用域
2. 子类和父类中有同名成员，**子类成员将屏蔽父类对同名成员的之间访问，这种情况也叫做重定义**（在子类成员函数中，可以使用**基类::基类成员 显示访问**）
3. 需要注意的是如果是成员函数的隐藏，只需要函数名相同就构成隐藏
4. 在实际中，继承体系里最好不要定义同名的成员

```c++
class Person
{
protected:
    string _name="小李子";// 姓名
    int _num = 111;// 身份证号
};
class Student : public Person
{
public:
    void Print()
    {
        cout<<"姓名："<<_name<<endl;
        cout<<"身份证号："<<_num<<endl;
        cout<<"学号："<<this->_num<<endl;
    }
protected:
    int _num = 999;
};
void Test()
{
    Student s;
    s.Print();
}
```

```c++
// B中的func和A中的func不是构成重载，因为不是在同一个作用域中
// B中的func和A中的func构造隐藏，成员函数妈祖函数名相同就构成隐藏
class A
{
public:
    void func()
    {
        cout<<"func()"<<endl;
    }
};
class B:public A
{
public:
    void func(int i)
    {
        A::func();
        cout<<"func(i)"<<endl;
    }
};
void Test()
{
    B b;
    b.func(1);
}
```

## 派生类的默认成员函数

6个默认成员函数，**默认**的意思就是指我们不写，编译器会自动给我们生成一个，那么在派生类中，这几个成员函数是如何生成的？

1. 派生类构造函数必须调用基类的构造函数初始化基类的把一部分成员。如果基类没有默认构造函数，那必须在派生类的初始化列表中显式调用。
2. 派生类的拷贝构造函数必须调用基类的拷贝构造函数来实现基类的拷贝初始化
3. 派生类的`operator=`必须调用基类的`operator=`来实现基类的复制
4. 派生类的析构函数在调用完之后自动调用基类的析构函数清理基类成员。因为这样子才能保证派生类对象先清理派生类对象，在清理基类对象
5. 派生类对象初始化先调用基类构造在调用派生类构造
6. 派生类对象析构先调用派生类析构在调用基类析构
7. 因为后序一些场景析构函数需要构成重写，重写的条件之一就是函数名相同（）。那么编译器会对析构函数名进行特殊处理，处理成`destrutor()`，所以父类析构函数不加`virtual`的情况下，子类构造函数和父类构造函数构成隐藏的关系

![img](https://i-blog.csdnimg.cn/direct/404489f43b5042088aa2b53207cd2312.png)

```c++
class Person
{
public:
    // 默认构造函数
    Person(const char *name = "peter") : _name(name)
    {
    }
    // 拷贝构造函数
    Person(const Person &p) : _name(p._name)
    {
    }
    // 赋值重载函数
    Person &operator=(const Person &p)
    {
        _name = p._name;
        return *this;
    }
    ~Person()
    {
        cout << "~Person()" << endl;
    }

private:
    string _name;
};
class Student : public Person
{
public:
    Student() = default;
    Student(const char *name, int num)
        : Person(name), _num(num)
    {
        cout << "Student()" << endl;
    }
    Student(const Student &s)
        : Person(s), _num(s._num)
    {
        cout << "Student(const Student& s)" << endl;
    }
    Student &operator=(const Student &s)
    {
        cout << "Student& operator= (const Student& s)" << endl;
        if (this != &s)
        {
            Person::operator=(s);
            _num = s._num;
        }
        return *this;
    }
    ~Student()
    {
        cout << "~Student()" << endl;
    }

protected:
    int _num; // 学号
};
void Test()
{
    Student s1("jack", 18);
    Student s2(s1);
    Student s3;
    s3 = s1;
}
```

## 继承和友元

**友元不能继承**，也就是说基类的友元不能访问派生类的私有或保护成员

```c++
class Student;
class Person
{
public:
    friend void Display(const Person &p, const Student &s);

protected:
    string _name="Mike"; // 姓名
};
class Student : public Person
{
protected:
    int _stuNum; // 学号
};
void Display(const Person &p, const Student &s)
{
    cout << p._name << endl;
    // 这一步会编译错误，基类的友元不能访问派生类的保护成员
    // cout << s._stuNum << endl;
}
void Test()
{
    Person p;
    Student s;
    Display(p,s);
}
```

## 继承和静态函数

**基类定义了static静态成员，则整个继承体系里面只有一个这样的成员**。无论有多少个子类，静态成员是独一份的。

```c++
class Person
{
public:
    Person()
    {
        ++count;
    }
    static int count;
protected:
    string _name;

};
int Person::count = 0;
class Student:public Person
{
protected :
    int _stuNum ; // 学号
};
class Graduate : public Student
{
protected :
    string _seminarCourse ; // 研究科目
};
void Test()
{
    Student s1 ;
    Student s2 ;
    Student s3 ;
    Graduate s4 ;
    cout <<" 人数 :"<< Person::count << endl;
    Student::count = 0;
    cout <<" 人数 :"<< Person::count << endl;
    /*
    人数 :4
    人数 :0
    */
}
```

## 复杂的菱形继承及菱形虚拟继承

**单继承：一个子类只有直接父类则成这个继承关系为单继承**

![img](https://i-blog.csdnimg.cn/direct/73b18114655d45ba9a68190d1fa088f1.png)

**多继承：一个子类有两个或两个以上父类则称这个继承关系为多继承**

![img](https://i-blog.csdnimg.cn/direct/00bbfdfbf58c4a498d2cd40c5e398ad4.png)

**菱形继承：菱形继承是多继承的一种特殊情况**

![img](https://i-blog.csdnimg.cn/direct/afa8f5469ff44ebfbfdd9abb27ad549f.png)

菱形继承的问题：从下面的对象成员模型沟槽，可以看出菱形继承有数据冗余和二义性的问题，在Assitant的对象中，Person成员会有两份

![img](https://i-blog.csdnimg.cn/direct/24c5a1ecba364e2e8df805b9fb08c7e2.png)

```c++
class Person
{
public:
    string _name;// 姓名

};
class Student:public Person
{
protected:
    int _num;// 学号
};
class Teacher:public Person
{
protected:
    int _id; // 职工编号
};
class Assistant:public Student,public Teacher
{
protected:
    string _majorCourse; // 主修课程
};
void Test()
{
    Assistant a;
    // 这样会有二义性，无法明确知道要访问的是哪一个
    // a._name = "peter";
    a.Student::_name = "xxx";
    a.Teacher::_name = "yyy";
}
```

虚拟继承可以解决菱形继承中的二义性和数据冗余的问题，上面的继承关系，在Student和Teacher的继承Person时使用虚拟继承，即可解决问题。需要注意的是，虚拟继承不要在其他地方使用。

```c++
class Person
{
public:
    string _name;// 姓名

};
class Student: virtual public Person
{
protected:
    int _num;// 学号
};
class Teacher: virtual public Person
{
protected:
    int _id; // 职工编号
};
class Assistant:public Student,public Teacher
{
protected:
    string _majorCourse; // 主修课程
};
void Test()
{
    Assistant a;
    // 这样会有二义性，无法明确知道要访问的是哪一个
    a._name = "peter";
    cout<<a._name<<endl;//peter
}
```

虚拟继承解决了数据冗余和二义性的原理

为了研究虚拟继承原理，我们给出了一个简化的菱形继承体系，在借助内存窗口观察对象成员的模型

```c++
class A
{
public:
	int _a;
};
 class B : public A
{
public:
	int _b;
};
 class C : public A
{
public:
	int _c;
};
class D : public B, public C
{
public:
	int _d;
};
int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;
	return 0;
}
```

下图是菱形继承的内存对象成员模型：这里可以看到数据冗余

![img](https://i-blog.csdnimg.cn/direct/896ea925e3f34d358b212a530c4b19f5.png)

下面是菱形虚拟继承的额内存对象成员模型：这里可以分析出D对象中将A放到了对象组成的最小面，这个A同时属于B和C，那么B和C如何去找到公共的A呢？**这里是通过B和C的两个指针，指向的一张表。这两个指针叫虚基表指针*，这两个表叫虚基表。虚基表中存的偏移量。通过偏移量可以找到下面的A**

![img](https://i-blog.csdnimg.cn/direct/8c287f42f8f34bbc8cfc9630db04814b.png)

![img](https://i-blog.csdnimg.cn/direct/5a61ae351fff406f9305feb4abc79fbd.png)

## 继承的总结和反思

1. **C++语法复杂，多继承就是一个体现**。有了多继承，就必然存在菱形继承，有了菱形继承，就有菱形虚拟继承，底层实现很复杂。所以不建议设计多继承，更不要设计菱形继承。
2. 多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。
3. **继承和组合**
   - `public`继承是一种**`is-a`**的关系，也就是每个派生类对象中都是一个基类对象
   - 组合是一个**`has-a`**的关系。假设B组合了A，每个B对象中都有一个A对象
   - 优先使用对象组合，而不是对象继承
   - 继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见 继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高
   - 对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。
   - 实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合

```c++
class Car {
protected:
	string _colour = "白色"; // 颜色
	string _num = "陕ABIT00"; // 车牌号
};
class BMW : public Car {
public:
	void Drive() { cout << "好开-操控" << endl; }
};
class Benz : public Car {
public:
	void Drive() { cout << "好坐-舒适" << endl; }
};
// Tire和Car构成has-a的关系
class Tire {
protected:
	string _brand = "Michelin"; // 品牌
	size_t _size = 17; // 尺寸
};
class Car {
protected:
	string _colour = "白色"; // 颜色
	string _num = "陕ABIT00"; // 车牌号
	Tire _t; // 轮胎
};
```

## 常见面试题

1. 什么是菱形继承？菱形继承的问题是什么？

菱形继承是多继承的一种特殊情况，举个例子，B、C继承自A，D又同时继承B、C，这就是菱形继承

2. 什么是菱形虚拟继承？如何解决数据冗余和二义性的

菱形虚拟继承就是在上述例子中，B、C使用virtual继承，这样B、C类中原来存放基类A的部分就会变成一个虚基表指针，指向一个虚基表，虚基表中存的是到达A基类的偏移量

3. 继承和组合的区别？什么时候用继承？什么时候用组合？

继承是一种**`is-a`**的关系，也就是每个派生类对象中都是一个基类对象；组合是一个**`has-a`**的关系。假设B组合了A，每个B对象中都有一个A对象。在实际开发中，**优先用组合降低耦合**，仅在 “is-a” 关系明确且需要多态时用继承
