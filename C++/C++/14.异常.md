## 异常概念

异常是一种处理错误的方式，**当一个函数发现自己无法处理的错误的时候就可以抛出异常，让函数直接或间接的调用者处理这个错误**

- **`throw`**：当问题出现时，程序会抛出一个异常。这是通过使用**`throw`**来完成的
- **`catch`**：在您想要处理问题的地方，通过异常处理程序捕获异常，**`catch`**关键字用于捕获异常，可以有多个**`catch`**进行捕获
- **`try`**：`try`块中的代码标识将被激活的特定异常，它后面通常跟着一个或多个`catch`块

## 异常的使用

### 异常的抛出和捕获

**异常的抛出和匹配原则**

1. 异常是通过**抛出对象而引发**的，该**对象的类型**决定了应该激活哪个`catch`的处理代码
2. 被**选中的处理代码**是调用链中**与该对象类型匹配且离抛出异常位置最近**的那一个
3. 抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁
4. `catch`可以捕获任意类型的异常，问题是不知道异常错误是什么
5. 实际中抛出和捕获的匹配原则有个例外，并不都是类型完全匹配，**可以抛出的派生类对象，用基类捕获，这个非常实用**

**在函数调用链中异常栈展开匹配原则**

1. 首先**检查`throw`本身是否在`try`块内部，如果是在查找匹配的`catch`语句**。如果右匹配的，则调到`catch`的地方进行处理。
2. 没有匹配的`catch`则退出当前函数栈，继续调用函数的栈进行查找匹配的`catch`
3. **如果到达`main`函数的栈，依旧没有匹配，则终止程序**。上述这个沿着调用链查找匹配的catch子句的过程称为栈展开。所以实际中我们最后都要加一个catch(...)捕获任意类型的异常，否则当有异常没捕获，程序就会直接终止。
4. 找到匹配的`catch`子句并处理后，会继续沿着`catch`子句后面继续执行

```c++
double Division(int a, int b)
{
	if (b == 0)
		throw "Division by zero condition";
	else
		return 1.0 * a / b;
}
void Func()
{
	int len, time;
	cin >> len >> time;
	cout << Division(len, time) << endl;
}

int main()
{
	try {
		Func();
	}
	catch (const char* errMsg) {
		cout << errMsg << endl;
	}
	catch (...) {
		cout << "unkown exception" << endl;
	}
	return 0;
}
```

### 异常的重新抛出

有时候单个的`catch`不能完全处理一个异常，在进行一些校正处理以后，希望再交给更外层的调用链函数来处理，`catch`则可以通过重新抛出异常传递给更上层的函数进行处理。

```c++
double Division(int a, int b)
{
	if (b == 0)
		throw "Division by zero condition";
	else
		return 1.0 * a / b;
}
void Func()
{
	// 这里可以看到如果发生除0错误抛出异常，另外下面的array没有得到释放。
	// 所以这里捕获异常后并不处理异常，异常还是交给外面处理，这里捕获了再
	// 重新抛出去。
	int* array = new int[10];
	try {
		int len, time;
		cin >> len >> time;
		cout << Division(len, time) << endl;
	}
	catch (...)
	{
		cout << "delete []" << array << endl;
		delete[] array;
		throw;
	}
	// ...
	cout << "delete []" << array << endl;
	delete[] array;
}

int main()
{
	try {
		Func();
	}
	catch (const char* errMsg) {
		cout << errMsg << endl;
	}
	return 0;
}
```

#### 异常安全

- **构造函数完成对象的构造和初始化，最好不要再构造函数中抛出异常**，否则可能导致对象不完整，或者没有完全初始化
- **析构函数主要完成资源的清理，最好不要在析构函数中抛出异常**，苟泽可能导致资源泄露
-  C++中异常经常会导致资源泄露的问题，比如`new`和`delete`中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁，C++中经常使用RAII来解决这个问题

### 异常规范

1. 异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些。可以在函数的后面接`throw（类型）`，列出这个函数可能抛掷的所有异常类型
2. 函数的后面接`throw`，表示函数不抛异常
3. 若无异常接口声明，则此函数可以抛掷任何类型的异常

```c++
// 这里表示这个函数会抛出A/B/C/D中的某种类型的异常
void fun() throw(A，B，C，D);
// 这里表示这个函数只会抛出bad_alloc的异常
void* operator new (std::size_t size) throw (std::bad_alloc);
// 这里表示这个函数不会抛出异常
void* operator delete (std::size_t size, void* ptr) throw();
// C++11 中新增的noexcept，表示不会抛异常
thread() noexcept;
thread (thread&& x) noexcept;
```

## 自定义类型异常体系

```c++
// 服务器开发中通常使用的异常继承体系
class Exception
{
public:
	Exception(const string& errmsg, int id)
		:_errmsg(errmsg)
		, _id(id)
	{}
	virtual string what() const
	{
		return _errmsg;
	}
protected:
	string _errmsg;
	int _id;
};
class SqlException : public Exception
{
public:
	SqlException(const string& errmsg, int id, const string& sql)
		:Exception(errmsg, id)
		, _sql(sql)
	{}
	virtual string what() const
	{
		string str = "SqlException:";
		str += _errmsg;
		str += "->";
		str += _sql;
		return str;
	}
private:
	const string _sql;
};
class CacheException : public Exception
{
public:
	CacheException(const string& errmsg, int id)
		:Exception(errmsg, id)
	{}
	virtual string what() const
	{
		string str = "CacheException:";
		str += _errmsg;
		return str;
	}
};
class HttpServerException : public Exception
{
public:
	HttpServerException(const string& errmsg, int id, const string& type)
		:Exception(errmsg, id)
		, _type(type)
	{}
	virtual string what() const
	{
		string str = "HttpServerException:";
		str += _type;
		str += ":";
		str += _errmsg;
		return str;
	}
private:
	const string _type;
};
void SQLMgr()
{
	srand(time(0));
	if (rand() % 7 == 0)
	{
		throw SqlException("权限不足", 100, "select * from name = '张三'");
	}
	//throw "xxxxxx";
}
void CacheMgr()
{
	srand(time(0));
	if (rand() % 5 == 0)
	{
		throw CacheException("权限不足", 100);
	}
	else if (rand() % 6 == 0)
	{
		throw CacheException("数据不存在", 101);
	}
	SQLMgr();
}
void HttpServer()
{
	// ...
	srand(time(0));
	if (rand() % 3 == 0)
	{
		throw HttpServerException("请求资源不存在", 100, "get");
	}
	else if (rand() % 4 == 0)
	{
		throw HttpServerException("权限不足", 101, "post");
	}
	CacheMgr();
}
int main()
{
	while (1)
	{
		this_thread::sleep_for(chrono::seconds(1));
		try {
			HttpServer();
		}
		catch (const Exception& e) // 这里捕获父类对象就可以
		{
			// 多态
			cout << e.what() << endl;
		}
		catch (...)
		{
			cout << "Unkown Exception" << endl;
		}
	}
	return 0;
}
```

## C++标准库的异常体系

![img](https://i-blog.csdnimg.cn/direct/ec47856f49b249efad71a8de9bd1b7e4.png)

![img](https://i-blog.csdnimg.cn/direct/287477b8989c423c822af512a6715c3a.png)

## 异常的优缺点

**C++异常的优点**

1. 异常对象定义好了，相比错误码的方式可以清晰准确的展示出错误的各种信息，甚至可以包含堆栈调用的信息，这样可以帮助更好的定位程序的bug
2. 返回错误码的传统方式有个很大的问题就是，在函数调用链中，深层的函数返回了错误，那么我们得层层返回错误，最外层才能拿到错误
3. 很多的第三方库都包含异常，比如boost、gtest、gmock等等常用的库，那么我们使用它们也需要使用异常
4. 部分函数使用异常更好处理，比如构造函数没有返回值，不方便使用错误码方式处理。比如T& operator这样的函数，如果pos越界了只能使用异常或者终止程序处理，没办法通过返回值表示错误。

**缺点**

1. 异常会导致程序的执行流乱跳，并且非常的混乱，并且是运行时出错抛异常就会乱跳。这会导致我们跟踪调试时以及分析程序时，比较困难
2. C++没有垃圾回收机制，资源需要自己管理。有了异常非常容易导致内存泄漏、死锁等异常安全问题。这个需要使用RAII来处理资源的管理问题
3. C++标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱
4. 异常会有一些性能的开销。当然在现代硬件速度很快的情况下，这个影响基本忽略不计
5. 异常尽量规范使用，否则后果不堪设想，随意抛异常，外层捕获的用户苦不堪言。所以异常规范有两点：一、抛出异常类型都继承自一个基类。二、函数是否抛异常、抛什么异常，都使用 func（） throw();的方式规范化。