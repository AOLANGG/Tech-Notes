## {}初始化

在C++98中，标准允许使用{}对数组或者结构体元素进行统一的列表初始值设定

```c++
struct Point
{
	int _x;
	int _y;
};
int main()
{
	int array1[] = { 1,2,3,4,5 };
	Point p = { 1,2 };
	return 0;
}
```

C++11扩大了用大括号括起的列表的使用范围，使所有的内置类型和用户自定义的类型，**使用初始化列表的时候，可以不添加=**

```c++
struct Point
{
	int _x;
	int _y;
};
int main()
{
	int x1 = 1;
	int x2{ 2 };
	int array1[]{ 1, 2, 3, 4, 5 };
	int array2[5]{ 0 };
	Point p{ 1, 2 };
	// C++11中列表初始化也可以适用于new表达式中
	int* pa = new int[4] { 0 };
	delete[]pa;
	return 0;
}
```

### std::initializer_list

std::initializer_list一般是作为构造函数的参数，C++11对STL中的不少容器就增加std::initializer_list作为参数的构造函数这样初始化容器对象就更方便了。可以作为operator=的参数，这样就可以用大括号赋值。

## 声明

### auto

auto用于实现自动类型推断，这样要求必须进行显式初始化，让编译器将定义对象的类型设置为初始化值的类型

```c++
int main()
{
	int i = 10;
	auto p = &i;
	auto pf = strcpy;
	cout << typeid(p).name() << endl;
	cout << typeid(pf).name() << endl;
	
	return 0;
}
```

### decltype

关键字decltype将变量的类型声明为表达式指定的类型

```c++
template<class T1, class T2>
void F(T1 t1, T2 t2)
{
	decltype(t1 * t2) ret;
	cout << typeid(ret).name() << endl;
}
int main()
{
	const int x = 1;
	double y = 2.2;
	decltype(x * y) ret; // ret的类型是double
	decltype(&x) p; // p的类型是int*
	cout << typeid(ret).name() << endl;
	cout << typeid(p).name() << endl;
	F(1, 'a');
	return 0;
}
```

### nullptr

由于C++中`NULL`被定义为字面量0，这样可能导致一些问题，因为0技能表示指针常量，又能表示整型常量。所以处于清晰和安全的角度考虑，C++中新增了nullptr，用于表示空指针

## 范围for循环

对于一个**有范围的集合**而言，由程序员来说明循环的范围是多余的；有时候还容易犯错误。因此C++中引入了基于范围的for循环。**for循环后的括号是由冒号:分为两部分，第一部分是范围内用于迭代的变量，第二部分是表示用于迭代的范围**

**范围for的使用条件**

1. **for循环迭代的范围必须是确定的**。**对于数组而言，就是数组中的第一个元素和最后一个元素的范围**；对于类而言，应该是提供`begin`和`end`的方法，`begin`和`end`就是for循环迭代的范围
2. 迭代的对象要实现++和==的操作

## 智能指针

### 内存泄漏

[内存管理](https://github.com/AOLANGG/Tech-Notes/blob/main/C%2B%2B/C%2B%2B/07.%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.md)

### 智能指针的使用和原理

1. RAII

RAII是一种**利用对象生命周期来控制程序**（如内存，文件句柄，网络连接，互斥量等）的简单技术

**在对象构造时获取资源**，接着控制对资源的访问，使之在对象的生命周期中保持有效，**最后在对象析构的时候释放资源**。

- 不需要显式的释放资源
- 采用这种方式，对象所需的资源在其生命周期内始终保持有效

```c++
// 利用RAII思想设计的SmartPtr类
template <class T>
class SmartPtr {
public:
	SmartPtr(T* ptr = nullptr)
		: _ptr(ptr)
	{}
	~SmartPtr()
	{
		cout << "调用析构函数" << endl;
		if (_ptr)
			delete _ptr;
	}
private:
	T* _ptr;
};
int div()
{
	int a, b;
	cin >> a >> b;
	if (b == 0)
		throw invalid_argument("除0错误");
	return a / b;
}
void Func()
{
	SmartPtr<int> sp1(new int);
	SmartPtr<int> sp2(new int);
	cout << div() << endl;
}
int main()
{
	try {
		Func();
	}
	catch (const exception& e)
	{
		cout << e.what() << endl;
	}
	return 0;
}
```

### 智能指针的原理

上述的`SmartPtr`还不能称之为智能指针，因为它还不具有指针的行为。指针可以解引用，也可以通过`->`去访问所指空间中的内容。因此：**AutoPtr模板类还得需要将`*`，`->`重载一下，才可让其像指针一样去使用**

```c++
template <class T>
class SmartPtr
{
public:
    SmartPtr(T* ptr = nullptr):
    _ptr(ptr)
    {}
    ~SmartPtr()
    {
        if(_ptr)
        {
            delete _ptr;
            _ptr = nullptr;
        }
    }
    T& operator*()
    {
        return *_ptr;
    }
    T* operator->()
    {
        return _ptr;
    }
private:
    T* _ptr;
};
struct Date
{
    int _year;
    int _month;
    int _day;
};
int main()
{
    SmartPtr<int> sp1(new int);
    *sp1 = 10;
    cout<<*sp1<<endl;
    SmartPtr<Date> sparray(new Date);
    sparray->_year = 2018;
    sparray->_month = 1;
    sparray->_day = 1;
    return 0;
}
```

### std::auto_ptr

**`auto_ptr`的实现原理：管理权转移的思想**

```c++
template<class T>
class auto_ptr
{
public:
    auto_ptr(T* ptr):
    _ptr(ptr)
    {

    }
    auto_ptr(auto_ptr<T>&sp):
    _ptr(sp._ptr)
    {
        sp._ptr = nullptr;
    }
    auto_ptr<T>&operator=(auto_ptr<T>& ap)
    {
        if(this!=&ap)
        {
            if(_ptr)
                delete _ptr;
            _ptr = ap._ptr;
            ap._ptr = nullptr;
        }
    }
    ~auto_ptr()
    {
        if(_ptr)
        {
            delete _ptr;
        }
    }
    // 像指针一样使用
    T& operator*()
    {
        return *_ptr;
    }
    T* operator->()
    {
        return _ptr;
    }
private:
    T* _ptr;
};
```

**结论：`auto_ptr`是一个失败的设计，很多公司要求不能使用`auto_ptr`**

### std::unique_ptr

**`unique_ptr`的实现原理：简单粗暴的防拷贝**

```c++
template <class T>
class unique_ptr
{
public:
    unique_ptr(T* ptr):
    _ptr(ptr)
    {}
    ~unique_ptr()
    {
        if(_ptr)
        {
            delete _ptr;
        }
    }
    T& operator*()
    {
        return *_ptr;
    }
    T* operator->()
    {
        return _ptr;
    }
    unique_ptr(const unique_ptr<T>& sp) = delete;
    unique_ptr<T>& operator=(const unique_ptr<T>& sp) = delete;
private:
    T*  _ptr;
};
int main()
{
    unique_ptr<int> sp1(new int);
    // unique_ptr<int> sp2(sp1);

    std::unique_ptr<int> sp1(new int);
    // std::unique_ptr<int> sp2(sp1);
    return 0;
}
```

### shared_ptr

C++11中提供了更靠谱的并且支持拷贝的`shared_ptr`

**`shard_ptr`的原理：通过引用计数的方式实现了多个`shared_ptr`对象之间共享资源。**

1. `shared_ptr`在其内部，**给每个资源都维护了一份计数，用来记录该份资源被几个对象共用**
2. 在**对象被销毁时（析构函数被调用）**，就说明这个对象不使用该资源了，引用计数--
3. **如果引用计数为0**，说明自己是最后一个使用该资源的对象，**必须要释放资源**
4. **如果不是0**，说明除了自己还有别的对象在使用这份资源，**不能释放资源**

```c++
template <class T>
class shared_ptr
{
public:
    shared_ptr(T* ptr = nullptr) :
        _ptr(ptr),
        _pRefCount(new int(1)),
        _pmtx(new mutex)
    {}
    shared_ptr(const shared_ptr<T>& sp) :
        _ptr(sp._ptr),
        _pRefCount(sp._pRefCount),
        _pmtx(sp._pmtx)
    {
        addRef();
    }
    shared_ptr<T>& operator=(const shared_ptr<T>& sp)
    {
        // 自己赋值给自己，应不予理会
        if (_ptr != &sp)
        {
            Release();
            _ptr = sp._ptr;
            _pRefCount = sp._pRefCount;
            _pmtx = sp._pmtx;
            addRef();
        }
        return *this;
    }
    ~shared_ptr()
    {
        Release();
    }
    void Release()
    {
        _pmtx->lock();
        bool flag = false;
        if (--(*_pRefCount) == 0 && _ptr)
        {
            delete _ptr;
            delete _pRefCount;
            flag = true;
        }
        _pmtx->unlock();
        if (flag)
            delete _pmtx;
    }
    void addRef()
    {
        _pmtx->lock();
        ++(*_pRefCount);
        _pmtx->unlock();
    }
    // 像指针一样使用
    T& operator*()
    {
        return *_ptr;
    }
    T* operator->()
    {
        return _ptr;
    }
    T* get()const
    {
        return _ptr;
    }
private:
    T* _ptr;
    int* _pRefCount;
    std::mutex* _pmtx;
};
```

`shared_ptr`智能指针是线程安全的吗?

是的，引用计数的加减是加锁保护的。但是指向的资源不是线程安全的。

**`std::shared_ptr`的线程安全问题**

1. 智能指针对象中引用计数是多个智能指针对象共享的，两个线程中智能指针的引用计数同时++或--，这个操作不是原子的，引用计数原来是1，++了两次，可能还是这样引用计数就错乱了。会导致资源未释放或者程序崩溃的问题。所以只能指针中引用计数++、--是需要加锁的，也就是说引用计数的操作是线程安全的。

2. 智能指针管理的对象存放在堆上，两个线程中同时去访问，会导致线程安全问题。

**`std::shared_ptr`的循环引用**

![img](https://i-blog.csdnimg.cn/direct/dc8063cd9ae147ed94a89c6123e42b82.png)

搭配`weak_ptr`使用

```c++
    template <class T>
    class shared_ptr
    {
    public:
        shared_ptr(T* ptr = nullptr)
            : _ptr(ptr), _pRefCount(new int(1)), _pmtx(new std::mutex)
        {
        }
        shared_ptr(const shared_ptr<T>& sp)
            : _ptr(sp._ptr), _pRefCount(sp._pRefCount), _pmtx(sp._pmtx)
        {
            AddRef();
        }
        void Release()
        {
            _pmtx->lock();
            bool flag = false;
            if (--(*_pRefCount) == 0 && _ptr)
            {
                std::cout << "delete:" << _ptr << std::endl;
                delete _ptr;
                delete _pRefCount;
                flag = true;
            }
            _pmtx->unlock();
            if (flag == true)
            {
                delete _pmtx;
            }
        }
        void AddRef()
        {
            _pmtx->lock();
            ++(*_pRefCount);
            _pmtx->unlock();
        }
        shared_ptr<T>& operator=(const shared_ptr<T>& sp)
        {
            // if (this != &sp)
            if (_ptr != sp._ptr)
            {
                Release();
                _ptr = sp._ptr;
                _pRefCount = sp._pRefCount;
                _pmtx = sp._pmtx;
                AddRef();
            }
            return *this;
        }
        int use_count()
        {
            return *_pRefCount;
        }
        ~shared_ptr()
        {
            Release();
        }
        // 像指针一样使用
        T& operator*()
        {
            return *_ptr;
        }
        T* operator->()
        {
            return _ptr;
        }
        T* get() const
        {
            return _ptr;
        }

    private:
        T* _ptr;
        int* _pRefCount;
        std::mutex* _pmtx;
    };
    // 简化版本的weak_ptr实现
    template <class T>
    class weak_ptr
    {
    public:
        weak_ptr()
            : _ptr(nullptr)
        {
        }
        weak_ptr(const shared_ptr<T>& sp)
            : _ptr(sp.get())
        {
        }
        weak_ptr<T>& operator=(const shared_ptr<T>& sp)
        {
            _ptr = sp.get();
            return *this;
        }
        T& operator*()
        {
            return *_ptr;
        }
        T* operator->()
        {
            return _ptr;
        }

    private:
        T* _ptr;
    };
}
```

**如果不是`new`出来的对象该如何使用智能指针管理呢？其实`shared_ptr`设计了一个删除器来解决这个问题**

```c++
template <class T>
struct FreeFunc
{
    void operator()(T* ptr)
    {
        std::cout << "free: " << ptr << std::endl;
        free(ptr);
    }
};
int main()
{
    std::shared_ptr<int> sp1((int*)malloc(4), FreeFunc<int>());
    std::shared_ptr<int> sp2((int*)malloc(4), [](int* ptr) {
        std::cout << "free: " << ptr << std::endl;
        free(ptr);
        });
	return 0;
}
```

## 右值引用和移动语义

传统的C++语法中就有引用的语法，而C++11中新增了的右值引用的语法特性，所以之前学习的引用都叫做左值引用。**无论左值引用还是会右值引用，都是给对象取别名**。

**什么是左值，什么是左值引用？**

左值是一个表示数据的表达式，**我们可以获取它的低职高，可以对它赋值，左值可以出现赋值符号左边，右值不能出现在赋值符号的左边**

比如：

```c++
int main()
{
    // 以下的p、b、c、*p都是左值
    int* p = new int(0);
    int b = 1;
    const int c = 2;
    // 以下几个是对上面左值的左值引用
    int*& rp = p;
    int& rb = b;
    const int& rc = c;
    int& pvalue = *p;
    return 0;
}
```

**什么是右值？什么是右值引用？**

右值也是一个数据的表达式，比如：字面常量，表达式返回值，函数返回值。**右值可以出现在赋值符号的右边，但是不能出现在赋值符号的左边，右值不能取地址**。右值引用就是对右值的引用，给右值取别名

```c++
int main()
{
    double x = 1.1, y = 2.2;
    // 以下几个都是常见的右值
    10;
    x + y;
    fmin(x, y);
    // 以下几个都是对右值的右值引用
    int&& rr1 = 10;
    double&& rr2 = x + y;
    double&& rr3 = fmin(x, y);
    // 这里编译会报错：error C2106: “=”: 左操作数必须为左值
    10 = 1;
    x + y = 1;
    fmin(x, y) = 1;
    return 0;
}
```

### 左值引用和右值引用的比较

**左值引用总结**：

1. 左值引用只能引用左值，不能引用右值
2. const左值引用既可以引用左值，也可以引用右值

```c++
int main()
{
	int a = 10;
	int& ra1 = a;
	//int& ra2 = 10;// 编译失败
	const int& ra3 = 10;
	const int& ra4 = a;
	return 0;
}
```

**右值引用总结**

1. 右值引用只能引用右值，不能引用左值
2. 但是右值引用可以引用move以后得左值

```c++
int main()
{
	int&& r1 = 10;
	int a = 10;
	//int&& r2 = a;// 错误

	int&& r3 = std::move(a);
	return 0;
}
```

### 右值引用的使用场景和意义

```c++
namespace bit
{
	class string
	{
	public:
		typedef char* iterator;
		iterator begin()
		{
			return _str;
		}
		iterator end()
		{
			return _str + _size;
		}
		string(const char* str=""):
			_size(strlen(str)),
			_capacity(_size)
		{
			_str = new char[_capacity + 1];
			strcpy(_str, str);
		}
		void swap(string& s)
		{
			std::swap(_str, s._str);
			std::swap(_size, s._size);
			std::swap(_capacity, s._capacity);
		}
		// 拷贝构造
		string(const string& s):
			_str(nullptr)
		{
			std::cout << "string(const string&s) 拷贝构造" << std::endl;
			string temp(s._str);
			swap(temp);
		}
		// 赋值重载
		string& operator=(const string& s)
		{
			std::cout << "string& operator=(const string& s) 赋值重载" << std::endl;
			string temp(s._str);
			swap(temp);
			return *this;
		}
		// 移动构造
		string(string&& s) :
			_str(nullptr),
			_size(0),
			_capacity(0)
		{
			std::cout << "string(string&& s) 移动构造" << std::endl;
			swap(s);
		}
		// 移动赋值
		string& operator=(string&& s)
		{
			std::cout << "string& operator=(string&& s)" << std::endl;
			swap(s);
			return *this;
		}
		~string()
		{
			delete[] _str;
			_str = nullptr;
		}
		char& operator[](size_t pos)
		{
			assert(pos < _size);
			return _str[pos];
		}
		void reserve(size_t n)
		{
			if (n > _capacity)
			{
				char* tmp = new char[n + 1];
				strcpy(tmp, _str);
				delete[] _str;
				_str = tmp;
				_capacity = n;
			}
		}
		void push_back(char ch)
		{
			if (_size >= _capacity)
			{
				size_t newcapacity = _capacity == 0 ? 4 : _capacity * 2;
				reserve(newcapacity);
			}
			_str[_size] = ch;
			++_size;
			_str[_size] = '\0';
		}
		string& operator+=(char ch)
		{
			push_back(ch);
			return *this;
		}
		const char* c_str() const
		{
			return _str;
		}
	private:
		char* _str;
		size_t _size;
		size_t _capacity;
	};
}
```

**左值引用的使用场景**

做参数和返回值都可以提高效率



但是当函数返回对象是一个局部变量，出了函数作用域就不存在了，就不能使用左值引用，只能传值返回，会导致至少1次拷贝构造（如果是一些旧的编译器可能是两次拷贝构造）

![img](https://i-blog.csdnimg.cn/direct/59623a6971c448ae9bdcddac9493d6cc.png)

![img](https://i-blog.csdnimg.cn/direct/81fa9f08f9bf46f5945029935edc187c.png)

**右值引用和移动语义解决上述问题**

在`bit::string`中增加移动构造，**移动构造本质就是将参数右值的资源窃取过来，占为已有，那么就不需要深拷贝了，所以它叫做移动构造，就是窃取别人的资源来构造自己**

![img](https://i-blog.csdnimg.cn/direct/0c8487d198a743d9b34d967af61af392.png)

## 右值引用

按照语法，右值引用只能引用右值，但右值引用一定不能引用左值吗？**当需要用右值，引用一个左值的时候，可以通过`move`**函数将左值转换成右值。C++11中，**`std::move`函数**，这个名字具有迷惑性，事实上，它**并不搬移任何东西，唯一的作用就是将一个左值强制转换成右值来使用，然后实现移动语义**

```c++
int main()
{
	bit::string s1("hello world");
	bit::string s2(s1);// 拷贝构造
	bit::string s3(std::move(s1));// 移动构造
	return 0;
}
```

### 完美转发

**模板中的&&万能引用**

```c++
void Fun(int& x)
{
	std::cout << "左值引用" << std::endl;
}
void Fun(const int& x)
{
	std::cout << "const 左值引用" << std::endl;
}
void Fun(int&& x)
{
	std::cout << "右值引用" << std::endl;
}
void Fun(const int&& x)
{
	std::cout << "const 右值引用" << std::endl;
}
template <class T>
void PerfectForward(T&& t)
{
    // t作为一个函数内部的变量，有自己的名字，它是一个左值
	Fun(t);
}
int main()
{
	PerfectForward(10); // 右值

	int a = 1;
	PerfectForward(a); // 左值
	PerfectForward(std::move(a)); // 右值

	const int b = 8;
	PerfectForward(b); // const 左值
	PerfectForward(std::move(b)); // const 右值
	return 0;
}
```

模板中的&&不代表右值引用，而是万能引用，既能接受左值也能接受右值

万能医用只是提供了能够同时接受左值引用和右值引用的能力

但是引用类型的唯一作用就是限制了接受的类型，后续使用中都退化成了左值

如果希望在传递的过程中保持它的左值或者右值的属性，就需要用到下面学习的完美转发

![img](https://i-blog.csdnimg.cn/direct/07b59904f46c46bf912014f2a82c3e7e.png)

`std::forward`完美转发的传参的过程中保留对象原生类型的属性

```c++
void Fun(int& x)
{
	std::cout << "左值引用" << std::endl;
}
void Fun(const int& x)
{
	std::cout << "const 左值引用" << std::endl;
}
void Fun(int&& x)
{
	std::cout << "右值引用" << std::endl;
}
void Fun(const int&& x)
{
	std::cout << "const 右值引用" << std::endl;
}
template <class T>
void PerfectForward(T&& t)
{
    // 完美转发
	Fun(std::forward<T>(t));
}
int main()
{
	PerfectForward(10); // 右值

	int a = 1;
	PerfectForward(a); // 左值
	PerfectForward(std::move(a)); // 右值

	const int b = 8;
	PerfectForward(b); // const 左值
	PerfectForward(std::move(b)); // const 右值
	return 0;
}
```

## 新的类功能

原来C++类中，有6个默认成员函数：

1. 构造函数
2. 析构函数
3. 拷贝构造函数
4. 拷贝赋值重载
5. 取地址重载
6. const 取地址重载

最后重要的是前4个，后两个用处不大。默认成员函数就是我们不写编译器会生成一个默认的。

C++11 新增了两个：移动构造函数和移动赋值运算符重载

针对移动构造函数和移动赋值运算符重载有一些需要注意的点如下

- 如果你没有自己实现移动构造函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个。那么编译器会自动生成一个默认移动构造。默认生成的移动构造函数，对于内置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动构造，如果实现了就调用移动构造，没有实现就调用拷贝构造。
- 如果你没有自己实现移动赋值重载函数，且没有实现析构函数 、拷贝构造、拷贝赋值重载中的任意一个，那么编译器会自动生成一个默认移动赋值。默认生成的移动构造函数，对于内置类型成员会执行逐成员按字节拷贝，自定义类型成员，则需要看这个成员是否实现移动赋值，如果实现了就调用移动赋值，没有实现就调用拷贝赋值。(默认移动赋值跟上面移动构造完全类似)
- 如果你提供了移动构造或者移动赋值，编译器不会自动提供拷贝构造和拷贝赋值。

**强制生成默认函数的关键字`default`**

C++11可以更好的控制要使用的默认函数。假设你要是用某个默认的函数，但是因为一些原因这个函数没有默认生成，可以使用`default`关键字显示指定移动构造生成

**禁止生成默认函数的关键字`delete`**

如果想要限制某些默认函数的生成，在C++11中，只需要在该函数声明加上`=delete`即可，该语法指示编译器不生成对应函数的默认版本，这个函数为删除函数
