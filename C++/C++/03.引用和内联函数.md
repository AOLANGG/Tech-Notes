## 引用

### 概念

引用不是新定义一个变量，而是给已经存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，他和他引用的变量共用同一块内存空间

### 特性

引用在定义的时候必须初始化

一个变量可以有多个引用

引用一旦引用一个实体，这个引用就不能引用其他实体

### const引用

用const修饰的引用，该引用变量不能修改

### 应用场景

为实现简单、普通的取别名；比如结构体套结构体，想要使用里层结构中的成员，AB成员，不方便可以直接用引用简化

做函数参数

1. 想要通过形成修改外部实参
   - 指针：虽然可以做到，但是比较麻烦而且可能会出现指针非法操作异常
   - 引用类型的参数，如果不想通过形参改变实参可以加const进行限制
2. 自定义类型对象传参（最好是引用，可以提高传参的效率）

做函数的返回值

注意：不能返回栈上空间的引用，与其实体共用同一块内存空间，栈空间已经回收，如果用户在函数外以引用方法接受函数返回值，那引用的将会是一段非法的空间

### 引用和指针的区别

概念上：

引用是一个别名，与其实体共用同一块内存空间

底层实现上：引用就是按照指针的方式实现的，即引用在底层就是一个指针

区别主要体现在特性和使用形式上

1. 引用在定义的时候必须要初始化，而指针没有要求
2. 引用在初始化时引用一个实体之后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型的实体
3. 没有空引用，但又空指针
4. 在sizeof中含义不同，引用结果为引用类型的大小，但指针始终为地址空间所占的字节个数（在32位平台下是4字节）
5. 引用变量的++和--是直接给引用实体的值+1或-1，而指针变量的++或--是让指针向后或向前偏移一个类型的大小
6. 有多级指针，没有多级引用
7. 访问实体的方式不同，指针需要显示解引用，引用编译器自己处理
8. 引用比指针使用起来相对更安全，指针更容易出现非法访问内存的情况

## 内联函数

### 概念

以inline修饰的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，可以提升函数运行的效率

### 特性

1. `inline`是一个以空间换时间的做法，省去调用函数额外的开销，所以代码很长或者有循环/递归的函数不适合作为内联函数
2. `inline`对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline函数体内有循环/递归，编译器可能会优化忽略掉内敛
3. `inline`不建议声明和定义分开，分开会导致链接错误，因为`inline`被展开，就没有函数地址了，链接就会找不到

### 内联函数和宏函数的区别

宏函数：

优点：

- 在预处理节点会展开，少了函数调用参数压栈的开销

缺陷：

1. 在预处理阶段展开，增加了预处理的事件
2. 编译之前展开，如果编译时报错，错误不好定位
3. 参数没有类型，而编译的时候已经展开，不能进行参数类型检测，安全性低
4. 可读性差，比如为了保证参数的正确性，需要多出括号，但仍可能出现错误
5. 不能调试
6. 因为已经展开，如果调用的位置比较多，可能会引起代码膨胀

内联函数：

优点：

1. 是一个函数，参数具有类型，可以进行类型检测，安全性高
2. 在编译阶段展开，少了函数调用开销，能够提高代码的运行效率
3. 在调试的时候可以不让编译器展开，方便调试
4. 没有副作用（不是直接替换，不会改变语义）

缺陷：

1. 可能引起代码膨胀
2. `inline`是建议性关键字，编译器将`inline`修饰的函数按照内联函数处理，但是编译器是否会将其当做内联函数处理，则不一定。