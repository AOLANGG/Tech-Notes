## 可变参数模板

C++11的新特性可变参数模板能够让您创建可以接受可变参数的函数模板和类模板

```c++
// Args 是一个模板参数包，args是一个函数形参参数包
// 声明一个参数包Args...args，这个参数包中包含0到任意个模板参数
template <class ...Args>
void ShowList<Args... args)
{
    
}
```

### **递归函数方式展开参数包**

```c++
void _cppPrintf()
{
	std::cout << std::endl;
}
template<class T,class ...Args>
void _cppPrintf(const T&val,Args... args)
{
	std::cout << val << " ";
	_cppPrintf(args...);
}
template<class ...Args>
void cppPrintf(Args... args)
{
	_cppPrintf(args...);
}
int main()
{
	cppPrintf(1);
	cppPrintf(1,'A');
	cppPrintf(1,'A',std::string("sort"));
	return 0;
}
```

### **逗号表达式展开参数包**

```c++
template <class T>
int PrintArg(T t)
{
	std::cout << t << " ";
	return 0;
}
template<class ...Args>
void cppPrintf(Args... args)
{
	// args... 参数有多少个值，PrintArg函数就调用多少次，也就有多少个返回值，arr数组就开多大
	int arr[] = { PrintArg(args)... };
	// 可以理解为
	// int arr[] = { PrintArg(x),PrintArg(y),PrintArg(z),... };
	std::cout << std::endl;
}

int main()
{
	cppPrintf(1);
	cppPrintf(1, 'A');
	cppPrintf(1.1, 'A', std::string("sort"));
	return 0;
}
```

### STL容器中的`emplace`相关接口函数

```c++
template <class ...Args>
    void emplace_back(ARgs&&... args);
```

`emplace`系列的接口，支持模板的可变参数，并且万能引用。那么相对`insert`和`emplace`系列接口的优势在哪里呢？

```c++
int main()
{
	std::list< std::pair<int, char> > mylist;
	// emplace_back支持可变参数，拿到构建pair对象的参数后自己去创建对象
	// 那么在这里我们可以看到除了用法上，和push_back没什么太大的区别
	mylist.emplace_back(10, 'a');
	mylist.emplace_back(20, 'b');
	mylist.emplace_back(make_pair(30, 'c'));
	mylist.push_back(make_pair(40, 'd'));
	mylist.push_back({ 50, 'e' });
	for (auto e : mylist)
		cout << e.first << ":" << e.second << endl;
	return 0;
}
```

```c++
int main()
{
	// 下面我们试一下带有拷贝构造和移动构造的bit::string，再试试呢
	// 我们会发现其实差别也不到，emplace_back是直接构造了，push_back
	// 是先构造，再移动构造，其实也还好。
	std::list< std::pair<int, bit::string> > mylist;
	mylist.emplace_back(10, "sort");
	mylist.emplace_back(make_pair(20, "sort"));
	mylist.push_back(make_pair(30, "sort"));
	mylist.push_back({ 40, "sort" });
	return 0;
}
```

## lambda表达式

```c++
int main()
{
 vector<Goods> v = { { "苹果", 2.1, 5 }, { "香蕉", 3, 4 }, { "橙子", 2.2, 
3 }, { "菠萝", 1.5, 4 } };
 sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2){
 return g1._price < g2._price; });
 sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2){
 return g1._price > g2._price; });
 sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2){
 return g1._evaluate < g2._evaluate; });
 sort(v.begin(), v.end(), [](const Goods& g1, const Goods& g2){
 return g1._evaluate > g2._evaluate; });
}
```

上述代码就是用C++11的lambda表达式来解决，可以看出lambda实际上是一个匿名函数

lambda表达式书写格式：

`[capture-list] (parameters) mutable -> return-type { statement}`

- `capture-list`：**捕捉列表**，该列表总是出现在lambda函数的开始位置，**编译器根据[]来判断接下来的代码是否为lambda函数，捕捉列表能够捕捉上下文中的变量供lambda函数使用**
- `parameters`：参数列表。和**普通函数的参数列表一致**，如果不需要参数传递，则可以连同（）一起省略
- `mutable`：默认情况下，lambda函数总是一个`const`函数，`mutable`可以取消其常量性。使用该修饰符时，参数列表不可省略。
- **`->returntype`**：**返回值类型**，用**追踪返回类型形式声明函数的返回值**，没有返回值的可以忽略。**返回值类型明确的情况下，可以忽略，有编译器自动推导出返回值的类型**
- **`{statement}`**：**函数体**。在该函数体内，除了可以使用其参数外，还可以使用所有捕获到的变量。

```c++
int main()
{
	// 最简单的lambda表达式, 该lambda表达式没有任何意义
	[] {};

	// 省略参数列表和返回值类型，返回值类型由编译器推导为int
	int a = 3, b = 4;
	[=] {return a + 3; };

	// 省略了返回值类型，无返回值类型
	auto fun1 = [&](int c) {b = a + c; };
	fun1(10);
	cout << a << " " << b << endl;

	// 各部分都很完善的lambda函数
	auto fun2 = [=, &b](int c)->int {return b += a + c; };
	cout << fun2(10) << endl;

	// 复制捕捉x
	int x = 10;
	auto add_x = [x](int a) mutable { x *= 2; return a + x; };
	cout << add_x(10) << endl;
	return 0;
}
```

**捕捉列表描述了上下文中那些数据可以被`lambda`使用，以及使用的方式——传值还是传引用**

- [var]：表示值传递捕捉变量`var`
- [=]：表示值传递方式捕获所有父作用域中的变量（包括this）
- [&var]：表示引用的方式捕捉变量`var`
- [&]：表示引用传递捕捉所有父作用域中的变量（包括this）
- [this]：表示值传递方式捕捉当前的`this`指针

**注意**

1. **父作用域指包含`lambda`函数的语句块**
2. **语法上捕捉列表可以由多个捕捉项组成，并用逗号分隔**
3. **捕捉列表不允许变量重复传递，否则会导致编译错误。**
4. **在快作用域以外的`lambda`函数捕捉列表必须为空**
5. 在块作用域中的lambda函数仅能捕捉父作用域中局部变量，捕捉任何非此作用域或者非局部变量都会报错
6. **`lambda`表达式之间不能相互赋值，即使看起来类型相同**

```c++
void (*PF)();
int main()
{
	auto f1 = [] {cout << "hello world" << endl; };
	auto f2 = [] {cout << "hello world" << endl; };
	// 此处先不解释原因，等lambda表达式底层实现原理看完后，大家就清楚了
	//f1 = f2; // 编译失败--->提示找不到operator=()
	// 允许使用一个lambda表达式拷贝构造一个新的副本
	auto f3(f2);
	f3();
	// 可以将lambda表达式赋值给相同类型的函数指针
	PF = f2;
	PF();
	return 0;
}
```

### 函数对象和`lambda`表达式

函数对象，又叫做仿函数，可以像一个函数一样使用的对象，就是在类中重载了`operator=()`运算符的类对象

```c++
class Rate
{
public:
	Rate(double rate) :
		_rate(rate)
	{}
	double operator()(double money, int year)
	{
		return money * _rate * year;
	}
private:
	double _rate;
};
int main()
{
	// 函数对象
	double rate = 0.49;
	Rate r1(rate);
	std::cout << r1(10000, 2) << std::endl;
	// lamber
	auto r2 = [=](double monty, int year)->double {
		return monty * rate * year;
		};
	std::cout << r2(10000, 2) << std::endl;
	return 0;
}
```

从使用方式上来看，函数对象与lambda表达式完全一样。

函数对象将rate作为其成员变量，在定义对象时给出初始值即可，lambda表达式通过捕获列表可以直接将该变量捕获到。

![img](https://i-blog.csdnimg.cn/direct/7290cc6154024eda8c9ff15d1e0ab7a8.png)

实际上在底层对于`lambda`表达式的处理方式就是生成一个类，重载`operator()`，和仿函数高度一致。

## 包装器

**function包装器**

```c++
template<class F,class T>
T useF(F f, T x)
{
	static int count = 0;
	std::cout << "count:" << ++count << std::endl;
	std::cout << "count:" << &count << std::endl;
	return f(x);
}
double f(double i)
{
	return i / 2;
}
struct Functor
{
	double operator()(double d)
	{
		return d / 3;
	}
};
int main()
{
	// 函数名
	cout << useF(f, 11.11) << endl;
	// 函数对象
	cout << useF(Functor(), 11.11) << endl;
	// lamber表达式
	cout << useF([](double d)->double { return d / 4; }, 11.11) << endl;
	return 0;
}
```

**通过上面程序验证，发现userF函数模板实例化成了三份**。这必然导致模板的效率低下。 

`function`的用法如下：

```c++
#include <functional>
int f(int a, int b)
{
	return a + b;
}
struct Functor
{
	int operator()(int a, int b)
	{
		return a + b;
	}
};
class Plus
{
public:
	static int plusi(int a, int b)
	{
		return a + b;
	}
	double plusd(double a, double b)
	{
		return a + b;
	}
};
int main()
{
	// 函数名(函数指针)
	std::function<int(int, int)> func1 = f;
	cout << func1(1, 2) << endl;
	// 函数对象
	std::function<int(int, int)> func2 = Functor();
	cout << func2(1, 2) << endl;
	// lamber表达式
	std::function<int(int, int)> func3 = [](const int a, const int b)
		{return a + b; };
	cout << func3(1, 2) << endl;
	// 类的成员函数
	std::function<int(int, int)> func4 = &Plus::plusi;
	cout << func4(1, 2) << endl;
	std::function<double(Plus, double, double)> func5 = &Plus::plusd;
	cout << func5(Plus(), 1.1, 2.2) << endl;
	return 0;
}
```

有了包装器，如何解决模板的效率低下，实例化多份的问题呢？

```c++
#include <functional>

template <class F,class T>
T useF(F f, T x)
{
	static int count = 0;
	cout << "count:" << ++count << endl;
	cout << "count:" << &count << endl;
	return f(x);
}
double f(double i)
{
	return i / 2;
}
struct Functor
{
	double operator()(double d)
	{
		return d / 3;
	}
};
int main()
{
	// 函数名
	function<double(double)>func1 = f;
	cout << useF(func1, 11.11) << endl;
	
	// 函数对象（仿函数）
	function<double(double)>func2 = Functor();
	cout << useF(func2, 11.11) << endl;

	// lambda表达式
	function<double(double)>func3 = [](double d)->double {
		return d / 4;
		};
	cout << useF(func3, 11.11) << endl;
	return 0;
}
```

![img](https://i-blog.csdnimg.cn/direct/b2775433a79741c99fb4aa84164c8c66.png)

### bind

`std::bind`是一个**函数模板，它就像一个新的可调用对象来适应源对象的参数列表**。一般而言，我们用它可以吧一个原本接受N个参数的函数，通过绑定一些参数，返回接受M个（M可以大于N，但是没有什么意义）参数的新函数。同时，使用`std::bind`函数还可以实现参数顺序调整等操作

```c++
// 原型如下：
template <class Fn, class... Args>
/* unspecified */ bind (Fn&& fn, Args&&... args);
// with return type (2) 
template <class Ret, class Fn, class... Args>
/* unspecified */ bind (Fn&& fn, Args&&... args);
```

可以将bind函数看作是一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

调用bind的一般形式：`auto newCallable = bind(callable,arg_list);`

其中，`newCallable`本身是一个可调用对象，`arg_list`是一个逗号分隔的参数列表，对应给定的`callable`的参数。**当我们调用`newCallable`的时候，`newCallbale`会调用`callable`，并传给他`arg_list`中的参数**

arg_list中的参数可能包含形如_n的名字，其中n是一个整数，这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1为newCallable的第一个参数，_2为第二个参数，以此类推

```c++
int Plus(int a, int b)
{
	return a + b;
}
class Sub
{
public:
	int sub(int a, int b)
	{
		return a - b;
	}
};
int main()
{
	//表示绑定函数plus 参数分别由调用 func1 的第一，二个参数指定
	std::function<int(int, int)> func1 = std::bind(Plus, placeholders::_1,
		placeholders::_2);
	//auto func1 = std::bind(Plus, placeholders::_1, placeholders::_2);
	//func2的类型为 function<void(int, int, int)> 与func1类型一样
	//表示绑定函数 plus 的第一，二为： 1， 2
	auto func2 = std::bind(Plus, 1, 2);
	cout << func1(1, 2) << endl;
	cout << func2() << endl;
	Sub s;
	// 绑定成员函数
	std::function<int(int, int)> func3 = std::bind(&Sub::sub, s,
		placeholders::_1, placeholders::_2);
	// 参数调换顺序
	std::function<int(int, int)> func4 = std::bind(&Sub::sub, s,
		placeholders::_2, placeholders::_1);
	cout << func3(1, 2) << endl;
	cout << func4(1, 2) << endl;
	return 0;
}
```

## 线程库

### `thread`类的简单介绍

在C++11之前，涉及多线程问题，都是和平台相关的，比如**windows和Linux下都有自己的接口，这使得代码的可移植性比较差。C++11中最重要的特性就是对线程进行支持，使得C++在并行编程中不需要依赖第三方库**，而且还在原子操作中引入了原子类。要使用标准库中的线程，必须包含`<thread>`头文件

| **函数名**             | **功能**                                                     |
| ---------------------- | ------------------------------------------------------------ |
| thread()               | 构造一个线程对象，没有关联任何线程函数，即没有启动任何线程   |
| thread(fn,args1,args2, | 构造一个线程对象，并关联线程函数fn，args1，args2，...为线程函数的参数 |
| get_id()               | 获取线程ID                                                   |
| jionable()             | 线程是否还在执行，joinable代表的是一个正在执行中的线程       |
| jion()                 | 该函数调用会后阻塞住线程，当该线程结束之后，主线程继续执行   |
| detach()               | 在创建线程对象后马上调用，用于吧被创建线程和线程对象分离开，分离的线程变为后台线程，创建的线程的状态和主线程无关 |

1. 线程是操作系统中的一个概念，**线程对象可以关联一个线程用来控制线程以及获取线程的状态**
2. 当创建一个线程独享后，没有提供线程函数，该对象实际没有对应任何线程

3. 当创建一个线程对象后，并且给线程关联线程函数，该线程就被启动，与主线程一起运行。
   线程函数一般情况下可按照以下三种方式提供
   - 函数指针
   - lambda表达式
   - 函数对象（仿函数）

```c++
#include <thread>

void ThreadFunc(int a)
{
	cout << "Thread1 " << a << endl;
}
class TF
{
public:
	void operator()()
	{
		cout << "Thread3 " << endl;
	}
};
int main()
{
	// 函数指针
	thread t1(ThreadFunc, 10);

	// lambda表达式
	thread t2([]() {cout << "Thread2" << endl; });

	// 函数对象
	TF tf;
	thread t3(tf);

	t1.join();
	t2.join();
	t3.join();
	cout << "main thread" << endl;
	return 0;
}
```

4. `thread`类是防拷贝的，不允许拷贝构造以及赋值，但是可以移动构造和移动赋值
5. 可以通过jionable()函数判断线程是否是有效的，如果是以下任意情况，则线程无效
   - 采用无参构造函数构造的线程对象
   - 线程对象的状态已经转移给其他线程对象
   - 线程已经调用jion或者detach结束

### 线程函数参数

线程函数的参数是以值拷贝的方式拷贝到线程栈空间中的，因此：即使线程参数为引用类型，在线程中修改后也不能修改外部实参，因为其实际引用的是线程栈中的拷贝，而不是外部实参

### 原子性操作库

**多线程最主要的问题就是共享数据带来的问题（线程安全）。如果共享数据都是只读的，那没有任何问题，因为读操作不会影响到数据，更不会涉及数据的修改，所以所有线程都会获得同样的数据**。但是，**当一个或者多个线程要修改共享数据的时候，就会产生很多潜在的麻烦**

```c++
#include <iostream>
using namespace std;
#include <thread>
unsigned long sum = 0L;
void fun(size_t num)
{
	for (size_t i = 0; i < num; ++i)
		sum++;
}
int main()
{
	cout << "Before joining,sum = " << sum << std::endl;
	thread t1(fun, 10000000);
	thread t2(fun, 10000000);
	t1.join();
	t2.join();
	cout << "After joining,sum = " << sum << std::endl;
	return 0;
}
```

对于上述代码，可以采用**加锁** 的方式来解决，同时也可以使用原子操作变量,**使用`atomic`类模板，定义出需要的任意原子类型**

```c++
#include <iostream>
using namespace std;
#include <thread>
#include <mutex>
#include <atomic>
atomic_long sum{ 0 };
//unsigned long sum = 0L;

void fun(size_t num)
{
	for (size_t i = 0; i < num; ++i)
	{
		sum++;
	}
}
int main()
{
	cout << "Before joining,sum = " << sum << std::endl;
	thread t1(fun, 10000000);
	thread t2(fun, 10000000);
	t1.join();
	t2.join();
	cout << "After joining,sum = " << sum << std::endl;
	return 0;
}
```

### lock_guard与unique_lock

在多线程环境下，如果想要保证某个变量的安全性，只需要设置成对应的原子类型即可。但是有些时候，我们需要保证一段代码的安全性，那么就只能通过锁的方式来进行控制。

```c++
#include <thread>
#include <mutex>
int number = 0;
mutex g_lock;
int ThreadProc1()
{
	for (int i = 0; i < 100; i++)
	{
		g_lock.lock();
		++number;
		cout << "thread 1 :" << number << endl;
		g_lock.unlock();
	}
	return 0;
}
int ThreadProc2()
{
	for (int i = 0; i < 100; i++)
	{
		g_lock.lock();
		--number;
		cout << "thread 2 :" << number << endl;
		g_lock.unlock();
	}
	return 0;
}
int main()
{
	thread t1(ThreadProc1);
	thread t2(ThreadProc2);
	t1.join();
	t2.join();
	cout << "number:" << number << endl;
	system("pause");
	return 0;
}
```

上述代码的缺陷：**锁控制不好时，可能会造成死锁**，最常见的比如**在锁中间代码返回，或者在锁的范围内抛异常**。因此：C++11采用RAII的方式对锁进行了封装，即lock_guard和unique_lock

#### mutex的种类

在C++11中，Mutex总共包了四个互斥量的种类：

`std::mutex`

C++11提供的最基本的互斥量，该类的对象之间不能拷贝，也不能进行移动。mutex最常用的三个函数：

| 函数名     | 函数功能                                                     |
| ---------- | ------------------------------------------------------------ |
| lock()     | 上锁：锁住互斥量                                             |
| unlock()   | 解锁：释放互斥量的所有权                                     |
| try_lock() | 尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞 |

注意，线程函数调用lock()时，可能会发生以下三种情况：

- 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁
- 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住
- 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock）

`lock_guard`

`std::lock_guard`是C++11中定义的模板类

```c++
template<class _Mutex>
class lock_guard
{
public:
	// 在构造lock_gard时，_Mtx还没有被上锁
	explicit lock_guard(_Mutex& _Mtx)
		: _MyMutex(_Mtx)
	{
		_MyMutex.lock();
	}
	// 在构造lock_gard时，_Mtx已经被上锁，此处不需要再上锁
	lock_guard(_Mutex& _Mtx, adopt_lock_t)
		: _MyMutex(_Mtx)
	{}
	~lock_guard() _NOEXCEPT
	{
		_MyMutex.unlock();
	}
	lock_guard(const lock_guard&) = delete;
	lock_guard& operator=(const lock_guard&) = delete;
private:
	_Mutex& _MyMutex;
};
```

通过上述代码可以看到，**lock_guard类模板主要是通过RAII的方式，对其管理的互斥量进行了封装**，在需要加锁的地方，只需要用上述介绍的**任意互斥体实例化一个lock_guard，调用构造函数成功上锁，出作用域前，lock_guard对象要被销毁，调用析构函数自动解锁，可以有效避免死锁问题。**

**`lock_guard`的缺陷：太单一，用户没有办法对锁进行控制**，因此C++11有提供了`unique_lock`

**unique_lock**

与lock_gard类似，**unique_lock类模板也是采用RAII的方式对锁进行了封装，并且也是以独占所有权的方式管理mutex对象的上锁和解锁操作，即其对象之间不能发生拷贝**。在构造(或移动(move)赋值)时，unique_lock 对象需要传递一个 Mutex 对象作为它的参数，新创建的unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作。使用以上类型互斥量实例化

**unique_lock的对象时，自动调用构造函数上锁，unique_lock对象销毁时自动调用析构函数解锁，可以很方便的防止死锁问题**

与lock_guard不同的是，unique_lock更加的灵活，提供了更多的成员函数：

1. 上锁/解锁操作：lock、try_lock、try_lock_for、try_lock_until和unlock
2. 修改操作：移动赋值、交换(swap：与另一个unique_lock对象互换所管理的互斥量所有权)、释放(release：返回它所管理的互斥量对象的指针，并释放所有权)、
3. 获取属性：owns_lock(返回当前对象是否上了锁)、operator bool()(与owns_lock()的功能相同)、mutex(返回当前unique_lock所管理的互斥量的指针)。

