## 树的概念以及结构

### 概念

树是一种非线性的数据结构，他是由`n`个有限节点组成的一个具有层次关系的集合，把他叫做树是因为它看起来像一棵倒挂的树，也就是说他是根朝上，而叶子朝下的

- 有一个**特殊的节点，称之为根节点**，根节点没有前驱节点
- 除根节点外，**其余节点被分成M个互不相交的集合T1、T2、······、Tm，其中每个集合又是一个结构和数类似的子树。每个子树的根节点有且只有一个前端，可以有0个或者多个后继
- 因此，树是递归定义的

### 树的相关概念

![img](https://i-blog.csdnimg.cn/direct/8a9543fbb29c4775993e9ff66534aa00.png)

**节点的度**：一个节点含有的子树的个数称为该节点的度

**叶节点或终端节点**：度为0的节点成为叶节点

**非终端节点或分支节点**：度不为0的节点

**孩子节点或子节点**：一个节点含有的子树的根节点成为该节点的子节点

**兄弟节点**：具有相同父节点的节点互称为兄弟节点

**树的度**：一棵树中，最大的节点的度称为树的度

**节点的层次**：从根开始定义起，根为第1层，根的子节点为第2层，以此类推

**树的高度或者深度**：树中节点的最大层次

**堂兄弟节点**：双亲在同一层的节点互为堂兄弟

**节点的祖先**：从根到该节点所经分支上的所有节点

**子孙**：以某节点为根的子树中任一节点都称为该节点的子孙

**森林**：由m（m>0）棵互不相交的树的集合称为森林

## 二叉树的概念和结构

### 概念

一个二叉树是节点的一个有限集合，该集合

1. 为空
2. 由一个跟几点两棵成为左子树和右子树的二叉树组成 

### 特殊的二叉树

1. **满二叉树**：一个二叉树，如果每一层都达到最大值，那这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且节点总数是2^k-1，则它就是慢二叉树
2. **完全二叉树**：完全二叉树是效率很高的数据结构，完全二叉树是由满二叉树赢出来的。对于深度为K的，有n个节点的二叉树，当且仅当每一个节点都与深度为K的慢二叉树中编号为1至n的节点——对应时称之为完全二叉树。要注意的是满二叉树是一种特殊的完全二叉树。

### 性质

1. 若规定根节点的层数为1，则一棵费控二叉树的第i层，最多有2^(i-1)
2.  若规定根节点的层数为1，增**深度为h的二叉树的最大节点数是2^h-1**。
3. 对任何一棵二叉树，**如果度为0其叶节点个数为n0，度2的分支节点个数为n2，则n0=n2+1**
4. 若规定根节点的层数为1，具有**n个节点的完全二叉树的深度**，h=log2(n+1)
5. 对于具有n个节点的完全二叉树，如果按照从上至下从左至右的数组顺序对所有节点从0开始编号，则对于序号为i的节点有
   1. 若i>0，i位置节点的双亲序号，`(i-1)/2`；`i=0`，i为根节点编号，无双亲节点
   2. 若2i+1<n，左孩子序号：2i+1，2i+1>=n否则无左孩子
   3. 2i+2<n，右孩子序号：2i+2，2i+2>=n否则无右孩子

## 堆

### 概念

如果一个关键码的集合K={$k_0$,$k_1$,$k_2$,$k_3$......$k_{n-1}$}，把它的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中，并满足：$K_i<=K_{2i+1}且K_i<=K_{2i+2}$或 $K_i>=K_{2i+1}且K_i>=K_{2i+2}$，i=0,1,2，......，则称之为小堆（或大堆）将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。

堆的性质

- 堆中某个节点的值总是不大于或者不小于其父节点的值
- 堆重视一棵完全二叉树

### 堆的视线

#### 堆向下调整算法

现在给出一个数组，逻辑上看做一棵完全二叉树。通过从根节点开始的向下调整算法可以把他调整成一个小堆。向下调整算法有一个前提，左右子树必须是一个堆，才能调整

```
int array[] = {27,15,19,18,28,34,65,49,25,37};
```

![img](https://i-blog.csdnimg.cn/direct/8b3c36b769044b9b8074a665d7fc5dda.png)

#### 堆的创建

下面我们给出一个数组，这个数组逻辑上可以看做一颗完全二叉树，但是还不是一个堆，现在我们通过算法，把它构建成一个堆。根节点左右子树不是堆，我们怎么调整呢？这里我们从倒数的第一个非叶子节点的子树开始调整，一直调整到根节点的树，就可以调整成堆。

```
int a[] = {1,5,3,8,7,6};
```

![img](https://i-blog.csdnimg.cn/direct/78f1c39340be46188b5cf46f0be85db2.png)

#### 堆的插入

先插入一个10到数组的尾上，再进行向上调整算法，直到满足堆

![img](https://i-blog.csdnimg.cn/direct/3212b054da9e4865a5217948387cfe6d.png)

#### 堆的删除

删除堆是删除堆顶的数据，将堆顶的数据根最后一个数据一换，然后删除数组最后一个数据，再进行向下调整算法。

![img](https://i-blog.csdnimg.cn/direct/d0f59f7fd7d8432c941d5aa3ba0d1c0b.png)

#### 堆排序

堆排序就是利用堆的思想来进行排序，总共分为两个步骤

1. 建堆
   - 升序：建大堆
   - 降序：建小堆
2. 利用堆删除的思想进行排序

建堆和堆删除中都用到了向下调整，因此掌握了向下调整，就可以完成堆排序。

思想：

1. 首先将待排序的数组构造成一个大根堆，此时整个数组的最大值就在顶端
2. 将顶端的元素和末尾的元素进行交换，此时末尾的数为最大值，剩余等待排序的元素有`n-1`个
3. 在将剩余的`n-1`个数构造成大根堆，重复操作1

![img](https://i-blog.csdnimg.cn/direct/d17e8d84c4c04495ae368c71f973ee52.png)

#### TOPK

求数据集合中前K个最大的元素或者最小的元素，一般情况下数据量都比较大

1. 用数据集合中的前K个元素来建堆
   - 前k个最大的元素，则建小堆
   - 前k个最小的元素，则建大堆
2. 用剩余的`N-K`个元素以此与堆顶的元素来比较，不满足就替换堆顶元素。

解答，以前k个最大的元素为例

求前k个最大的元素，这个时候使用小根堆。先用前k个元素构建一个最小堆，堆根就是当前第K大的元素。然后遍历剩余的元素，如果某个元素比对根要大，就把替换掉堆根，并且重新调整堆，这样就可以使堆中始终保留着前K个最大的元素。遍历结束之后，堆中的元素就是前K个最大的元素

### 常见的面试题

### [二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal)

- 按照`中左右 `的顺序进行遍历即可

```c+=
// 递归版本
class Solution {
    vector<int>ans;
    void dfs(TreeNode* node){
        if(node==nullptr)return;
        ans.push_back(node->val);
        dfs(node->left);
        dfs(node->right);
    }
public:
    vector<int> preorderTraversal(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
// 迭代版本
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*>st;
        if(root)
            st.push(root);
        vector<int>ans;
        while(!st.empty()){
            auto top = st.top();
            st.pop();
            ans.push_back(top->val);
            if(top->right)
                st.push(top->right);
            if(top->left)
                st.push(top->left);
        }
        return ans;
    }
};
```

### [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal)

- 按照`左中右`的顺序进行遍历即可

```c++
// 递归版本
class Solution {
    vector<int>ans;
    void dfs(TreeNode* node){
        if(node==nullptr)return;
        dfs(node->left);
        ans.push_back(node->val);
        dfs(node->right);
    }
public:
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
// 迭代版本
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int>result;
        stack<TreeNode*> st;
        auto cur = root;
        while(cur||!st.empty())
        {
            if(cur){
                st.push(cur);
                cur = cur->left;
            }
            else{
                cur = st.top();
                st.pop();
                result.push_back(cur->val);
                cur = cur->right;
            }
        }
        return result;
    }
};
```

### [二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal)

- 按照`左右中`的顺序进行遍历即可

```c++
// 递归版本
class Solution {
    vector<int>ans;
    void dfs(TreeNode* node){
        if(node==nullptr)return;
        dfs(node->left);
        dfs(node->right);
        ans.push_back(node->val);
    }
public:
    vector<int> postorderTraversal(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
// 迭代版本
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*>st;
        if(root)
            st.push(root);
        vector<int>ans;
        while(!st.empty()){
            auto top = st.top();
            st.pop();
            ans.push_back(top->val);
            if(top->left)
                st.push(top->left);
            if(top->right)
                st.push(top->right);
        }
        reverse(ans.begin(),ans.end());
        return ans;
    }
};
```

### [判断是否为平衡二叉树](https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof)

- `-1`代表这个子树不是平衡二叉树

```c++
class Solution {
int getHeight(TreeNode* node){
    if(node==nullptr)return 0;
    int leftH = getHeight(node->left);
    if(leftH==-1)return -1;
    int rightH = getHeight(node->right);
    if(rightH==-1)return -1;
    if(abs(leftH-rightH)>1)return -1;
    return max(leftH,rightH)+1;
}
public:
    bool isBalanced(TreeNode* root) {
        return getHeight(root)!=-1;
    }
};
```

###[相同的树](https://leetcode.cn/problems/same-tree)

```c++
class Solution {
    bool compare(TreeNode* tree1,TreeNode* tree2){
        if(tree1==nullptr&&tree2)return false;
        else if(tree1&&tree2==nullptr)return false;
        else if(tree1==nullptr&&tree2==nullptr)return true;
        else if(tree1->val!=tree2->val)return false;
        bool left = compare(tree1->left,tree2->left);
        if(!left)return false;
        bool right = compare(tree1->right,tree2->right);
        return right;
    }
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        return compare(p,q);
    }
};
```

### [翻转二叉树](https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof)

```c++
class Solution {
    void dfs(TreeNode* node){
        if(node==nullptr)return;
        dfs(node->left);
        dfs(node->right);
        swap(node->left,node->right);
    }
public:
    TreeNode* flipTree(TreeNode* root) {
        dfs(root);
        return root;
    }
};
```

### [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal)

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int> >result;
        queue<TreeNode*>q;
        if(root)
            q.push(root);
        while(!q.empty()){
            int sz = q.size();
            vector<int>temp;
            for(int i = 0;i<sz;i++){
                auto t = q.front();
                q.pop();
                temp.push_back(t->val);
                if(t->left)q.push(t->left);
                if(t->right)q.push(t->right);
            }
            result.push_back(temp);
        }
        return result;
    }
};
```

### [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root==nullptr)return root;
        if(root==p||root==q)return root;
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        if(left&&right)return root;
        if(left==nullptr&&right)return right;
        else if(left&&right==nullptr)return left;
        else return nullptr;
    }
};
```

### [将二叉搜索树转换为排序的双向链表](https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof)

```c++
class Solution {
    void dfs(Node* node){
        if(node==nullptr)return;
        dfs(node->left);
        if(prev==nullptr)head = node;
        else prev->right = node;
        node->left = prev;
        prev = node;
        dfs(node->right);
    }
public:
    Node* treeToDoublyList(Node* root) {
        if(root==nullptr)return nullptr;
        dfs(root);
        head->left = prev;
        prev->right = head;
        return head;
    }
private:
    Node* head,*prev;
};
```

### [从中序与后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal)

```c++
class Solution {
    TreeNode* traversal(vector<int>&inorder,vector<int>&postorder){
        if(postorder.size()==0)return nullptr;
        int rootValue = postorder.back();
        TreeNode* root = new TreeNode(rootValue);
        if(postorder.size()==1)return root;
        int index;
        for(index = 0;index<inorder.size();index++){
            if(inorder[index]==rootValue)break;
        }
        vector<int>leftInorder(inorder.begin(),inorder.begin()+index);
        vector<int>rightInorder(inorder.begin()+index,inorder.end());
        vector<int>leftPostorder(postorder.begin(),postorder.begin()+leftInorder.size());
        vector<int>rightPostorder(postorder.begin()+leftInorder.size(),postorder.end()-1);
        root->left = traversal(leftInorder,leftPostorder);
        root->right = traversal(rightInorder,rightPostorder);
        return root;
    }
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return traversal(inorder,postorder);
    }
};
```

### [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal)

```c++
class Solution {
    TreeNode* tranversal(vector<int>& preorder, vector<int>& inorder){
        if(preorder.size()==0)return nullptr;
        int rootValue = preorder[0];
        TreeNode* root = new TreeNode(rootValue);
        if(preorder.size()==1)return root;
        int index;
        for(index = 0;index<inorder.size();index++)
            if(inorder[index]==rootValue)
                break;
        vector<int>leftInorder(inorder.begin(),inorder.begin()+index);
        vector<int>rightInorder(inorder.begin()+index+1,inorder.end());
        vector<int>leftPreorder(preorder.begin()+1,preorder.begin()+1+leftInorder.size());
        vector<int>rightPreorder(preorder.begin()+1+leftInorder.size(),preorder.end());
        root->left = tranversal(leftPreorder,leftInorder);
        root->right = tranversal(rightPreorder,rightInorder);
        return root;
    }
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return tranversal(preorder,inorder);
    }
};
```

## 搜索树

### 二叉搜索树

二叉搜索树又称二叉排序树，它或者是一棵空树，或者是有以下性质的二叉树

- 若它的左子树不为空，则左子树上的所有的节点都小于根节点的值
- 若它的右子树不为空，则右子树上的所有的节点都大于根节点的值
- 它的左右子树也分别为二叉搜索树

它的实现代码

```c++
#include <iostream>

template <class T>
struct BSTNode
{
	BSTNode(const T& data) :
		_data(data),
		_left(nullptr),
		_right(nullptr)
	{}
	T _data;
	BSTNode<T>* _left;
	BSTNode<T>* _right;
};
template <class T>
class BSTree
{
	typedef BSTNode<T> Node;
	void destory(Node* node)
	{
		if (node == nullptr)return;
		destory(node->_left);
		destory(node->_right);
		delete node;
		node = nullptr;
	}
public:
	BSTree():
		_root(nullptr)
	{}
	~BSTree()
	{
		destory(_root);
	}
	Node* Find(const T& data)
	{
		if (_root == nullptr)return nullptr;
		Node* cur = _root;
		while (cur)
		{
			if (data < cur->_data)cur = cur->_left;
			else if (data > cur->_data)cur = cur->_right;
			else return cur;
		}
		return nullptr;
	}
	bool Insert(const T& data)
	{
		if (_root == nullptr) {
			_root = new Node(data);
			return true;
		}
		Node* cur = _root, * parent = nullptr;
		while (cur)
		{
			if (data < cur->_data) {
				parent = cur;
				cur = cur->_left;
			}
			else if (data > cur->_data) {
				parent = cur;
				cur = cur->_right;
			}
			else {
				return false;
			}
		}
		cur = new Node(data);
		if (data < parent->_data)parent->_left = cur;
		else parent->_right = cur;
		return true;
	}
	bool Erase(const T& data)
	{
		if (_root == nullptr)return false;
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (data < cur->_data) {
				parent = cur;
				cur = cur->_left;
			}
			else if (data > cur->_data) {
				parent = cur;
				cur = cur->_right;
			}
			else {
				// 如果这个节点的左子树是空的,直接用它的右子树来代替这个被删除的节点
				if (cur->_left == nullptr) {
					if (cur == _root) {
						_root = _root->_right;
					}
					else {
						if (cur == parent->_left)
							parent->_left = cur->_right;
						else
							parent->_right = cur->_right;
					}
					delete cur;
				}
                // 如果这个节点的右子树是空的,直接用它的左子树来代替删除这个被删除的节点
				else if (cur->_right == nullptr) {
					if (cur == _root) {
						_root = _root->_left;
					}
					else {
						if (cur == parent->_left)
							parent->_left = cur->_left;
						else
							parent->_right = cur->_left;
					}
					delete cur;
				}
				else {
					// 用右子树的最小节点来替代删除
					Node* rightMinParent = cur;
					Node* rightMin = cur->_right;
					while (rightMin->_left) {
						rightMinParent = rightMin;
						rightMin = rightMin->_left;
					}
					swap(cur->_data, rightMin->_data);
					if (rightMin == rightMinParent->_left)
						rightMinParent->_left = rightMin->_right;
					else
						rightMinParent->_right = rightMin->_right;
					delete rightMin;
				}
				return true;
			}
		}
		return false;
	}
private:
	Node* _root;
};
```

### AVL树

二叉搜索树虽然可以缩短查找效率，但是如果数据有序或者接近有序二叉搜索树将退化为单支树，查找元素相当于在顺序表中搜索元素，效率低下。

**当二叉搜索树中插入新节点后，如果能保证每个节点的左右子树高度之差的绝对值哦不超过1**，即可降低树的高度，从而减少平均搜索长度

一棵AVL树或者是空树，或者是具有以下性质的**二叉搜索树**：

1. **它的左右子树都是AVL树**
2. **左右子树的高度之差（平衡因子）的绝对值不超过1（-1、0.1）**

```c++
#include <iostream>

template <class K,class V>
struct AVLTreeNode
{
	AVLTreeNode<K,V>* _left;
	AVLTreeNode<K, V>* _right;
	AVLTreeNode<K, V>* _parent;
	std::pair<K, V> _kv;
	int _bf;// 平衡因子,为了方便使用，这里直接规定是右子树的高度-左子树的高度
	AVLTreeNode(const std::pair<K, V>& kv) :
		_kv(kv),
		_left(nullptr),
		_right(nullptr),
		_parent(nullptr),
		_bf(0)
	{}
};
template <class K, class V>
class AVLTree
{
	typedef AVLTreeNode<K, V> Node;
public:
	AVLTree() :
		_root(nullptr)
	{}
	bool Insert(const std::pair<K, V>& kv)
	{
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (kv.first < cur->_kv.first) {
				parent = cur;
				cur = cur->_left;
			}
			else if (kv.first > cur->_kv.first) {
				parent = cur;
				cur = cur->_right;
			}
			else {
				return false;
			}
		}
		cur = new Node(kv);
		if (parent == nullptr) {
			// 说明根节点为空
			_root = cur;
			return true;
		}
		cur->_parent = parent;
		if (kv.first < parent->_kv.first)parent->_left = cur;
		else parent->_right = cur;
		// 更新平衡因子
		while (parent)
		{
			if (cur == parent->_left)
				parent->_bf--;
			else
				parent->_bf++;
			if (parent->_bf == 0)break;
			else if (parent->_bf == 1 || parent->_bf == -1) {
				// 说明之前是0,这时候需要继续向上调整
				cur = parent;
				parent = parent->_parent;
			}
			else if (parent->_bf == -2 || parent->_bf == 2) {
				if(parent->_bf==-2&& cur->_bf==-1)
					// 左左类型,需要进行右单旋
					RotateR(parent);
				else if (parent->_bf == 2 && cur->_bf == 1) {
					// 右右类型,需要进行左单旋
					RotateL(parent);
				}
				else if (parent->_bf == -2 && cur->_bf == 1) {
					// 左右类型,需要进行左单旋 右单旋
					RotateLR(parent);
				}
				else if (parent->_bf == 2 && cur->_bf == -1) {
					// 右左类型,需要进行右单旋 左单旋
					RotateRL(parent);
				}
				break;
			}
		}
		return true;
	}
private:
	// 右单旋
	void RotateR(Node* parent)
	{
		Node* subL = parent->_left;
		Node* subLR = subL->_right;
		parent->_left = subLR;
		if (subLR)
			subLR->_parent = parent;
		subL->_right = parent;
		Node* pparent = parent->_parent;
		parent->_parent = subL;

		if (parent == _root)
		{
			_root = subL;
			_root->_parent = nullptr;
		}
		else {
			subL->_parent = pparent;
			if (pparent->_left == parent)pparent->_left = subL;
			else pparent->_right = subL;
		}
		parent->_bf = subL->_bf = 0;
	}
	// 左单旋
	void RotateL(Node* parent)
	{
		Node* subR = parent->_right;
		Node* subRL = subR->_left;
		parent->_right = subRL;
		if (subRL)
			subRL->_parent = parent;
		subR->_left = parent;
		Node* pparent = parent->_parent;
		parent->_parent = subR;

		if (parent == _root) {
			_root = subR;
			_root->_parent = nullptr;
		}
		else {
			subR->_parent = pparent;
			if (parent == pparent->_left)pparent->_left = subR;
			else pparent->_right = subR;
		}
		parent->_bf = subR->_bf = 0;
	}
	// 左右双旋
	void RotateLR(Node* parent)
	{
		Node* subL = parent->_left;
		Node* subLR = subL->_right;
		int bf = subLR->_bf;

		RotateL(parent->_left);
		RotateR(parent);
		if (bf == -1)
		{
			subL->_bf = 0;
			subLR->_bf = 0;
			parent->_bf = 1;
		}
		else if (bf == 1) {
			subL->_bf = -1;
			subLR->_bf = 0;
			parent->_bf = 0;
		}
		else if (bf == 0) {
			subL->_bf = 0;
			subLR->_bf = 0;
			parent->_bf = 0;
		}
	}
	// 右左双旋
	void RotateRL(Node* parent)
	{
		Node* subR = parent->_right;
		Node* subRL = subR->_left;
		int bf = subRL->_bf;

		RotateR(parent->_right);
		RotateL(parent);

		if (bf == -1) {
			parent->_bf = 0;
			subR->_bf = 1;
			subRL->_bf = 0;
		}
		else if (bf == 1) {
			parent->_bf = -1;
			subR->_bf = 0;
			subRL->_bf = 0;
		}
		else if (bf == 0) {
			parent->_bf = 0;
			subR->_bf = 0;
			subRL->_bf = 0;
		}
	}
	Node* _root = nullptr; // 根节点
};
```

### 红黑树

红黑树，是一种二叉搜索树，但在每个节点上增加一个存储为表示节点的颜色，可以是Red或者Black。通过任何一条从根到叶子的路径上哥哥节点的着色方式的限制，红黑树确保没有一个路径比其他路径长出两倍，因此是接近平衡的

**红黑树的性质**

1. **每个节点不是黑色就是红色**
2. **根节点是黑色的**
3. **如果一个节点的红色的，则它的两个孩子节点是黑色的**
4. **对于每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点**
5. **每个叶子结点都是黑色的（此处的叶子结点指的是空节点）**

插入的代码

```c++
#include <iostream>

enum Color
{
	RED,
	BLACK,
};
template <class K,class V>
struct RBTreeNode
{
	RBTreeNode<K, V>* _left;
	RBTreeNode<K, V>* _right;
	RBTreeNode<K, V>* _parent;
	Color _col;
	std::pair<K, V> _kv;
	RBTreeNode(const std::pair<K, V>& kv) :
		_left(nullptr),
		_right(nullptr),
		_parent(nullptr),
		_col(RED),
		_kv(kv)
	{}
};

template <class K,class V>
class RBTree
{
	typedef RBTreeNode<K, V> Node;
public:
	bool Insert(const std::pair<K, V>& kv) {
		Node* cur = _root;
		Node* parent = nullptr;
		while (cur)
		{
			if (kv.first < cur->_kv.first)
			{
				parent = cur;
				cur = cur->_left;
			}
			else if (kv.first > cur->_kv.first)
			{
				parent = cur;
				cur = cur->_right;
			}
			else {
				return false;
			}
		}
		cur = new Node(kv);
		if (parent == nullptr)
		{
			_root = cur;
			_root->_col = BLACK;
			return true;
		}
		if (kv.first < parent->_kv.first)
			parent->_left = cur;
		else
			parent->_right = cur;
		cur->_parent = parent;
		while (parent && parent == RED)
		{
			Node* grandfather = parent->_parent;
			if (parent == grandfather->_left)
			{
				Node* uncle = grandfather->_right;
				if (uncle && uncle->_col == RED) {
					parent->_col = uncle->_col = BLACK;
					grandfather->_col = RED;

					// 继续向上处理
					cur = grandfather;
					parent = cur->_parent;
				}
				else 
				{
					// 叔叔不存在或者叔叔为黑色
					if (cur == parent->_left) {
						RotateR(grandfather);
						parent->_col = BLACK;
						grandfather->_col = RED;
					}
					else {
						RotateL(parent);
						RotateR(grandfather);
						cur->_col = BLACK;
						grandfather->_col = RED;
					}
					break;
				}
			}
			else{
				Node* uncle = grandfather->_left;
				if (uncle && uncle->_col == RED) {
					parent->_col = uncle->_col = BLACK;
					grandfather->_col = RED;

					// 继续向上处理
					cur = grandfather;
					parent = cur->_parent;
				}
				else
				{
					if (cur == parent->_right)
					{
						RotateL(grandfather);
						parent->_col = BLACK;
						grandfather->_col = RED;
					}
					else {
						RotateR(parent);
						RotateL(grandfather);
						cur->_col = BLACK;
						grandfather->_col = RED;
					}
					break;
				}
			}
		}
		_root->_col = BLACK;
		return true;
	}
private:
	// 右旋
	void RotateR(Node* parent)
	{
		Node* subL = parent->_left;
		Node* subLR = subL->_right;
		parent->_left = subLR;
		if (subLR)
			subLR->_parent = parent;
		subL->_right = parent;
		Node* pparent = parent->_parent;
		parent->_parent = subL;

		if (parent == _root)
		{
			_root = subL;
			_root->_parent = nullptr;
		}
		else
		{
			subL->_parent = pparent;
			if (parent == pparent->_left)pparent->_left = subL;
			else pparent->_right = subL;
		}
	}
	// 左旋
	void RotateL(Node* parent)
	{
		Node* subR = parent->_right;
		Node* subRL = subR->_left;
		parent->_right = subRL;
		if (subRL)
			subRL->_parent = parent;
		subR->_left = parent;
		Node* pparent = parent->_parent;
		parent->_parent = subR;
		if (pparent == nullptr)
		{
			_root = subR;
			_root->_parent = nullptr;
		}
		else
		{
			subR->_parent = pparent;
			if (parent == pparent->_left)pparent->_left = subR;
			else pparent->_right = subR;
		}
	}

	Node* _root = nullptr;
};
```

