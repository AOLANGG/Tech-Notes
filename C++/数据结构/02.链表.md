## 链表的概念以及结构

**概念**：链表是一种**物理存储结构上非连续**、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。

**结构**：链表实际上可以分成8中结构，单向、双向，带头、不带头，循环、不循环 两两组合实际上可以组成8中结构。但是实际上我们用得比较多的是带头双向循环链表和不带头单向肺循环链表这两种结构。比如STL中的list就是带头双向循环链表，哈希桶结构下面挂的就是不带头单向非循环链表。

## 顺序表和链表的区别和联系？

| 不同点                   | 顺序表                         | 链表                           |
| ------------------------ | ------------------------------ | ------------------------------ |
| 存储空间上               | 物理上一定连续                 | 逻辑上连续，耽误离殇不一定连续 |
| 随机访问                 | 支持O(1)                       | 不支持：O（N）                 |
| 任意位置插入或者删除元素 | 可能需要搬移元素，效率低O（N） | 只需要修改指针指向             |
| 插入                     | 动态顺序表，空间不够时需要扩容 | 没有容量的概念                 |
| 应用场景                 | 元素高效存储+频繁访问          | 在任意位置插入和删除频繁       |
| 缓存利用率               | 高                             | 低                             |

## 面试题

1. [移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements)

```c++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode dummy(0,head);
        auto cur = &dummy;
        while(cur->next){
            auto next = cur->next;
            if(next->val==val){
                cur->next=next->next;
                delete next;
            }else{
                cur = next;
            }
        }
        return dummy.next;
    }
};
```

2. [反转链表](https://leetcode.cn/problems/reverse-linked-list)

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head,*prev = nullptr;
        while(cur){
            ListNode* next = cur->next;
            cur->next=prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
};
```

3. [链表的中间节点](https://leetcode.cn/problems/middle-of-the-linked-list)

```c++
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* fast = head,*slow = head;
        while(fast&&fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

4. [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1==nullptr)return list2;
        if(list2==nullptr)return list1;
        if(list1->val<list2->val){
            list1->next = mergeTwoLists(list1->next,list2);
            return list1;
        }
        list2->next=mergeTwoLists(list1,list2->next);
        return list2;
    }
};
```

5. [链表分割](https://www.nowcoder.com/share/jump/8978549211759487208769)

```c++
class Partition {
  public:
    ListNode* partition(ListNode* pHead, int x) {
        ListNode dummy1(-1), dummy2(-1);
        auto cur1 = &dummy1, cur2 = &dummy2;

        while (pHead) {
            // 保存下一个节点
            ListNode* next = pHead->next;
            // 断开当前节点与后续节点的连接
            pHead->next = nullptr;

            if (pHead->val < x) { // 注意：应该是 < x，不是 <= x
                cur1->next = pHead;
                cur1 = cur1->next;
            } else {
                cur2->next = pHead;
                cur2 = cur2->next;
            }
            pHead = next;
        }

        // 连接两个链表
        cur1->next = dummy2.next;
        // 确保第二个链表的尾部next为nullptr
        cur2->next = nullptr;

        return dummy1.next;
    }
};
```

6. [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists)

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* cur1 = headA,*cur2 = headB;
        bool flag1 = true,flag2 = true;
        while(cur1&&cur2){
            if(cur1==cur2)return cur1;
            cur1=cur1->next;
            cur2=cur2->next;
            if(cur1==nullptr&&flag1){
                flag1 = false;
                cur1 = headB;
            }
            if(cur2==nullptr&&flag2){
                flag2 = false;
                cur2 = headA;
            }
        }
        return nullptr;
    }
};
```

7. [环形链表](https://leetcode.cn/problems/linked-list-cycle)

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* fast = head,*slow = head;
        while(fast&&fast->next){
            fast=fast->next->next;
            slow=slow->next;
            if(fast==slow)return true;
        }
        return false;
    }
};
```

8. [环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii)

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head,*slow = head;
        while(fast&&fast->next){
            fast = fast->next->next;
            slow = slow->next;
            if(fast==slow){
                while(head!=slow){
                    head = head->next;
                    slow = slow->next;
                }
                return head;
            }
        }
        return nullptr;
    }
};
```

9. [随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer)

**哈希表**

```c++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*,Node*>MP;
        auto cur = head;
        while(cur){
            MP[cur] = new Node(cur->val);
            cur = cur->next;
        }
        cur = head;
        while(cur)
        {
            MP[cur]->next = MP[cur->next];
            MP[cur]->random = MP[cur->random];
            cur = cur->next;
        }
        return MP[head];
    }
};
```

**在原链表上进行复制**

```c++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head==nullptr)return nullptr;

        // 复制每个节点，把新的节点插入到原节点的后面
        for(Node* cur = head;cur;cur = cur->next->next)
        {
            cur->next = new Node(cur->val,cur->next,nullptr);
        }
        for(Node* cur = head;cur;cur = cur->next->next)
            if(cur->random)
                cur->next->random = cur->random->next;
        // 把交错链表分离成两个链表
        Node* new_head = head->next;
        Node* cur = head;
        for(;cur->next->next;cur = cur->next){
            Node* copy = cur->next;
            cur->next = copy->next;
            copy->next=copy->next->next;
        }
        cur->next = nullptr;
        return new_head;
    }
};
```

