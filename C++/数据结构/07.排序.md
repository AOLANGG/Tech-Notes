## 插入排序

### 直接插入排序

在待排序的元素中，假设前`n-1`个元素已经有序，现将第`n`个元素插入到前面已经拍好的序列中，使得前`n`个元素有序。按照此法对所有元素进行插入，直到整个序列有序。

但是我们并不能确定待排元素究竟哪一部分是有序的，依次将其后面的元素插入到这个有序序列中，直到整个序列有序为止。

![](https://i-blog.csdnimg.cn/blog_migrate/7b23514289fd4c0fa3eeb9343a58baad.gif)

```c++
void InsertSort(int* a, int n)
{
	for (int i = 1; i < n; i++)
	{
		if (a[i] < a[i - 1])
		{
			int temp = a[i];
			int j;
			for (j = i - 1; j >= 0 && a[j] >= temp; j--)
			{
				a[j + 1] = a[j];
			}
			a[j + 1] = temp;
		}
	}
}
```



### 希尔排序

**思路**

1. 插入排序的优化版本，有一个预排序的过程。让大的数快速跳到后面，小的数快读跳到前面。
2. 使待排序接近有序，然后在读该序列进行一次插入排序
3. 相当于把直接插入排序中的1换成`gap`而已

![img](https://i-blog.csdnimg.cn/blog_migrate/93fae629acfc03414c2645e4c160ff01.gif)

```c++
void ShellSort(int* a, int n)
{
	int gap = n;
	while (gap > 1)
	{
		gap = gap / 3 + 1;
		for (int i = gap; i < n; i++)
		{
			if (a[i] < a[i - gap])
			{
				int temp = a[i];
				int j;
				for (j = i - gap; j >= 0&&a[j]>=temp; j -= gap)
				{
					a[j + gap] = a[j];
				}
				a[j+gap] = temp;
			}
		}
	}
}
```



## 选择排序

### 直接选择排序

**思路**

1. 内层循环一趟找出最小值的下标，与第一个数交换。重复找小，交换的两个操作
2. 实际上我们可以一趟选出两个值，一个最大值和一个最小值，然后将其放在序列的开头和末尾，这样的效率更高，但是事件复杂度还是$O(N^2)$

![img](https://i-blog.csdnimg.cn/blog_migrate/5d50f9a16c5bb410be12eee453d31ef2.gif)

```c++
void SelectSort(int* a, int n)
{
	for (int i = 0; i < n; i++)
	{
		int min = i;
		int j;
		for (j = i; j < n; j++)
		{
			if (a[j] < a[min])min = j;
		}
		swap(a[i], a[min]);
	}
}
```

### 堆排序

堆排序是利用堆积树这种数据结构所设计的一种排序的算法，它是选择排序的一种，通过堆来实现。

堆分为大堆和小堆，大堆就是所有的父亲节点大于儿子节点，小堆就是所有的父亲节点大于儿子节点

值得一提的是，排升序的时候要建一个大堆，排降序的时候要建一个小堆。

堆排序分为两个大步骤，建堆和向下调整

![img](https://i-blog.csdnimg.cn/blog_migrate/f81018d0dccacef5e724a0c54499d3cc.gif)

```c++
void AdjustDown(int* a, int n, int root)
{
	int parent = root;
	int child = parent * 2 + 1;
	while (child < n)
	{
		if (child + 1 < n && a[child] < a[child + 1])
		{
			child++;
		}
		if (a[child] > a[parent])
		{
			swap(a[child], a[parent]);
			parent = child;
			child = child * 2 + 1;
		}
		else
			break;
	}
}
void Heapsort(int* a, int n)
{
	for (int i = (n - 1 - 1) / 2; i >= 0; i--)
	{
		AdjustDown(a, n, i);
	}
	int end = n - 1;
	while (end > 0)
	{
		swap(a[0], a[end]);
		AdjustDown(a, end, 0);
		end--;
	}
}
```

## 交换排序

### 冒泡排序

**思路**：通过对待排序序列从前向后，依次对相邻两个元素的值进行两两比较，若发现前一个数大于后一个数则交换，使值较大的元素逐渐从前向后移动。

```c++
void BubbleSort(int* a, int n)
{
	int end = n - 1;
	while (end)
	{
		bool exchange = false;
		for (int i = 0; i < end; i++)
		{
			if (a[i] > a[i + 1])
			{
				swap(a[i], a[i + 1]);
				exchange = true;
			}
		}
		if (exchange == false)break;
	}
}
```



### 快速排序

#### 挖坑法

**思想**

记第一个数为key，要调整key的位置，使得key左边都要比key小，右边的书都比key的大

**步骤**

选出一个数据存放在key变量中，在该数据位置形成一个坑

定义一个`left`和`right`从左向右走。`left`从左向右走（遇到大于key的值停下来），`right`从右向左走（遇到小于key的值停下来）。

```c++
void QuickSort(int* a, int left, int right)
{
	if (left >= right)return;
	int begin = left, end = right;
	int key = a[begin];
	int pivot = begin;
	while (begin < end)
	{
		// 右边找小
		while (begin < end && a[end] >= key)
			end--;
		a[pivot] = a[end];
		pivot = end;
		// 左边找大 
		while (begin < end && a[begin] <= key)
			begin++;
		a[pivot] = a[begin];
		pivot = begin;
	}
	a[pivot] = key;
	QuickSort(a, left, pivot - 1);
	QuickSort(a, pivot + 1, right);
}
```

### 左右指针法

**思路**

1. 选出一个key，一般是最左边或者最右边
2. 定义一个begin和一个end，begin从左向右走，end从右向左走。需要注意的是：若选择最左边的数据作为key，则需要end先走；若选择最右边的数据作为key，则需要bengin先走）
3. 在走的过程中，若end遇到小于key的数，则停下，begin开始走，直到begin遇到一个大于key的数时，将begin和right的内容交换，end再次开始走，如此进行下去，直到begin和end最终相遇，此时将相遇点的内容与key交换即可。（选取最左边的值作为key）
4. 此时key的左边都是小于key的数，key的右边都是大于key的数
5. 将key的左序列和右序列再次进行这种单趟排序，如此反复操作下去，直到左右序列只有一个数据，或是左右序列不存在时

```c++
void QuickSort(int* a, int left, int right)
{
	if (left >= right)return;
	int begin = left, end = right;
	int key = begin;
	while (begin < end)
	{
		while (begin < end && a[end] >= a[key])
			end--;
		while (begin < end && a[begin] <= a[key])
			begin++;
		swap(a[begin], a[end]);
	}
	swap(a[begin], a[key]);
	QuickSort(a, left, begin - 1);
	QuickSort(a, begin + 1, right);
}
```

### 三数取中法

三数取中法：取左端、中间、右端三个数，然后进行比较，将中值数当做key

否则有序时时间复杂度为$O(N^2)$

**这里我套用挖坑法**

```c++
```



## 归并排序

![img](https://i-blog.csdnimg.cn/blog_migrate/20bca66489ea8615dfa2c44c05820c4f.png)

![img](https://i-blog.csdnimg.cn/blog_migrate/17847222181095acdab5c4a31b307b16.gif)

需要开一个_MergeSort,而不是直接在MergeSort中直接递归，是因为MergeSort中有一个malloc

归并排序很像二叉树中的后序思想，先递归，递归到最后的时候再合并

```c++
void MergeSort(int* a, int left, int right, int* temp)
{
    if (left >= right)return;
    int mid = (left + right) / 2;
    MergeSort(a, left, mid, temp);
    MergeSort(a, mid + 1, right, temp);
    int i = left, j = mid + 1, idx = 0;
    while (i <= mid && j <= right)
    {
        if (a[i] < a[j])temp[idx++] = a[i++];
        else temp[idx++] = a[j++];
    }
    while (i <= mid)temp[idx++] = a[i++];
    while (j <= right)temp[idx++] = a[j++];
    for (i = left, j = 0; i <= right; i++, j++)
    {
        a[i] = temp[j];
    }

}
```

