## 常见面试题

### 旋转数组



### 删除有序数组中的重复项

- 用两个指针`left`，`right`，从左向右进行遍历
- `right`寻找不重复的一项，填充到`left`位置处
- 最后`left`就是数组的大小

```python
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int n = nums.size();
        int left = 1,right = 1;
        while(right<n){
            if(nums[right]!=nums[right-1]){
                nums[left++]=nums[right];
            }
            right++;
        }
        return left;
    }
};
```



### 数组形式的整数加法



```cpp
class Solution {
public:
    vector<int> addToArrayForm(vector<int>& num, int k) {
        reverse(num.begin(), num.end());
        int n = num.size();
        int carry = 0;
        vector<int> result;
        
        // 先处理num的每一位和k的对应位
        for (int i = 0; i < n; ++i) {
            int temp = num[i] + (k % 10) + carry;
            k /= 10;
            result.push_back(temp % 10);
            carry = temp / 10;
        }
        
        // 处理k剩余的位和可能的进位
        while (k > 0 || carry > 0) {
            int temp = (k % 10) + carry;
            result.push_back(temp % 10);
            carry = temp / 10;
            k /= 10;
        }
        
        reverse(result.begin(), result.end());
        return result;
    }
};
```

### 乘积最大的子数组

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int>f(n);
        auto g = f;
        int ret = f[0]=g[0]=nums[0];
        for(int i = 1;i<n;i++){
            f[i]=max(nums[i],max(f[i-1]*nums[i],g[i-1]*nums[i]));
            g[i]=min(nums[i],min(f[i-1]*nums[i],g[i-1]*nums[i]));
            ret = max(ret,f[i]);
        }
        return ret;
    }
};
```

### 多数元素

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int cadidata = 0,count = 0;
        for(int&x:nums){
            if(count==0)cadidata=x;
            count+=(cadidata==x?1:-1);
        }
        return cadidata;
    }
};
```

### 存在重复元素

```cpp
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
        unordered_map<int,bool>vis;
        for(int&x:nums){
            if(vis.count(x))return true;
            vis[x]=true;
        }
        return false;
    }
};
```

### 搜索二维矩阵

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        // 从右上角开始搜索，因为这样搜索可以夹逼
        int m = matrix.size(),n = matrix[0].size();
        int row = 0,col = n-1;
        while(row<m&&col>=0){
            if(matrix[row][col]==target){
                return true;
            }
            if(matrix[row][col]<target)row++;
            else col--;
        }
        return false;
    }
};
```

