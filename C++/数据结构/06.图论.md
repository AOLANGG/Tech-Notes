## 图的基本概念

图是由顶点集合以及顶点之间的关系组成的一种数据结构：G=（V,E），其中：顶点集合V={x|x属于某个数据对象集}是有穷非空集合E={（x，y）| x，y属于V}或者E = {<x, y>|x,y属于V && Path(x, y)}是顶点间关系的有穷集合，也叫做边的集合。

顶点和边：**图中节点称为顶点**，第`i`个顶点记作`vi`。**两个顶点`vi`和`vj`之间有一条边**，图中的第`k`条边叫做`ek`，`ek=(vi,vj)`或者`<vi,vj>`

有向图和无向图：在有向图中，顶点对<x, y>是有序的，顶点对<x，y>称为顶点x到顶点y的一条边(弧)，<x, y>和<y, x>是两条不同的边。在无向图中，顶点对(x, y)是无序的，顶点对(x,y)称为顶点x和顶点y相关联的一条边，这条边没有特定方向，(x, y)和(y，x)是同一条边

完全图：在**有n个顶点的无向图中，若有n*(n-1)/2条边**，即**任意两个顶点之间有且仅有一条边**，则称此图为**无向完全图**；如果有**n(n-1)条边，即任意两个顶点之间有且仅有方向相反的边**，则称此图为**有向完全图**。 

邻接顶点：在**无向图中G中，若（u，v）是E（G）的一条边，则称u和v互为邻接顶点**；在**有向图中，若<u，v>是E（G）中的一条边，则顶点u邻接到v顶点v邻接自顶点u，并称边<u, v>与顶点u和顶点v相关联**

顶点的度：顶点v的度是指与它相关联的边的条数，记作deg(v)。在有向图中，顶点的度等于该顶点的入度与出度之和，其中顶点v的入度是以v为终点的有向边的条数，记作indev(v);顶点v的出度是以v为起始点的有向边的条数，记作outdev(v)。因此：dev(v) = indev(v) + outdev(v)。注意：对于无向图，顶点的度等于该顶点的入度和出度，即dev(v) = indev(v) =outdev(v)。

路径：在图G = (V， E)中，若从顶点vi出发有一组边使其可到达顶点vj，则称顶点vi到顶点vj的顶点序列为从顶点vi到顶点vj的路径。

路径长度：对于不带权的图，一条路径的路径长度是指该路径上的边的条数；对于带权的图，一条路径的长度是指该路径上各个边权值的总和

简单路径与回路：若路径上各顶点v1，v2，v3，…，vm均不重复，则称这样的路径为简单路径。若路径上第一个顶点v1和最后一个顶点vm重合，则称这样的路径为回路或环。

子图：设图G = {V, E}和图G1 = {V1，E1}，若V1属于V且E1属于E，则称G1是G的子图

连通图：在无向图中，若从顶点v1到顶点v2有路径，则称顶点v1与顶点v2是连通的。如果图中任意一对顶点都是联通的，则称此图为连通图

强连通图：在有向图中，若在每一对顶点vi和vj之间都存在一条从vi到vj的路径，也存在一条从vj到vi的路径，则称此图为强连通图

生成树：一个连通图的最小连通子图称作改图的生成树。有n个顶点的连通图的生成树有n个顶点和n-1条边

## 图的存储结构

### 邻接矩阵

因为节点与节点之间的关系就是连通的与否，即为0或者1，因此**邻接矩阵：先用一个数组将顶点保存，然后用矩阵来表示节点和节点之间的关系**

![img](https://i-blog.csdnimg.cn/direct/2baf5233ad7d4f76b028c65b4c17a1ed.png)

1. **无向图的邻接矩阵是对称的，第`i`行元素之和，就是顶点`i`的度。有向图的邻接矩阵则不一定对称，第`i`元素之和是顶点`i`的出（入）度**
2. 如果边带有权值，并且两个节点之间是连通的，如果两个顶点不同，则用无穷大来代替。

3. 用邻接矩阵存储图的有点是能够快速知道两个顶点是否连通，缺点是如果顶点比较多，边比较少，矩阵中存储了大量的0成为系数矩阵，比较浪费空间

```c++
#include <iostream>
#include <vector>
#include <map>
using namespace std;

template<class V,class W,W MAX_W=INT_MAX,bool Direction=false>
class Graph
{
public:
	typedef Graph<V, W, MAX_W, Direction> Self;
	Graph() = default;
	Graph(const V* vertexs, size_t n)
	{
		_vertexs.reserve(n);
		for (int i = 0; i < n; i++)
		{
			_vertexs.push_back(vertexs[i]);
			_vIndexMap.insert({ vertexs[i],i });
		}
		_matrix.resize(n);
		for (auto& e : _matrix)
			e.resize(n,MAX_W);
	}
	size_t GetVertexIndex(const V& v)
	{
		auto ret = _vIndexMap.find(v);
		if (ret != _vIndexMap.end())
			return ret->second;
		else
		{
			throw invalid_argument("不存在的顶点");
			return -1;
		}
	}
	void _AddEdge(size_t srci, size_t dsti, const W& w)
	{
		_matrix[srci][dsti] = w;
		if (Direction)
		{
			_matrix[dsti][srci] = w;
		}
	}
	void AddEdge(const V& src, const V& dst, const W& w)
	{
		size_t srci = GetVertexIndex(src);
		size_t dsti = GetVertexIndex(dst);
		_AddEdge(srci, dsti, w);
	}
	
	void Print()
	{
		// 打印顶点和下标映射关系
		for (size_t i = 0; i < _vertexs.size(); ++i)
		{
			cout << _vertexs[i] << "-" << i << " ";
		}
		cout << endl << endl;
		cout << " ";
		for (size_t i = 0; i < _vertexs.size(); ++i)
		{
			cout << i << " ";
		}
		cout << endl;
		// 打印矩阵
		for (size_t i = 0; i < _matrix.size(); ++i)
		{
			cout << i << " ";
			for (size_t j = 0; j < _matrix[i].size(); ++j)
			{
				if (_matrix[i][j] != MAX_W)
					cout << _matrix[i][j] << " ";
				else
					cout << "#" << " ";
			}
			cout << endl;
		}
		cout << endl << endl;
		// 打印所有的边
		for (size_t i = 0; i < _matrix.size(); ++i)
		{
			for (size_t j = 0; j < _matrix[i].size(); ++j)
			{
				if (i < j && _matrix[i][j] != MAX_W)
				{
					cout << _vertexs[i] << "-" << _vertexs[j] << ":" <<
						_matrix[i][j] << endl;
				}
			}
		}
	}
private:
	map<V, size_t> _vIndexMap;// 把顶点映射到下标
	vector<V> _vertexs;// 顶点集合
	vector<vector<W>> _matrix; // 存储边集合的矩阵
};


int main()
{
	Graph<char, int, INT_MAX, true> g("0123", 4);
	g.AddEdge('0', '1', 1);
	g.AddEdge('0', '3', 4);
	g.AddEdge('1', '3', 2);
	g.AddEdge('1', '2', 9);
	g.AddEdge('2', '3', 8);
	g.AddEdge('2', '1', 5);
	g.AddEdge('2', '0', 3);
	g.AddEdge('3', '2', 6);
	g.Print();
	return 0;
}
```

### 邻接表

邻接表：使用数组表示顶点的集合，**使用链表表示边的关系**。

![img](https://i-blog.csdnimg.cn/direct/96074b8a2d104bab85981aa233af8ed9.png)

注意：**无向图中同一条边在邻接表中出现了两次。如果想知道顶点vi的度，只需要知道顶点vi边链表集合中节点的数目即可**

![img](https://i-blog.csdnimg.cn/direct/04bd593a2c9c408e8bb1111bd989e1ee.png)

注意：有向图每个边在邻接表中只出现一次，与顶点vi对应的玲姐表所含节点的个数，就是该顶点的出度；要得到vi顶点的入度，必须检测其他所有顶点对应的边链表，看看有多少边顶点的dst取值是i

```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

template <class W>
struct LinkEdge
{
	int _srcIndex;
	int _dstIndex;
	W _w;
	LinkEdge<W>* _next;
	LinkEdge(const W& w) :
		_srcIndex(-1),
		_dstIndex(-1),
		_w(w),
		_next(nullptr)
	{}
};
template <class V,class W,bool Direction = false>
class Graph
{
	typedef LinkEdge<W> Edge;
public:
	Graph(const V* vertexs, size_t n)
	{
		_vertexs.reserve(n);
		for (int i = 0; i < n; i++)
		{
			_vertexs.push_back(vertexs[i]);
			_vIndexMap.insert({ _vertexs[i],i });
		}
		_linkTable.resize(n, nullptr);
	}
	size_t GetVertexsIndex(const V& v)
	{
		auto ret = _vIndexMap.find(v);
		if (ret != _vIndexMap.end())
		{
			return ret->second;
		}
		throw invalid_argument("不存在的顶点");
		return -1;
	}
	void AddEdge(const V& src, const V& dst, const W& w)
	{
		size_t srci = GetVertexsIndex(src);
		size_t dsti = GetVertexsIndex(dst);
		
		Edge* sd_edge = new Edge(w);
		sd_edge->_srcIndex = srci;
		sd_edge->_dstIndex = dsti;
		sd_edge->_next = _linkTable[srci];
		_linkTable[srci] = sd_edge;
		if (Direction == false)
		{
			Edge* ds_edge = new Edge(w);
			ds_edge->_srcIndex = dsti;
			ds_edge->_dstIndex = srci;
			ds_edge->_next = _linkTable[dsti];
			_linkTable[dsti] = ds_edge;
		}
	}
private:
	map<V, int> _vIndexMap;
	vector<V> _vertexs; // 顶点集合
	vector<Edge*> _linkTable; // 边的集合的邻接表
};
```

## 图的遍历

**这里使用邻接矩阵为例**

### 广度优先搜索

```c++
void BFS(const V& src)
{
    size_t srci = GetVertexIndex(src);
    queue<int>q;
    vector<bool>visited(_vertexs.size(),false);
    visited[srci] = true;
    q.push(srci);
    while(!q.empty())
    {
        int front = q.front();
        q.pop();
        cout<<front<<":"<<_vertexs[front]<<endl;
        for(int i = 0;i<n;i++)
        {
            if(_matrix[front][i]!=MAX_W&&visited[i]==false)
            {
                visited[i] = true;
                q.push(i);
            }
        }
    }
}
```



### 深度优先搜索

```c++
void _DFS(size_t srci,vector<bool>& visited)
{
    std::cout<<srci<<":"<<_vertexs[srci]<<std::endl;
    visited[srci] = true;
    for(int i = 0;i<_vertexs.size();i++)
    {
        if(_matrix[srci][i]!=MAX_W && visited[i]==false)
        {
            _DFS(i,visited);
        }
    }
}
void DFS(const V& src)
{
    size_t srci = GetVertexIndex(src);
    vector<bool>visited(_vertexs.size(),false);
    _DFS(srci,visited);
}
```

## 最小生成树

连通图中的每一颗生成树，都是原图的一个极大无环子图：**从其中删去任何一条边，生成树就不再连通；反之，在其中引入任何一条新边，都会形成回路。**

**若连通图由`n`个顶点组成，则其生成树必含`n`个顶点和`n-1`条边**

1. 只能使用图中的边来构造最小生成树
2. 只能使用恰好`n-1`条边来连接图中的`n`个顶点
3. 选用的`n-1`条边不能构成回路

构造最小生成树的方法：**kruskal和Prim算法**。这两个算法都采用了**逐步求解的贪心策略**。

### kruskal算法

任给一个有`n`个顶点的连通网络N={V，E}

首先构造一个由这`n`个顶点组成、不含任何边的图，其中每个顶点自成一个连通分量，其次不断从E中取出权值最小的一条边，若该边的两个顶点来自不同的连通分量，则将此边加入到G中。如此重复，直到所有顶点在同一个连通分量上为止。

核心：**每次迭代时，选出一条具有最小权值，且两端点不在同意连通分量上的边，加入生成树**

```c++
struct Edge
{
    size_t _srci;
    size_t _dsti;
    W _w;
    Edge(size_t srci,size_t dsti,const W& w):
    _srci(srci),
    _dsti(dsti),
    _w(w)
    {}
    bool operator>(const Edge& e)const
    {
        return _w > e._w;
    }
};
W kruskal(Self& minTree)
{
    size_t n = _vertexs.size();
    minTree._vertexs = _vertexs;
    minTree._indexMap = _indexMap;
    minTree._matrix.resize(n,vector<W>(n,MAX_W));

    priority_queue<Edge,vector<Edge>,greater<Edge> >minque;
    for(int i = 0;i<n;i++)
    {
        for(int j = i+1;j<n;j++)
        {
            if(_matrix[i][j]!=MAX_W)
                minque.push(Edge(i,j,_matrix[i][j]));
        }
    }
    // 连接的边的数量
    size_t size = 0;
    W totalw = W();
    UnionFindSet ufs(n);

    while(!minque.empty())
    {
        Edge min = minque.top();
        minque.pop();
        if(!ufs.Inset(min._srci,min._dsti))
        {
            cout<<_vertexs[min._srci]<<"->"<<_vertexs[min._dsti];
            minTree._addEdge(min._srci,min._dsti);
            ++size;
            ufs.Union(min._srci,min._dsti);
            totalw += min._w;
            if (size == n - 1)
                break;
        }
    }
    if(size == n-1)
        return totalw;
    return W();
}
```

### Prim算法

Prime算法的工作原理与Dijkstra最短路径算法相似。Prim算法所具有的一个性质是集合A中的边总是构成一棵树。这颗树从任意一个根节点r开始，一直昌长大到覆盖V的所有节点为止。算法每一步在连接集合A和集合A之外的节点的所有边种，选择一条轻量级边加入到A中。这条规则所加入的边都是对A安全的边。因此，当算法终止的时候，A中的边杏花村呢个一棵最小生成树。本策略也属于贪心策略，因为每一步所加入的边都必须是使树的总权重增加量最小的边。

```c++
W Prim(Self& minTree,const V& src)
{
    size_t n = _vertexs.size();
    size_t srci = GetVertexIndex(src);
    minTree._vertexs = _vertexs;
    minTree._indexMap = _indexMap;
    minTree._matrix.resize(n,vector<W>(n,MAX_W));
    vector<bool>X(n,false);
    X[srci] = true;
    std::priority_queue<Edge,vector<Edge>,greater<Edge>>minque;
    for(int i = 0;i<n;i++)
    {
        if(_matrix[srci][i]!=MAX_W)
            minque.push(Edge(srci,i,_matrix[srci][i]));
    }
    size_t sz = 0;
    W totalw = W();
    while(!minque.empty())
    {
        Edge min = minque.top();
        minque.pop();
        if(!X[min._dsti])
        {
            minTree._addEdge(min._srci,min._dsti,min._w);
            sz++;
            totalw += min._w;
            if(sz == n-1)
            {
                break;
            }
            X[min._dsti]=true;
            for(int i = 0;i<n;i++)
            {
                if(!X[i]&&_matrix[min._dsti][i]!=MAX_W)
                    minque.emplace(min._dsti,i,_matrix[min._dsti][i]);
            }
        }
    }
    if(sz == n-1)
    {
        return totalw;
    }
    return W();
}
```

## 最短路径

最短路径问题：从在带权有向图G中的某一顶点出发，找到一条通往另一顶点的最短路径，最短也就是沿路径各边的权值综合达到最小。

### dijkstra算法

单源最短路径问题：给定一个图G = ( V ， E ) G=(V，E)G=(V，E)，求源结点s ∈ V s∈Vs∈V到图中每个结点v ∈ V v∈Vv∈V的最短路径。Dijkstra算法适用于解决带权重的有向图的单源最短路径问题，**同时要求图中所有边的权值非负**。一般在求解最短路径的时候都是知一个起点和一个终点，所以使用Dijkstra算法求解之后也就得到了所需起点到终点的最短路径。

针对一个带权有向图G，将所有的节点分为两组S和Q，S是已经确定最短路径的节点集合，在初始化时为空（初始化就可以将源节点s放入，毕竟源节点到自己的代价是0），Q是其余未确定最短路径的节点集合，**每次从Q中找出一个起点到该节点代价最小的节点u，把节点u从Q中移除，放入到s中，对u的每个相邻节点进行松弛操作**。松弛即对每个相邻节点v，判断源节点s到节点u的代码与u到v的代价之和是否比原来s到v的代价更小，如果代价比原来小则将s到v的代价更新为s到u，u到v的代价之和，否则维持原样。入池循环知道集合Q为空，即所有节点都已经查找过一遍，并且确定了最短路径，至于一些起点到达不了的节点在算法循环后其代价仍未初始设定的值，不发生变化。Dijkstra算法每次都是选择v-s中最小的路径节点类更新，并且放入s中，所以使用的是贪心策略。

**Dijkstra算法存在的问题是不支持图中带负权路径，如果带有负权路径，则可能找不到一些路径的最短路径**

```c++
void Dijkstra(const V& src, vector<int>& dist, vector<int>& pPath)
{
    size_t srci = GetVertexIndex(src);
    size_t n = _vertexs.size();
    dist, resize(n, MAX_W);
    pPath.resize(n, -1);
    vector<bool> S(n);
    dist[srci] = 0;

    for (size_t v = 0; v < n; v++)
    {
        dist[v] = _matrix[srci][v];
        if (dist[v] != MAX_W)
        {
            pPath[v] = srci;
        }
    }
    for (size_t j = 0; j < n - 1; j++)
    {
        int u = -1;
        W minDist = MAX_W;
        for (size_t i = 0; i < n; i++)
        {
            if (!S[i] && dist[i] < minDist)
            {
                u = i;
                minDist = dist[i];
            }
        }
        // 说明这个图不是连通图
        if (u == -1)
        {
            break;
        }
        S[u] = true;
        for (size_t v = 0; v < n; v++)
        {
            if (!S[v] && _matrix[u][v] != MAX_W && dist[v] > dist[u] + _matrix[u][v])
            {
                dist[v] = dist[u] + _matrix[u][v];
                pPath[v] = u;
            }
        }
    }
}
```

### 单源最短路径-Bellman-Ford算法

Dijkstra算法只能用来解决正权图的单源最短路径问题，有些题目会出现负权图。这时这个算法就不能帮助我们解决问题了，而bellman-ford算法可以解决负权图的单源最短路径问题。它的优点是可以解决负权边的单源最短路径问题，而且可以用来判断是否有负权回路。他也有明显的缺点，它的时间复杂度是O(N*E)（N是点数，E是边数）普遍是要高于普通版的Dijkstra算法。

```c++
bool Bellman_ford(const V&src,vector<W>& dist,vector<int>& parentPath)
{
    size_t n = _vertexs.size();
    size_t srci = GetVertexIndex(src);

    dist.resize(n, MAX_W);
    parentPath.resize(n, -1);
    dist[srci] = W();
    for (size_t k = 0; k < n - 1; k++)
    {
        bool exchange = false;
        for (size_t i = 0; i < n; i++)
        {
            for (size_t j = 0; j < n; j++)
            {
                // srci -> i，i->j
                if (_matrix[i][j] != MAX_W && dist[j] > dist[i] + _matrix[i][j])
                {
                    dist[j] = dist[i] + _matrix[i][j];
                    parentPath[j] = i;
                    exchange = true;
                }
            }
        }

        if (exchange == false)break;
    }
    for (size_t i = 0; i < n; i++)
    {
        for (size_t j = 0; j < n; j++)
        {
            if (_matrix[i][j] != MAX_W && dist[j] > dist[i] + _matrix[i][j])
            {
                return false;
            }
        }
    }
    return true;
}
```

### 多远最短路径-Floyd-Warshall算法

Floyd-warshall算法是解决任意两点间的最短路径的一种算法

Floyd算法考虑的E是一条最短路径的中间节点，即简单路径p={v1,v2,…,vn}上除v1和vn的任意节点。

设k是p的一个中间节点，那么从i到j的最短路径p就被分成i到k和k到j的两段最短路径p1，p2。p1是从i到k且中间节点属于{1，2，…，k-1}取得的一条最短路径。p2是从k到j且中间节点属于{1，2，…，k-1}取得的一条最短路径

![img](https://i-blog.csdnimg.cn/direct/ba0bbae9a3d643b387a5de46b83573cc.png)

即Floyd算法本质是三维动态规划，D[i][j][k]表示从点i到点j只经过0到k个点最短路径，然后建立起转移方程，然后通过空间优化，优化掉最后一维度，变成一个最短路径的迭代算法，最后即得到所以点的最短路

```c++
void FloydWarshall(std::vector<std::vector<W>>& vvDist, std::vector<std::vector<int>>& vvpPath)
		{
			size_t n = _vertexs.size();
			vvDist.resize(n);
			vvpPath.resize(n);

			// 初始化权值和路径矩阵
			for (size_t i = 0; i < n; ++i)
			{
				vvDist[i].resize(n, max_w);
				vvpPath[i].resize(n, -1);
			}

			// 直接相连的边更新一下
			for (size_t i = 0; i < n; ++i)
			{
				for (size_t j = 0; j < n; ++j)
				{
					if (_matrix[i][j] != max_w)
					{
						vvDist[i][j] = _matrix[i][j];
						vvpPath[i][j] = i;
					}

					if (i == j)
					{
						vvDist[i][j] = W();
					}
				}
			}

			// abcdef  a {} f ||  b {} c
			// 最短路径的更新i-> {其他顶点} ->j
			for (size_t k = 0; k < n; ++k)
			{
				for (size_t i = 0; i < n; ++i)
				{
					for (size_t j = 0; j < n; ++j)
					{
						// k 作为的中间点尝试去更新i->j的路径
						if (vvDist[i][k] != max_w && vvDist[k][j] != max_w
							&& vvDist[i][k] + vvDist[k][j] < vvDist[i][j])
						{
							vvDist[i][j] = vvDist[i][k] + vvDist[k][j];

							// 找跟j相连的上一个邻接顶点
							// 如果k->j 直接相连，上一个点就k，vvpPath[k][j]存就是k
							// 如果k->j 没有直接相连，k->...->x->j，vvpPath[k][j]存就是x

							vvpPath[i][j] = vvpPath[k][j];
						}
					}
				}

				// 打印权值和路径矩阵观察数据
				for (size_t i = 0; i < n; ++i)
				{
					for (size_t j = 0; j < n; ++j)
					{
						if (vvDist[i][j] == max_w)
						{
							//cout << "*" << " ";
							printf("%3c", '*');
						}
						else
						{
							//cout << vvDist[i][j] << " ";
							printf("%3d", vvDist[i][j]);
						}
					}
					std::cout << std::endl;
				}
				std::cout << std::endl;

				for (size_t i = 0; i < n; ++i)
				{
					for (size_t j = 0; j < n; ++j)
					{
						//cout << vvParentPath[i][j] << " ";
						printf("%3d", vvpPath[i][j]);
					}
					std::cout << std::endl;
				}
				std::cout << "=================================" << std::endl;
			}
		}
```

